{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/icp.png","path":"img/icp.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/1-Vue.md","hash":"40a2982df7b43d7578533013ff755788dba28ed0","modified":1631110554000},{"_id":"source/_posts/1-https.md","hash":"657b77b089f8ba34891ff097c5a8d43d10c95ae6","modified":1631172315211},{"_id":"source/_posts/1-webpack.md","hash":"ddbf2a1ee82e8fa2bef10fc3d8f6d9564509b5d9","modified":1631694685107},{"_id":"source/_posts/1.Bowser_GC.md","hash":"e893227b22b811ab77df3fdc16ee25fa402d22c2","modified":1631695206754},{"_id":"source/_posts/2-Vue.md","hash":"7ebc5080e0c84665a9127154f6e5dda0697f24e8","modified":1631110554000},{"_id":"source/_posts/2-webpack.md","hash":"bd9bf3e9dd5c3de9f818e20a4a1029d076564318","modified":1631694685112},{"_id":"source/_posts/3-Vue.md","hash":"1b248278494478c767afecfa024156b53b594ae4","modified":1631695015629},{"_id":"source/_posts/4-Vue.md","hash":"0b4ea54cc4eb180904a967eb95814941e1c53f16","modified":1631695015624},{"_id":"source/_posts/Algorithm-165.md","hash":"745ca219ba2ff2c83af27dc74d946231ea49fb90","modified":1645155577882},{"_id":"source/_posts/Algorithm-300.md","hash":"cdb6fb23bb03ac348869ae3f106f88c072bafe3d","modified":1649996898045},{"_id":"source/_posts/Algorithm-42.md","hash":"1ed4aae9b723a56f022044191e84071bee9c9182","modified":1647487525182},{"_id":"source/_posts/Algorithm-5.md","hash":"4b087a9c49f128cee15f527e920a36e60b261517","modified":1647311167191},{"_id":"source/_posts/Browser-Cross_domain.md","hash":"7f05bec1bf0bdb3ff6972a117aa3b4f7a09aba0a","modified":1638429958541},{"_id":"source/_posts/Browser-History.md","hash":"b471c5b98d8d74cd5ada08339724a981490ad7bf","modified":1638429958548},{"_id":"source/_posts/Browser-Render _Process.md","hash":"276fbbe6a723b3301de1b89048f2662eadb6d93a","modified":1638430013708},{"_id":"source/_posts/Browser-WebStorage.md","hash":"9e4611d9f1e930fc882702033211fa02ebe71df7","modified":1638430067927},{"_id":"source/_posts/HTML-all.md","hash":"0fd4069b7899c6c9203ccf811d241642a501c991","modified":1648611190990},{"_id":"source/_posts/Browser-Web_safety .md","hash":"46084d3d141476dbdf7fbf3977c7236ccecb30f0","modified":1638430019415},{"_id":"source/_posts/CSS-all.md","hash":"172ec96f85033b86a2a56ec47a94106db1c2f743","modified":1649993601883},{"_id":"source/_posts/Hexo.md","hash":"fa0dfe23bf47821573db32952ce90e468b601fd5","modified":1631695316164},{"_id":"source/_posts/Internet-DNS_CDN.md","hash":"778b1a9bc0948823286d3197ed77237bc213ec6f","modified":1637548888878},{"_id":"source/_posts/Internet-HTTP_Cache.md","hash":"2f4ffe5ecd4e2aab6d14901aa16f86c1b44e471c","modified":1637723226836},{"_id":"source/_posts/Internet-HTTP_detail.md","hash":"f40eb08fb9a1c83801212a903746cfd5bab7d035","modified":1637637950457},{"_id":"source/_posts/Internet-HTTP_history.md","hash":"cb61059598da1a079764f2697ad27994b128f14d","modified":1637637371007},{"_id":"source/_posts/Internet-TCP_UDP.md","hash":"d510c696002c655b130cfd1239a422e0fdf7f5e8","modified":1637548664205},{"_id":"source/_posts/Nginx-Install.md","hash":"e3ad122ef1a79c979be70d3a95947f44465a60ab","modified":1641452642371},{"_id":"source/_posts/Project-base64ToFile.md","hash":"b21f1a739509e8a73e7d629a0b169f0405ffd95d","modified":1647416181521},{"_id":"source/_posts/React.md","hash":"116e59be62b34f9a024a80b3a2e7f62a0702b7ca","modified":1631110555000},{"_id":"source/_posts/ReactFiber.md","hash":"b64e6755c0ca18eb4d96a054996d10d0c590d362","modified":1636338150086},{"_id":"source/_posts/Study-microApp.md","hash":"e0d661f5406bc408da567d3ac6aff69a8e42f218","modified":1647420584237},{"_id":"source/_posts/WebComponent.md","hash":"fb3bf37969dd7501a1cfbc31ac55381da3803a68","modified":1636338307013},{"_id":"source/_posts/WebpackLoader.md","hash":"98d0fbbc889bd7cce64401fbb5194e0b4045f8f4","modified":1636614382774},{"_id":"source/_posts/WebpackPlugin.md","hash":"c2262024014288d179ad5d4522e3045056865f6e","modified":1636613192155},{"_id":"source/_posts/Work-optimize.md","hash":"2fcbe1170f0eaed2f0557e40633547369125ecb4","modified":1648717977286},{"_id":"source/_posts/resource.md","hash":"f10dafc0e3c97b95d8a2ec2afb125d03f3ad645e","modified":1648191323187},{"_id":"source/_posts/vue3-newChacater.md","hash":"1c8eeeed6a135c5a018ac6d85615ecee0fd0964c","modified":1636343158716},{"_id":"themes/hexo-theme-butterfly/LICENSE","hash":"e7e7b7677bb19563a9013e936486bdefeb761d07","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/README.md","hash":"2ed9318e801ceab8da8f1bba9525cb5506721865","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/README_CN.md","hash":"d744fb96591aed26fa4b219924bcb269245cd9b0","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/_config.yml","hash":"1ddac8499a3aa09db9c3fe784e2045a987e1418d","modified":1649318123804},{"_id":"themes/hexo-theme-butterfly/github/ISSUE_TEMPLATE.md","hash":"8f7a0f8d4bfc97ba106128828a33a9cc0a295194","modified":1631110558000},{"_id":"themes/hexo-theme-butterfly/github/stale.yml","hash":"70467ce772e68de57a4bf2ac285f1c0b122f25f5","modified":1631110558000},{"_id":"themes/hexo-theme-butterfly/git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1631110555000},{"_id":"themes/hexo-theme-butterfly/package.json","hash":"3aa0062f45f127879be42c02095841c5d44041d3","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/git/config","hash":"91c62ea141283fa516461bd0e3bbb54ca7695ecb","modified":1631110555000},{"_id":"themes/hexo-theme-butterfly/git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1631110555000},{"_id":"themes/hexo-theme-butterfly/git/packed-refs","hash":"70e46de7620f664245b6efc885492a628a4a9582","modified":1631110558000},{"_id":"themes/hexo-theme-butterfly/git/index","hash":"abf321b55268b1f853ba36f7f1534eaed7b464a9","modified":1631110557000},{"_id":"themes/hexo-theme-butterfly/languages/default.yml","hash":"d20ee727e7f01cec360da6aff3133b82d61f3bb1","modified":1631110559000},{"_id":"themes/hexo-theme-butterfly/languages/en.yml","hash":"d20ee727e7f01cec360da6aff3133b82d61f3bb1","modified":1631110559000},{"_id":"themes/hexo-theme-butterfly/languages/zh-CN.yml","hash":"5a24e207960497fe7031dcdeebe6ec528ebd27be","modified":1631110559000},{"_id":"themes/hexo-theme-butterfly/languages/zh-TW.yml","hash":"d2ca0539070c98d4539646621c68c64059c3a123","modified":1631110559000},{"_id":"themes/hexo-theme-butterfly/layout/404.pug","hash":"43eb9777ec0243210df39f3be4926c42b8738985","modified":1631110559000},{"_id":"themes/hexo-theme-butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1631110560000},{"_id":"themes/hexo-theme-butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1631110559000},{"_id":"themes/hexo-theme-butterfly/layout/flink.pug","hash":"b2222e7cacd5b9e1b730ea52e3c1032623f5bd5e","modified":1631110560000},{"_id":"themes/hexo-theme-butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/page.pug","hash":"5cef945ed21199da6950cb3806d1faa45d3130c1","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/post.pug","hash":"ace5cefcd90d34e09119bedb064c34238f653687","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/tag.pug","hash":"e658aa76a11d1e18ec00131d9cec1a38b3d6a62e","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1631110555000},{"_id":"themes/hexo-theme-butterfly/git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1631110555000},{"_id":"themes/hexo-theme-butterfly/git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/fsmonitor-watchman.sample","hash":"55a762007dd48d229ef89fe8d0882256dcbee41a","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1631110556000},{"_id":"themes/hexo-theme-butterfly/git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1631110557000},{"_id":"themes/hexo-theme-butterfly/git/logs/HEAD","hash":"3076a09081a966a949c43472533f275ea3d19229","modified":1631110557000},{"_id":"themes/hexo-theme-butterfly/layout/includes/footer.pug","hash":"91ba9c2826c588011d6b28bb43b113287c79caae","modified":1631110563000},{"_id":"themes/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"cd757323bda770b16d51f5eb75299b9c7b280982","modified":1631110560000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head.pug","hash":"d99a94eb54a65b84b25c64a31f68002a8c255db2","modified":1631110565000},{"_id":"themes/hexo-theme-butterfly/layout/includes/layout.pug","hash":"d7cbb95e515155bb8e6657aa6e18f345332a2de6","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"b3abeb60790f6cbf2d110325bda27921949ac013","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"db722b3905c1f6ac750a1a851de09fbe2547837e","modified":1631110567000},{"_id":"themes/hexo-theme-butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"a70cce6dbd18db5c56ed13e992e013c96f7d542c","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/scripts/events/replace_config.js","hash":"39fabaae6943bbafb8248ee81ae9b32e1145c84a","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"8df2ec7c5fdee1dd86462103f6693774e338bec7","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"0a141c7d10b4467c0ad3d343dee54db0709bf7f0","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"cbdfab0bc5903ae8b84b21d153281f5c91e032d7","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"8e44ec5c9a50b01790186cb6c319b70a42581add","modified":1631110571000},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"0ad86baaa665efe0aaeaa979e9b2c77f6a28946b","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/tags/button.js","hash":"9c04a14213c0817ee1950e04fb020241b5137a99","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/page.js","hash":"4e6cffc4ecf5c600dc50b5677a21c3569e2ed043","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/tags/gallery.js","hash":"1735602a8da89b3ee961899c0eb4c9e6116b580c","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/tags/hide.js","hash":"f2f75f91d6cf2452e0c771735b9b7434afb718d1","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/tags/mermaid.js","hash":"46d3c4c6a38d750d1ad9ca695d6c0df62b7107d6","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/tags/note.js","hash":"b6acc0f4f994692d124c7a251a2606afde3fcf9d","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/scripts/tags/tabs.js","hash":"9dab568d42e560cbe178acec629a939e924034b0","modified":1631110572000},{"_id":"themes/hexo-theme-butterfly/source/css/index.styl","hash":"7c5f165d30a4ce07cb3c60bc10d3adab226fce27","modified":1631110573000},{"_id":"themes/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1631110577000},{"_id":"themes/hexo-theme-butterfly/source/css/var.styl","hash":"9dc81387006ae8edb0535029b7deb461e1cba964","modified":1631110573000},{"_id":"themes/hexo-theme-butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1631110577000},{"_id":"themes/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1631110577000},{"_id":"themes/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1631110577000},{"_id":"themes/hexo-theme-butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/main.js","hash":"006a34b962e6b5f1bc8aeaaf7be9044961defeae","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/utils.js","hash":"02e647fecbd78476925fb96762bd442ccfb8bd2f","modified":1631110579000},{"_id":"themes/hexo-theme-butterfly/source/js/tw_cn.js","hash":"bdc74e8ddaa6966822dba0e642cd278d819c4c74","modified":1631110579000},{"_id":"themes/hexo-theme-butterfly/git/objects/pack/pack-6a2a6775f009df694871c21f91e03bde098df9dc.idx","hash":"f04bb2b5ef823b87c5f3858bcc69278fbf2ee106","modified":1631110558000},{"_id":"themes/hexo-theme-butterfly/git/refs/heads/master","hash":"fcf778d423456a2e6e80aad0975d9f977dcbc144","modified":1631110558000},{"_id":"themes/hexo-theme-butterfly/layout/includes/chat/chatra.pug","hash":"f42e02bb6cddea021d0f2a8c2181186506ce1796","modified":1631110560000},{"_id":"themes/hexo-theme-butterfly/layout/includes/chat/daovoice.pug","hash":"6be9c4320f81ac818cd42d7b35e5035373f0eec4","modified":1631110560000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/disqus.pug","hash":"5ae50a271fe5a49f4012555657db028b7113612b","modified":1631110561000},{"_id":"themes/hexo-theme-butterfly/layout/includes/chat/gitter.pug","hash":"27afd01a1ac95fb0a8f0afcce084c0a88e713260","modified":1631110561000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/disqusjs.pug","hash":"a35e7a7f6694bf3f11c7a2137ff244ec30bb71ba","modified":1631110561000},{"_id":"themes/hexo-theme-butterfly/layout/includes/chat/tidio.pug","hash":"c00d323f3235576f98411785d4e70d58374bc55c","modified":1631110561000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/facebook_comments.pug","hash":"9d4ed57b91ad520b95d220980add8477ce968618","modified":1631110562000},{"_id":"themes/hexo-theme-butterfly/layout/includes/chat/index.pug","hash":"fc636bbe089b93a58e482c265d3d4e8dd7a36582","modified":1631110561000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/index.pug","hash":"0c386937c41174df327d5b77c17395484b6006ac","modified":1631110562000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/gitalk.pug","hash":"bb4de1b40ae07b27dda4e3e529687f6c1a9196ca","modified":1631110562000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/livere.pug","hash":"eb247e71b67f7ad53d519dd5776df92b198755e4","modified":1631110562000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/utterances.pug","hash":"8ef3dc1a27c19645ac054e30594ed1930b1c56f0","modified":1631110562000},{"_id":"themes/hexo-theme-butterfly/layout/includes/comments/valine.pug","hash":"c277f58fabe5fce8d24bfb47c66cbbdcd7fe613e","modified":1631110563000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"e613797213428031543952fd7ea262225c94013c","modified":1631110564000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"036213b05df9e51250c2734854de7a096a9ed8c2","modified":1631110563000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"ef72a6457c58c925ba4d8154f79a0ed5837d4903","modified":1631110563000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/comment.pug","hash":"2dbb3378929e2f1ead3bbc4a88fafd72c6632ff8","modified":1631110563000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/aplayer.pug","hash":"eb18647e15acbf0f9faf9c56bc43cecc6c3069b1","modified":1631110563000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"98e7f4d5609a7167826458a2c7c353082eb5b2a7","modified":1631110564000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/darkmode.pug","hash":"7eba82bb9058c98285d2f2af889d6b8bc444668c","modified":1631110564000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"393e641a35174f26318b8724eddaf1a0b1386636","modified":1631110564000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"90bb6775573c78b337f809400246d475eed89564","modified":1631110564000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"9f2bdadd5c8b8fd0cbe5256b54963d1617a2369f","modified":1631110564000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"e4fb9e5c72ca05d595f0959893c2fe03b8f478e2","modified":1631110565000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"2d267fcc926505fcc5ebc9f59146555b32654c7e","modified":1631110565000},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/subtitle.pug","hash":"16a55d395fe74d31723b5b1c13ac391c05b6f6e6","modified":1631110565000},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"499b85f6d68b9a7cd889a99e081cadb8c65c7354","modified":1631110565000},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"bc58b81f75c72c6b1178f16b3488b93d8a76c2b3","modified":1631110565000},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"330cf354ffbde0d7f24da1c65a2c08f3005e0c13","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/loading/loading-js.pug","hash":"3a605e29a0607c315c0566f2a1c6487b4aa98140","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/math/index.pug","hash":"403601a903d02ef0a103d18909a6eb0b088fcb4c","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"c9f783639b9dccadf7692e6dab8ef1660d19c2b7","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/math/katex.pug","hash":"60bd18e051a442d5ce25325a55982922ab15be04","modified":1631110566000},{"_id":"themes/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"2eb98df02f2ff9cefeb6db0a6c681a3e8172e732","modified":1631110567000},{"_id":"themes/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"6cac73eb3f87e44e853eee3206f263c396e4b6a5","modified":1631110567000},{"_id":"themes/hexo-theme-butterfly/layout/includes/math/mathjax.pug","hash":"9f10622c73c2c87d3502660eb933af654d2600b4","modified":1631110567000},{"_id":"themes/hexo-theme-butterfly/layout/includes/math/mermaid.pug","hash":"41f6c6c9d753ed97ab2adef47f13595f8aebb464","modified":1631110567000},{"_id":"themes/hexo-theme-butterfly/layout/includes/mobile-sidebar/index.pug","hash":"e9eacd936c259d8f10e1becdd6e3ca129ea0e942","modified":1631110567000},{"_id":"themes/hexo-theme-butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"eaaf1ff602121b6e2a3df602eeb80c4047a5d2f3","modified":1631110567000},{"_id":"themes/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"547a2737cd3ac45272a75561f5b5438d72d10f6d","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"18ed72185fe1b95f7a70a01d0601fc1b7b800f2e","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/search/algolia.pug","hash":"345280a843c43a6a600fcd74978ccba2354b7e7f","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/search/index.pug","hash":"66b4f4e8119e987cd3f9907298689a1408a05859","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/search/local-search.pug","hash":"f48686684bf322b3967fe6fa892e0b244d1394f8","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/share/index.pug","hash":"af2f09d374a55983d1ac695848ccfae50629f439","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/share/share-js.pug","hash":"43643295be651fb3d2cd88ebf81544fde3131489","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/share/addtoany.pug","hash":"4108ab6b91461254901f19ed3e5e082e437324aa","modified":1631110568000},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"44af3c7a67b86f048deacb451dd454b088631374","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"74fc2a62e125f28947ec9cd60f968023da766adb","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"86f1c36a3092fdaae239cb7129526966b96c6cda","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"59d1096a1bb04c9559367d54d90186afcc115850","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"7450c5bae8aa422c39504a3574f97ef1709d1779","modified":1631110569000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"ca4858ed872c43334f05ce0f444385529b677188","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"40923d59c452d2a71195ddf1a8e3b840f27ef560","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"65597e263ca020622ce3947db97284ff3a871217","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e55f16e8aef805bc7c66eb3147394a83e1623476","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"cde114449d959e8e8d208eea584edc8c404e1759","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"6ef8482c9e8b9ac3ab06e48e69853ac536836905","modified":1631110570000},{"_id":"themes/hexo-theme-butterfly/source/css/_global/function.styl","hash":"6a0561b9cbc880224cdc57f1a59898bb8511711b","modified":1631110573000},{"_id":"themes/hexo-theme-butterfly/source/css/_global/index.styl","hash":"4f4dfc78cd11ece75db733940948a37bf4050c1d","modified":1631110573000},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/diff.styl","hash":"53e1765a4097369072d91be83cd5ea2461b29762","modified":1631110573000},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"17598674ae0b2778b8e831b4e112ea4bf226e025","modified":1631110573000},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"011728deca7b8e7ffb7d5278f078bcfaa3407295","modified":1631110573000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/404.styl","hash":"88bfb709c6f0483b98ee1338c8169bba3c25a25c","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"da4b18fe45ea6a771e1a53e138b8b69bf8399f94","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/category.styl","hash":"b5bca389c3185b2794939f0f5dd889e1ed72f6cc","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/flink.styl","hash":"db112eff3c87857dc706ec8919a808dadb56f2e9","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"2dace492e6da44e39ad5cc7eae8bc8bb5a34aaae","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"48eae21acb25847794ca9094c73d295bd540e525","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/loadding.styl","hash":"7acbbed062bf4070ef998e760491f436b2629738","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/mobile-sidebar.styl","hash":"12cdf8e436bae03869b312e8353aa25e1c604161","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/page.styl","hash":"613e1ec7ae7cb81d71a1284052a2d74b9b6bb48c","modified":1631110574000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"941bbc113732135cb691f1848a1d532856bb0c30","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"60b20a928c626d506934552fc435b71349c6864b","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"31b0be8844fb29fcf6aa8e759bc58385f92253a0","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"d790cb4e120dede0b26ce7739da95ad556406dbf","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"b0eb47b9d01164e10cf35c11bb89729fd3022e5e","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"d1ad6bbdedf8bead2b0b18519629c731afbab49d","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"7d51ea839eb824da07a450cc0ad0aef643e2a69d","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"2f04e3e0ccfe26c38ad721dbb93521f1d38dd464","modified":1631110575000},{"_id":"themes/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"4f1774d69ab9a0174739d8522a5b8c1bd0e582f7","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"55fc3a91dfbd8f15aab2595fb0c68d3981edb629","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1631110577000},{"_id":"themes/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"0c293c8e72ec7e2432d46eef666b8db16ca6e826","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_search/index.styl","hash":"9e90117c80772ac4f45a97be685e7ab4c6b70a41","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"2f009c58a80e6ebd6e314fa7e0890246cbad4fab","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"7382e74fcfd711699dac91a504dc94898e5ecd6e","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"3a44135ebba2cc089869242d7f30c7e9219abeb5","modified":1631110576000},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"82903068b1e50d7b326548fa628b55bf03d72536","modified":1631110577000},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"fd1ba8567c1b80777f0711d8a925d08d9a40d40b","modified":1631110577000},{"_id":"themes/hexo-theme-butterfly/source/js/search/algolia.js","hash":"9d38898a997e65127a65d7f286113b14af94ceba","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/search/local-search.js","hash":"7ed0e03733127dd34dc251f5b36e3e7eadd73097","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/ClickShowText.js","hash":"2af6ddbabdd36979cc9c05b117452a1534702c6d","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/canvas-nest.js","hash":"ed2a7dedc314eb1047d030be2e95d0d5679bc577","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/canvas-ribbon.js","hash":"c345ea68e37caabe8d8f48af41837ccb86952cd5","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/click_heart.js","hash":"7295ee03e9ae40f855d0c494a9b84e76a36ffe20","modified":1631110578000},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/piao.js","hash":"bc3d3f2afeefea55d9d6ba8dfa798435e1eb1062","modified":1631110579000},{"_id":"themes/hexo-theme-butterfly/source/js/third-party/fireworks.js","hash":"75b3d7025c01947f3d425e592e910458393ee621","modified":1631110579000},{"_id":"themes/hexo-theme-butterfly/git/logs/refs/heads/master","hash":"3076a09081a966a949c43472533f275ea3d19229","modified":1631110557000},{"_id":"themes/hexo-theme-butterfly/git/refs/remotes/origin/HEAD","hash":"2c142208129b78a4616cbb6798f96f4fb3580296","modified":1631110558000},{"_id":"themes/hexo-theme-butterfly/git/logs/refs/remotes/origin/HEAD","hash":"f3b661b85b5b74bac5eb7d4a41e23631107bf951","modified":1631110558000},{"_id":"themes/hexo-theme-butterfly/git/objects/pack/pack-6a2a6775f009df694871c21f91e03bde098df9dc.pack","hash":"56e1899672e2b7016297c8016c815455b652ca73","modified":1631110566000},{"_id":"public/2022/04/15/CSS-all/index.html","hash":"6becab80b7f0c1038949a94456aedf531dcf75a5","modified":1649996906076},{"_id":"public/2022/04/05/Algorithm-300/index.html","hash":"5e9f4609052bbcd9ffc643b19039f2c48b0e553c","modified":1649996906076},{"_id":"public/2022/03/31/Work-optimize/index.html","hash":"97ae48c5337dcb978f40559900663e9acd7bdb25","modified":1649996906076},{"_id":"public/2022/03/30/HTML-all/index.html","hash":"7387a2d1d22a05cdb60bb64b2e13cfce4f4cd120","modified":1649996906076},{"_id":"public/2022/03/17/Algorithm-42/index.html","hash":"51c92e36ec5014a2ca2f3c7260d7cede9ef42fba","modified":1649996906076},{"_id":"public/2022/03/16/Study-microApp/index.html","hash":"e2cac29a1ed04ac503226fc6f52da9f84883550a","modified":1649996906076},{"_id":"public/2022/03/15/Algorithm-5/index.html","hash":"eb9cbd4c71f4d1ce2f2fce4ff15882338b4d8d5e","modified":1649996906076},{"_id":"public/2022/01/12/Project-base64ToFile/index.html","hash":"283b1abff08db41cb1295954c95d0b0e81d9798e","modified":1649996906076},{"_id":"public/2022/01/06/Nginx-Install/index.html","hash":"8fffd4a12440e2d009345ccbc2c4183ed8209df6","modified":1649996906076},{"_id":"public/2021/12/22/Algorithm-165/index.html","hash":"5b1b65118947c388bf2f04cf354d502feead5d4d","modified":1649996906076},{"_id":"public/2021/12/02/Browser-WebStorage/index.html","hash":"b487b9cbdbfb1886c2d57bf27ee4dcec29fe1526","modified":1649996906076},{"_id":"public/2021/11/30/Browser-Web_safety /index.html","hash":"9b8da765e5fbee730042a9466a35a28c8806065c","modified":1649996906076},{"_id":"public/2021/11/28/Browser-Render _Process/index.html","hash":"7b24ff31d67d29063a9e183b0eb314abc1a9454b","modified":1649996906076},{"_id":"public/2021/11/27/Browser-Cross_domain/index.html","hash":"b600c01759c79cf54ef9fa38e4b31ea39e16fef6","modified":1649996906076},{"_id":"public/2021/11/25/Browser-History/index.html","hash":"07f0acc67dd66019ad97f04d5f97558f0c176034","modified":1649996906076},{"_id":"public/2021/11/24/Internet-HTTP_Cache/index.html","hash":"3c9f176a15ab1e8b9eb65773e40f0c7f607a122f","modified":1649996906076},{"_id":"public/2021/11/23/Internet-HTTP_detail/index.html","hash":"2699a71993c182096ba5befe79046d2242881be8","modified":1649996906076},{"_id":"public/2021/11/23/Internet-HTTP_history/index.html","hash":"ce25bdaf2cbfb166199a9a6aa25820afb5f60bc2","modified":1649996906076},{"_id":"public/2021/11/22/Internet-DNS_CDN/index.html","hash":"bc9fc969b5eb11dc5ea8a2cd0926bcb10c2954d8","modified":1649996906076},{"_id":"public/2021/11/19/Internet-TCP_UDP/index.html","hash":"07df5607fed0bad0147ad8be4f2e34c762be5883","modified":1649996906076},{"_id":"public/2021/11/11/WebpackLoader/index.html","hash":"1d0204d6826f81d490bdf529968616c9bdd33a86","modified":1649996906076},{"_id":"public/2021/11/11/WebpackPlugin/index.html","hash":"37a88d97daaa4a2ec3c58efcdf1b98863c6d5eeb","modified":1649996906076},{"_id":"public/2021/11/08/WebComponent/index.html","hash":"c0473aca7605640edeea6a914572048a3230f4dc","modified":1649996906076},{"_id":"public/2021/11/08/ReactFiber/index.html","hash":"fbf9db4463743fea8b2878b4776f817dab906ba9","modified":1649996906076},{"_id":"public/2021/10/22/vue3-newChacater/index.html","hash":"9d0eac666e89fe2e83c204cf601a7404c72035d5","modified":1649996906076},{"_id":"public/2021/09/30/resource/index.html","hash":"5e52adaf22d8182589ba45f623323e1b1cd9fe7e","modified":1649996906076},{"_id":"public/2021/09/15/1.Bowser_GC/index.html","hash":"4fc414d678bbfcf168fa1f770fc5cd48ee894aab","modified":1649996906076},{"_id":"public/2021/09/09/Hexo/index.html","hash":"baec38d256c9c7a5102f4e6c3b5d1bfc5f862f04","modified":1649996906076},{"_id":"public/2021/09/09/1-https/index.html","hash":"1243d6f3d8b93054646f4e453460ed1a53c1b50f","modified":1649996906076},{"_id":"public/2020/06/22/React/index.html","hash":"7777d52f2b9f4d41848cf062fa20060154c755db","modified":1649996906076},{"_id":"public/2020/02/29/2-webpack/index.html","hash":"7b9794458aefc3a9075692243ff25cae12b4c942","modified":1649996906076},{"_id":"public/2020/02/28/1-webpack/index.html","hash":"20946af38f141853bf83efa98a2145303e160970","modified":1649996906076},{"_id":"public/2020/02/24/4-Vue/index.html","hash":"2847a0a0e93b5812139f0450e6028b8b20516b8d","modified":1649996906076},{"_id":"public/2020/02/24/3-Vue/index.html","hash":"f8d231843a6ccd690882bfaced698bc8285cb1e1","modified":1649996906076},{"_id":"public/2020/02/24/2-Vue/index.html","hash":"9bf3d042ddc0e7d0933466b0afc7951b543f8051","modified":1649996906076},{"_id":"public/2020/02/24/1-Vue/index.html","hash":"9d7478694650150b093198cc905efe778948035b","modified":1649996906076},{"_id":"public/archives/index.html","hash":"d8fa0a50a598349a857b313f0475232c396ea12d","modified":1649996906076},{"_id":"public/archives/page/2/index.html","hash":"7cb5f56c218550c5c206101a1b099a34cddd7459","modified":1649996906076},{"_id":"public/archives/page/3/index.html","hash":"6c77ea198427c696f658d3e0d0e4d487383e90d8","modified":1649996906076},{"_id":"public/archives/page/4/index.html","hash":"83efcd6e03170f19e2609a4ba78503fd8b7c3e82","modified":1649996906076},{"_id":"public/archives/2020/index.html","hash":"2e4359a0e46b20cd3111cd2d56761763f8a984c9","modified":1649996906076},{"_id":"public/archives/2020/02/index.html","hash":"a00cc0e75234f3074e18bfa696097c62087a4c11","modified":1649996906076},{"_id":"public/archives/2020/06/index.html","hash":"4e4ba91e76113c08f6a1198e6b0ac4828500a538","modified":1649996906076},{"_id":"public/archives/2021/index.html","hash":"afae3149c72064035eae1219ef0cfa7eca99fb2f","modified":1649996906076},{"_id":"public/archives/2021/page/2/index.html","hash":"bfbe94e91de5584c50c48a019403529f6552364e","modified":1649996906076},{"_id":"public/archives/2021/09/index.html","hash":"c340499555c080e58b9f89716c93933ffebb35e6","modified":1649996906076},{"_id":"public/archives/2021/10/index.html","hash":"9eb8ebb0573e3c66a92337053d50bb0804815d61","modified":1649996906076},{"_id":"public/archives/2021/11/index.html","hash":"77e8596c56185a7b6e9e357a831dfc107dd9ff1f","modified":1649996906076},{"_id":"public/archives/2021/11/page/2/index.html","hash":"e9ce93a583ecf62a0049fd7a464726c4f6aca4e4","modified":1649996906076},{"_id":"public/archives/2021/12/index.html","hash":"57f8746538b205e91f33d82680d4b0737f813281","modified":1649996906076},{"_id":"public/archives/2022/index.html","hash":"efc57da9511cce5cb364ea779627699be75d4344","modified":1649996906076},{"_id":"public/archives/2022/01/index.html","hash":"7b242abc21e9ac5dcaccb01d1cd7322e4b221e95","modified":1649996906076},{"_id":"public/archives/2022/03/index.html","hash":"3a8c63340283d9dd19d89a13b3c677a4fb1633e6","modified":1649996906076},{"_id":"public/archives/2022/04/index.html","hash":"656806c30404b79a94efc523b75913da303416f8","modified":1649996906076},{"_id":"public/page/2/index.html","hash":"2ced71f2c6dc388d77374e1cbf344c8f018bb5e9","modified":1649996906076},{"_id":"public/index.html","hash":"869811435a8e4f144b5ade79df15cf86f4f3f014","modified":1649996906076},{"_id":"public/page/3/index.html","hash":"1ab0e4a90f73c824cc77536ce1110e4dcf026cd0","modified":1649996906076},{"_id":"public/page/4/index.html","hash":"4f2ae49d014e82304cdb8249909c13474a849456","modified":1649996906076},{"_id":"public/tags/http/index.html","hash":"a469198d6cebf0f33914e4d9bc46c18f6aebed5a","modified":1649996906076},{"_id":"public/tags/vue/index.html","hash":"a2b60845405184e6b6cbae6c54b4fc4fd1c6a3e6","modified":1649996906076},{"_id":"public/tags/浏览器/index.html","hash":"a9a814634696f20ace083591a40867ea1b817a95","modified":1649996906076},{"_id":"public/tags/webpack/index.html","hash":"ef5ba45264d10a09a49e1df7d24ce2eadfa23112","modified":1649996906076},{"_id":"public/tags/算法/index.html","hash":"a2ed5ab88cc266661cf545c415cfea1859a3af58","modified":1649996906076},{"_id":"public/tags/CSS/index.html","hash":"1ac292317dfa05d6a9ae9ba6e43c9e0fda17e9e5","modified":1649996906076},{"_id":"public/tags/HTML/index.html","hash":"b809ffa970f7c82a736f4d0253ffdebcfde57a87","modified":1649996906076},{"_id":"public/tags/网络/index.html","hash":"ed89d0b90b348db6847763ff6f433e594725d34e","modified":1649996906076},{"_id":"public/tags/服务器/index.html","hash":"66c62be4b0ccd873c26cd00636d25ebaec0739da","modified":1649996906076},{"_id":"public/tags/项目/index.html","hash":"4228ff5d653b03c56112ffc32269f109e4bd17b8","modified":1649996906076},{"_id":"public/tags/React/index.html","hash":"3b6e9eb74753dbc466fc28bc8962ab8fa31f987f","modified":1649996906076},{"_id":"public/tags/react/index.html","hash":"d18f9994a581e92aacbc0a9cde1a5ded619b22c3","modified":1649996906076},{"_id":"public/tags/微前端/index.html","hash":"15d99aa9f71784a63a18a172bd0b498c84c4a5b0","modified":1649996906076},{"_id":"public/tags/component/index.html","hash":"ff3d7b01f8834ab597339fa0113186c7bfeb52b6","modified":1649996906076},{"_id":"public/tags/WORK/index.html","hash":"8421208a8c3b33e6f933f4a97572abdb200acaab","modified":1649996906076},{"_id":"public/categories/http/index.html","hash":"04cd4ee5bb3bcd3eff6e65adfe1ddb44d492538c","modified":1649996906076},{"_id":"public/categories/vue/index.html","hash":"4869679520a70a6df6b10be86f4a213ddf0f3f9d","modified":1649996906076},{"_id":"public/categories/浏览器/index.html","hash":"a31ce9b9c442e5f33543a05fe1cab6555aac5c3e","modified":1649996906076},{"_id":"public/categories/webpack/index.html","hash":"64537da3c40a03e140380bd0e6de20dfc8ae25fd","modified":1649996906076},{"_id":"public/categories/算法/index.html","hash":"5dcc9fafcfefa58d49b82ebfbfecea11f0fe7dc3","modified":1649996906076},{"_id":"public/categories/CSS/index.html","hash":"4b835e37dbca0b27a293e1c883de4b2551f310ef","modified":1649996906076},{"_id":"public/categories/HTML/index.html","hash":"302eb869cd99c0cc833387938769ed90fb5aeb5a","modified":1649996906076},{"_id":"public/categories/网络/index.html","hash":"e1b2c8b1cc084621fb13f244fcd934e2eafe7138","modified":1649996906076},{"_id":"public/categories/服务器/index.html","hash":"a3944ba954d3465b25364dba9357025d0367846f","modified":1649996906076},{"_id":"public/categories/项目/index.html","hash":"f3a19fc643db17109093f757a990e77ae31f132a","modified":1649996906076},{"_id":"public/categories/React/index.html","hash":"ef91dde00edadc1d086d1dcceca9fb7a4304b29d","modified":1649996906076},{"_id":"public/categories/react/index.html","hash":"e2b60d1f48d5b05b5a5eae5148a458ed838a6c03","modified":1649996906076},{"_id":"public/categories/微前端/index.html","hash":"9134e0aeb5e55a3ceeaff1089e67740ed6bcd08c","modified":1649996906076},{"_id":"public/categories/component/index.html","hash":"e4f5b0809cad452b50e5436cd86b4c052c5f4e86","modified":1649996906076},{"_id":"public/categories/项目优化/index.html","hash":"b8ff4335665f41862f3aeccda81ed830a4810b08","modified":1649996906076},{"_id":"public/categories/resource/index.html","hash":"0751b6c935bab907d906270e07693a9c19f422de","modified":1649996906076},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1649996906076},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1649996906076},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1649996906076},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1649996906076},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1649996906076},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1649996906076},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1649996906076},{"_id":"public/css/index.css","hash":"4127bbb8c6a08f2e16a10398f38b102d166317d0","modified":1649996906076},{"_id":"public/js/utils.js","hash":"43da5a9129aa827dc5c311b0e5e3a12ccc61b488","modified":1649996906076},{"_id":"public/js/search/algolia.js","hash":"5ff5cb40d5ede73b48594d331244ada001154dac","modified":1649996906076},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1649996906076},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1649996906076},{"_id":"public/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1649996906076},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"1ddf4f6896175e77518f0fbd45776132b2954fb6","modified":1649996906076},{"_id":"public/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1649996906076},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1649996906076},{"_id":"public/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1649996906076},{"_id":"public/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1649996906076},{"_id":"public/js/main.js","hash":"9772cdb841b527406473730faf523aa942d4dbb2","modified":1649996906076},{"_id":"public/js/tw_cn.js","hash":"030ad26843c22f6a5f91a40200c65d079a4f8475","modified":1649996906076}],"Category":[{"name":"http","_id":"cl1zxk1l80002dswkfdzs8i72"},{"name":"vue","_id":"cl1zxk1lc0007dswk1fdk33tw"},{"name":"浏览器","_id":"cl1zxk1le000ddswkc8m1cdi1"},{"name":"webpack","_id":"cl1zxk1lg000kdswk21re7sal"},{"name":"算法","_id":"cl1zxk1lp0015dswk68wc4wv7"},{"name":"CSS","_id":"cl1zxk1lz001zdswk4ek09288"},{"name":"HTML","_id":"cl1zxk1m00024dswkabm0bq5v"},{"name":"网络","_id":"cl1zxk1m4002cdswk8d23hys7"},{"name":"服务器","_id":"cl1zxk1ma002wdswk149f5ypk"},{"name":"项目","_id":"cl1zxk1me0033dswk76dp5lsi"},{"name":"React","_id":"cl1zxk1mg0039dswk73mk70xd"},{"name":"react","_id":"cl1zxk1mi003hdswkfkhwbpwx"},{"name":"微前端","_id":"cl1zxk1mk003pdswkhiho1yd1"},{"name":"component","_id":"cl1zxk1ml003vdswk0l7b654p"},{"name":"项目优化","_id":"cl1zxk1mm003zdswk6zrt3d9x"},{"name":"resource","_id":"cl1zxk1mm0043dswk4dm33iks"}],"Data":[],"Page":[],"Post":[{"title":"HTTPS解决的问题","date":"2021-09-09T05:08:20.000Z","description":"有了大家熟悉的HTTP之后，为什么还会诞生HTTPS呢？ 那是因为HTTP存在很多问题，比如：无状态、不安全等 而HTTPS不是一个新的协议，其实只是相当对HTTP安全的一个升级。在介绍HTTPS之前先介绍一下HTTP存在的安全问题。","cover":"https://i.loli.net/2021/09/09/G1PReNVLltUcMmX.jpg","_content":"\n### HTTPS解决的问题\n\n有了大家熟悉的HTTP之后，为什么还会诞生HTTPS呢？\n\n那是因为HTTP存在很多问题，比如：无状态、不安全等\n\n而HTTPS不是一个新的协议，其实只是相当对HTTP安全的一个升级。在介绍HTTPS之前先介绍一下HTTP存在的安全问题。\n\n* 明文传输\n* 不知道服务器是不是我们要请求的服务器（中间人攻击）\n* 客户端和服务器拿到对方的数据是不是真实，有可能被黑客获取修改了\n\n而HTTPS就解决了这些问题。主要解决的方式如下：\n\n1. 数字证书\n\n数字证书主要解决了确认请求的服务器是安全的。数字证书是由一些官方机构发放的，当然是需要收费的。在建立HTTPS连接的时候，客户端向服务器发送请求，服务器会把自己的数字证书发送给客户端，客户端拿到之后，浏览器会自动去验证这个证书的真实性，如果证书是假的，那么浏览器就会报错，也就是我们常看到的浏览器提示该网站不安全。如果证书验证通过，客户端就可以继续发送请求。\n\n2. 密文传输\n\n密文传输肯定就是解决明文传输的问题了，那它是怎么加密的呢？在此之前先介绍一下对称加密和非对称加密。\n\n* 对称加密\n\n通过名字就可以看出，对称加密其实就是使用同一个密钥进行加密或解密。服务器使用私钥将数据加密，然后将加密后的数据和密钥一起发送给客户端，客户端在使用解密数据使用。其实大家既可以发现这种加密方式很不安全，一旦黑客截取到了这个私钥，那么就可以拿到数据。所以就有了非对称加密。\n\n* 非对称加密\n\n非对称加密就是使用私钥加密，就只能用公钥解密，同理，用公钥加密就只能使用私钥解密。服务器先将公钥发送给客户端，然后使用私钥将数据加密，然后将加密的数据和公钥同时传送到客户端。这样就算黑客截取到数据，没用公钥也就拿不到数据。但是还是有风险，服务器把公钥发送给客户端的时候，同样由被截取的风险，那么怎样才能安全的将公钥送到客户端呢？\n\n这个时候就是HTTPS登场了，HTTPS的加密方式结合了两种加密方式，首先使用非对称加密将对称加密要使用的密钥发送给服务器。具体流程如下：\n\n> 首先服务器将公钥发送给客户端\n>\n> 客户端生成一个对称加密的密钥，然后使用服务器的公钥将密钥加密，发送给服务器\n>\n> 服务器再通过自己的私钥解密拿到密钥\n>\n> 然后接下来的传输数据就使用这个密钥进行传输\n\n但是将才说了，公钥传送给客户端是有被截取的风险的，那怎样才能安全的将公钥传送给客户端呢？\n\n这就要用到我们说的数字证书了，数字证书不是为了确认服务器的真实性嘛，那我就把公钥放在这个数字证书中，这样服务器既能证明自己的身份，又能将公钥传送到客户端。然后客户端就可以按照之前的流程继续操作了。\n\n3. 数字签名\n\n还有最后一个问题就是数据再传输的过程中可能被黑客截取修改，这个时候就使用到了数字证书，服务器通过将数据某个加密算法计算出一个摘要，然后将这个摘要一起发送到客户端，客户端拿到数据之后，再使用同样的加密算法计算出数据的摘要，然后和服务器发送过来的摘要进行比对，如果相同说明没有被修改，相反，那个这个数据就已经被修改了。\n\n#### 总结\n\nHTTPS的诞生主要是为了解决HTTP存在的一些安全问题，当然HTTPS虽然解决了这些问题，但是也是有代价的，他的连接速度没有HTTP快，当然这种连接速度是可以接受的，还有就是数字证书是需要申请和收费的。\n\n","source":"_posts/1-https.md","raw":"---\ntitle: HTTPS解决的问题\ndate: 2021-09-09 13:08:20\ncategories: http\ntags: [http]\ndescription: 有了大家熟悉的HTTP之后，为什么还会诞生HTTPS呢？ 那是因为HTTP存在很多问题，比如：无状态、不安全等 而HTTPS不是一个新的协议，其实只是相当对HTTP安全的一个升级。在介绍HTTPS之前先介绍一下HTTP存在的安全问题。\ncover: https://i.loli.net/2021/09/09/G1PReNVLltUcMmX.jpg\n---\n\n### HTTPS解决的问题\n\n有了大家熟悉的HTTP之后，为什么还会诞生HTTPS呢？\n\n那是因为HTTP存在很多问题，比如：无状态、不安全等\n\n而HTTPS不是一个新的协议，其实只是相当对HTTP安全的一个升级。在介绍HTTPS之前先介绍一下HTTP存在的安全问题。\n\n* 明文传输\n* 不知道服务器是不是我们要请求的服务器（中间人攻击）\n* 客户端和服务器拿到对方的数据是不是真实，有可能被黑客获取修改了\n\n而HTTPS就解决了这些问题。主要解决的方式如下：\n\n1. 数字证书\n\n数字证书主要解决了确认请求的服务器是安全的。数字证书是由一些官方机构发放的，当然是需要收费的。在建立HTTPS连接的时候，客户端向服务器发送请求，服务器会把自己的数字证书发送给客户端，客户端拿到之后，浏览器会自动去验证这个证书的真实性，如果证书是假的，那么浏览器就会报错，也就是我们常看到的浏览器提示该网站不安全。如果证书验证通过，客户端就可以继续发送请求。\n\n2. 密文传输\n\n密文传输肯定就是解决明文传输的问题了，那它是怎么加密的呢？在此之前先介绍一下对称加密和非对称加密。\n\n* 对称加密\n\n通过名字就可以看出，对称加密其实就是使用同一个密钥进行加密或解密。服务器使用私钥将数据加密，然后将加密后的数据和密钥一起发送给客户端，客户端在使用解密数据使用。其实大家既可以发现这种加密方式很不安全，一旦黑客截取到了这个私钥，那么就可以拿到数据。所以就有了非对称加密。\n\n* 非对称加密\n\n非对称加密就是使用私钥加密，就只能用公钥解密，同理，用公钥加密就只能使用私钥解密。服务器先将公钥发送给客户端，然后使用私钥将数据加密，然后将加密的数据和公钥同时传送到客户端。这样就算黑客截取到数据，没用公钥也就拿不到数据。但是还是有风险，服务器把公钥发送给客户端的时候，同样由被截取的风险，那么怎样才能安全的将公钥送到客户端呢？\n\n这个时候就是HTTPS登场了，HTTPS的加密方式结合了两种加密方式，首先使用非对称加密将对称加密要使用的密钥发送给服务器。具体流程如下：\n\n> 首先服务器将公钥发送给客户端\n>\n> 客户端生成一个对称加密的密钥，然后使用服务器的公钥将密钥加密，发送给服务器\n>\n> 服务器再通过自己的私钥解密拿到密钥\n>\n> 然后接下来的传输数据就使用这个密钥进行传输\n\n但是将才说了，公钥传送给客户端是有被截取的风险的，那怎样才能安全的将公钥传送给客户端呢？\n\n这就要用到我们说的数字证书了，数字证书不是为了确认服务器的真实性嘛，那我就把公钥放在这个数字证书中，这样服务器既能证明自己的身份，又能将公钥传送到客户端。然后客户端就可以按照之前的流程继续操作了。\n\n3. 数字签名\n\n还有最后一个问题就是数据再传输的过程中可能被黑客截取修改，这个时候就使用到了数字证书，服务器通过将数据某个加密算法计算出一个摘要，然后将这个摘要一起发送到客户端，客户端拿到数据之后，再使用同样的加密算法计算出数据的摘要，然后和服务器发送过来的摘要进行比对，如果相同说明没有被修改，相反，那个这个数据就已经被修改了。\n\n#### 总结\n\nHTTPS的诞生主要是为了解决HTTP存在的一些安全问题，当然HTTPS虽然解决了这些问题，但是也是有代价的，他的连接速度没有HTTP快，当然这种连接速度是可以接受的，还有就是数字证书是需要申请和收费的。\n\n","slug":"1-https","published":1,"updated":"2021-09-09T07:25:15.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1kz0000dswkfk2nhy3k","content":"<h3 id=\"HTTPS解决的问题\"><a href=\"#HTTPS解决的问题\" class=\"headerlink\" title=\"HTTPS解决的问题\"></a>HTTPS解决的问题</h3><p>有了大家熟悉的HTTP之后，为什么还会诞生HTTPS呢？</p>\n<p>那是因为HTTP存在很多问题，比如：无状态、不安全等</p>\n<p>而HTTPS不是一个新的协议，其实只是相当对HTTP安全的一个升级。在介绍HTTPS之前先介绍一下HTTP存在的安全问题。</p>\n<ul>\n<li>明文传输</li>\n<li>不知道服务器是不是我们要请求的服务器（中间人攻击）</li>\n<li>客户端和服务器拿到对方的数据是不是真实，有可能被黑客获取修改了</li>\n</ul>\n<p>而HTTPS就解决了这些问题。主要解决的方式如下：</p>\n<ol>\n<li>数字证书</li>\n</ol>\n<p>数字证书主要解决了确认请求的服务器是安全的。数字证书是由一些官方机构发放的，当然是需要收费的。在建立HTTPS连接的时候，客户端向服务器发送请求，服务器会把自己的数字证书发送给客户端，客户端拿到之后，浏览器会自动去验证这个证书的真实性，如果证书是假的，那么浏览器就会报错，也就是我们常看到的浏览器提示该网站不安全。如果证书验证通过，客户端就可以继续发送请求。</p>\n<ol start=\"2\">\n<li>密文传输</li>\n</ol>\n<p>密文传输肯定就是解决明文传输的问题了，那它是怎么加密的呢？在此之前先介绍一下对称加密和非对称加密。</p>\n<ul>\n<li>对称加密</li>\n</ul>\n<p>通过名字就可以看出，对称加密其实就是使用同一个密钥进行加密或解密。服务器使用私钥将数据加密，然后将加密后的数据和密钥一起发送给客户端，客户端在使用解密数据使用。其实大家既可以发现这种加密方式很不安全，一旦黑客截取到了这个私钥，那么就可以拿到数据。所以就有了非对称加密。</p>\n<ul>\n<li>非对称加密</li>\n</ul>\n<p>非对称加密就是使用私钥加密，就只能用公钥解密，同理，用公钥加密就只能使用私钥解密。服务器先将公钥发送给客户端，然后使用私钥将数据加密，然后将加密的数据和公钥同时传送到客户端。这样就算黑客截取到数据，没用公钥也就拿不到数据。但是还是有风险，服务器把公钥发送给客户端的时候，同样由被截取的风险，那么怎样才能安全的将公钥送到客户端呢？</p>\n<p>这个时候就是HTTPS登场了，HTTPS的加密方式结合了两种加密方式，首先使用非对称加密将对称加密要使用的密钥发送给服务器。具体流程如下：</p>\n<blockquote>\n<p>首先服务器将公钥发送给客户端</p>\n<p>客户端生成一个对称加密的密钥，然后使用服务器的公钥将密钥加密，发送给服务器</p>\n<p>服务器再通过自己的私钥解密拿到密钥</p>\n<p>然后接下来的传输数据就使用这个密钥进行传输</p>\n</blockquote>\n<p>但是将才说了，公钥传送给客户端是有被截取的风险的，那怎样才能安全的将公钥传送给客户端呢？</p>\n<p>这就要用到我们说的数字证书了，数字证书不是为了确认服务器的真实性嘛，那我就把公钥放在这个数字证书中，这样服务器既能证明自己的身份，又能将公钥传送到客户端。然后客户端就可以按照之前的流程继续操作了。</p>\n<ol start=\"3\">\n<li>数字签名</li>\n</ol>\n<p>还有最后一个问题就是数据再传输的过程中可能被黑客截取修改，这个时候就使用到了数字证书，服务器通过将数据某个加密算法计算出一个摘要，然后将这个摘要一起发送到客户端，客户端拿到数据之后，再使用同样的加密算法计算出数据的摘要，然后和服务器发送过来的摘要进行比对，如果相同说明没有被修改，相反，那个这个数据就已经被修改了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>HTTPS的诞生主要是为了解决HTTP存在的一些安全问题，当然HTTPS虽然解决了这些问题，但是也是有代价的，他的连接速度没有HTTP快，当然这种连接速度是可以接受的，还有就是数字证书是需要申请和收费的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"HTTPS解决的问题\"><a href=\"#HTTPS解决的问题\" class=\"headerlink\" title=\"HTTPS解决的问题\"></a>HTTPS解决的问题</h3><p>有了大家熟悉的HTTP之后，为什么还会诞生HTTPS呢？</p>\n<p>那是因为HTTP存在很多问题，比如：无状态、不安全等</p>\n<p>而HTTPS不是一个新的协议，其实只是相当对HTTP安全的一个升级。在介绍HTTPS之前先介绍一下HTTP存在的安全问题。</p>\n<ul>\n<li>明文传输</li>\n<li>不知道服务器是不是我们要请求的服务器（中间人攻击）</li>\n<li>客户端和服务器拿到对方的数据是不是真实，有可能被黑客获取修改了</li>\n</ul>\n<p>而HTTPS就解决了这些问题。主要解决的方式如下：</p>\n<ol>\n<li>数字证书</li>\n</ol>\n<p>数字证书主要解决了确认请求的服务器是安全的。数字证书是由一些官方机构发放的，当然是需要收费的。在建立HTTPS连接的时候，客户端向服务器发送请求，服务器会把自己的数字证书发送给客户端，客户端拿到之后，浏览器会自动去验证这个证书的真实性，如果证书是假的，那么浏览器就会报错，也就是我们常看到的浏览器提示该网站不安全。如果证书验证通过，客户端就可以继续发送请求。</p>\n<ol start=\"2\">\n<li>密文传输</li>\n</ol>\n<p>密文传输肯定就是解决明文传输的问题了，那它是怎么加密的呢？在此之前先介绍一下对称加密和非对称加密。</p>\n<ul>\n<li>对称加密</li>\n</ul>\n<p>通过名字就可以看出，对称加密其实就是使用同一个密钥进行加密或解密。服务器使用私钥将数据加密，然后将加密后的数据和密钥一起发送给客户端，客户端在使用解密数据使用。其实大家既可以发现这种加密方式很不安全，一旦黑客截取到了这个私钥，那么就可以拿到数据。所以就有了非对称加密。</p>\n<ul>\n<li>非对称加密</li>\n</ul>\n<p>非对称加密就是使用私钥加密，就只能用公钥解密，同理，用公钥加密就只能使用私钥解密。服务器先将公钥发送给客户端，然后使用私钥将数据加密，然后将加密的数据和公钥同时传送到客户端。这样就算黑客截取到数据，没用公钥也就拿不到数据。但是还是有风险，服务器把公钥发送给客户端的时候，同样由被截取的风险，那么怎样才能安全的将公钥送到客户端呢？</p>\n<p>这个时候就是HTTPS登场了，HTTPS的加密方式结合了两种加密方式，首先使用非对称加密将对称加密要使用的密钥发送给服务器。具体流程如下：</p>\n<blockquote>\n<p>首先服务器将公钥发送给客户端</p>\n<p>客户端生成一个对称加密的密钥，然后使用服务器的公钥将密钥加密，发送给服务器</p>\n<p>服务器再通过自己的私钥解密拿到密钥</p>\n<p>然后接下来的传输数据就使用这个密钥进行传输</p>\n</blockquote>\n<p>但是将才说了，公钥传送给客户端是有被截取的风险的，那怎样才能安全的将公钥传送给客户端呢？</p>\n<p>这就要用到我们说的数字证书了，数字证书不是为了确认服务器的真实性嘛，那我就把公钥放在这个数字证书中，这样服务器既能证明自己的身份，又能将公钥传送到客户端。然后客户端就可以按照之前的流程继续操作了。</p>\n<ol start=\"3\">\n<li>数字签名</li>\n</ol>\n<p>还有最后一个问题就是数据再传输的过程中可能被黑客截取修改，这个时候就使用到了数字证书，服务器通过将数据某个加密算法计算出一个摘要，然后将这个摘要一起发送到客户端，客户端拿到数据之后，再使用同样的加密算法计算出数据的摘要，然后和服务器发送过来的摘要进行比对，如果相同说明没有被修改，相反，那个这个数据就已经被修改了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>HTTPS的诞生主要是为了解决HTTP存在的一些安全问题，当然HTTPS虽然解决了这些问题，但是也是有代价的，他的连接速度没有HTTP快，当然这种连接速度是可以接受的，还有就是数字证书是需要申请和收费的。</p>\n"},{"title":"vue源码分析-手写模拟简单源码(1)","date":"2020-02-24T03:31:20.000Z","description":"Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.","_content":"\n### 使用步骤:\n\n1. 编写 页面 模板 \n   1. 直接在 HTML 标签中写 标签\n   2. 使用 template\n   3. 使用 单文件 `( <template /> )`\n2. 创建 Vue 的实例\n   - 在 Vue 的构造函数中提供: data, methods, computed, watcher, props, ...\n3. 将 Vue 挂载到 页面中 ( mount )\n\n```js\n<!-- 写模板 -->\n  <div id=\"root\">\n    <p>{{name}}</p>\n    <p>{{message}}</p>\n  </div>\n  <script>\n    // 第二步 创建 实例\n    let app = new Vue( {\n      el: '#root',\n      data: {\n        name: '张三'\n        , message: '是一个男人'\n      }\n    } );\n    // 第三步是挂载: 这种用法的挂载在 vue.js 中帮我们实现了\n```\n\n### Vue 的执行流程\n\n1. 获得模板: 模板中有 \"坑\"\n2. 利用 Vue 构造函数中所提供的数据来 \"填坑\", 得到可以在页面中显示的 \"标签了\"\n3. 将标签替换页面中原来有坑的标签\n\nVue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),\n替换到了 页面中 放置模板的位置.\n\n### 简单的模板渲染\n\n步骤:\n\n1. 拿到模板\n2. 拿到数据 ( data )\n3. 将数据与模板结合, 得到 的是 HTML 元素 ( DOM 元素 )\n\n```js\nfunction compiler( template, data ) {\n      let childNodes = template.childNodes; // 取出子元素\n      for ( let i = 0; i < childNodes.length; i++ ) {\n        let type = childNodes[ i ].nodeType; // 1 元素, 3 文本节点\n        if ( type === 3 ) {\n          // 文本节点, 可以判断里面是否有 需要 插值\n          let txt = childNodes[ i ].nodeValue; // 该属性只有文本节点才有意义\n          // 有没有双花括号??? \n          txt = txt.replace( rkuohao, function ( _, g ) { // replace 使用正则匹配一次 函数就会被调用一次\n                                                    // 函数的 第 0 个参数 表示匹配到的内容\n                                                    // 函数的 第 n 个参数 表示正则中的 第 n 组\n            let key = g.trim(); // 写在双花括号里面的 东西\n            let value = data[ key ];\n            // 将 {{ xxxx }} 用这个 值替换\n            return value;\n          } );\n          // 注意:  txt 现在和 DOM 元素是没有关系\n          childNodes[ i ].nodeValue = txt;\n        } \n        else if ( type === 1 ) {\n          // 元素, 考虑它有没有子元素, 是否需要将其子元素进行 判断是否要插值\n          compiler( childNodes[ i ], data );\n        }\n      }\n    }\n```\n\n4. 放到页面中\n\n``` js\nroot.parentNode.replaceChild( generateNode, root );\n```\n\n来源: 腾讯课堂蒋坤公开课","source":"_posts/1-Vue.md","raw":"---\ntitle: vue源码分析-手写模拟简单源码(1)\ndate: 2020-02-24 11:31:20\ncategories: vue\ntags: [vue]\ndescription: Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.\n---\n\n### 使用步骤:\n\n1. 编写 页面 模板 \n   1. 直接在 HTML 标签中写 标签\n   2. 使用 template\n   3. 使用 单文件 `( <template /> )`\n2. 创建 Vue 的实例\n   - 在 Vue 的构造函数中提供: data, methods, computed, watcher, props, ...\n3. 将 Vue 挂载到 页面中 ( mount )\n\n```js\n<!-- 写模板 -->\n  <div id=\"root\">\n    <p>{{name}}</p>\n    <p>{{message}}</p>\n  </div>\n  <script>\n    // 第二步 创建 实例\n    let app = new Vue( {\n      el: '#root',\n      data: {\n        name: '张三'\n        , message: '是一个男人'\n      }\n    } );\n    // 第三步是挂载: 这种用法的挂载在 vue.js 中帮我们实现了\n```\n\n### Vue 的执行流程\n\n1. 获得模板: 模板中有 \"坑\"\n2. 利用 Vue 构造函数中所提供的数据来 \"填坑\", 得到可以在页面中显示的 \"标签了\"\n3. 将标签替换页面中原来有坑的标签\n\nVue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),\n替换到了 页面中 放置模板的位置.\n\n### 简单的模板渲染\n\n步骤:\n\n1. 拿到模板\n2. 拿到数据 ( data )\n3. 将数据与模板结合, 得到 的是 HTML 元素 ( DOM 元素 )\n\n```js\nfunction compiler( template, data ) {\n      let childNodes = template.childNodes; // 取出子元素\n      for ( let i = 0; i < childNodes.length; i++ ) {\n        let type = childNodes[ i ].nodeType; // 1 元素, 3 文本节点\n        if ( type === 3 ) {\n          // 文本节点, 可以判断里面是否有 需要 插值\n          let txt = childNodes[ i ].nodeValue; // 该属性只有文本节点才有意义\n          // 有没有双花括号??? \n          txt = txt.replace( rkuohao, function ( _, g ) { // replace 使用正则匹配一次 函数就会被调用一次\n                                                    // 函数的 第 0 个参数 表示匹配到的内容\n                                                    // 函数的 第 n 个参数 表示正则中的 第 n 组\n            let key = g.trim(); // 写在双花括号里面的 东西\n            let value = data[ key ];\n            // 将 {{ xxxx }} 用这个 值替换\n            return value;\n          } );\n          // 注意:  txt 现在和 DOM 元素是没有关系\n          childNodes[ i ].nodeValue = txt;\n        } \n        else if ( type === 1 ) {\n          // 元素, 考虑它有没有子元素, 是否需要将其子元素进行 判断是否要插值\n          compiler( childNodes[ i ], data );\n        }\n      }\n    }\n```\n\n4. 放到页面中\n\n``` js\nroot.parentNode.replaceChild( generateNode, root );\n```\n\n来源: 腾讯课堂蒋坤公开课","slug":"1-Vue","published":1,"updated":"2021-09-08T14:15:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1l70001dswke2jsefa4","content":"<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤:\"></a>使用步骤:</h3><ol>\n<li>编写 页面 模板 <ol>\n<li>直接在 HTML 标签中写 标签</li>\n<li>使用 template</li>\n<li>使用 单文件 <code>( &lt;template /&gt; )</code></li>\n</ol>\n</li>\n<li>创建 Vue 的实例<ul>\n<li>在 Vue 的构造函数中提供: data, methods, computed, watcher, props, …</li>\n</ul>\n</li>\n<li>将 Vue 挂载到 页面中 ( mount )</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 写模板 --&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    <span class=\"comment\">// 第二步 创建 实例</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>( &#123;</span><br><span class=\"line\">      <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#root&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">&#x27;张三&#x27;</span></span><br><span class=\"line\">        , <span class=\"attr\">message</span>: <span class=\"string\">&#x27;是一个男人&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">    <span class=\"comment\">// 第三步是挂载: 这种用法的挂载在 vue.js 中帮我们实现了</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Vue-的执行流程\"><a href=\"#Vue-的执行流程\" class=\"headerlink\" title=\"Vue 的执行流程\"></a>Vue 的执行流程</h3><ol>\n<li>获得模板: 模板中有 “坑”</li>\n<li>利用 Vue 构造函数中所提供的数据来 “填坑”, 得到可以在页面中显示的 “标签了”</li>\n<li>将标签替换页面中原来有坑的标签</li>\n</ol>\n<p>Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),<br>替换到了 页面中 放置模板的位置.</p>\n<h3 id=\"简单的模板渲染\"><a href=\"#简单的模板渲染\" class=\"headerlink\" title=\"简单的模板渲染\"></a>简单的模板渲染</h3><p>步骤:</p>\n<ol>\n<li>拿到模板</li>\n<li>拿到数据 ( data )</li>\n<li>将数据与模板结合, 得到 的是 HTML 元素 ( DOM 元素 )</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compiler</span>(<span class=\"params\"> template, data </span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> childNodes = template.<span class=\"property\">childNodes</span>; <span class=\"comment\">// 取出子元素</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childNodes.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> type = childNodes[ i ].<span class=\"property\">nodeType</span>; <span class=\"comment\">// 1 元素, 3 文本节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type === <span class=\"number\">3</span> ) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 文本节点, 可以判断里面是否有 需要 插值</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> txt = childNodes[ i ].<span class=\"property\">nodeValue</span>; <span class=\"comment\">// 该属性只有文本节点才有意义</span></span><br><span class=\"line\">          <span class=\"comment\">// 有没有双花括号??? </span></span><br><span class=\"line\">          txt = txt.<span class=\"title function_\">replace</span>( rkuohao, <span class=\"keyword\">function</span> (<span class=\"params\"> _, g </span>) &#123; <span class=\"comment\">// replace 使用正则匹配一次 函数就会被调用一次</span></span><br><span class=\"line\">                                                    <span class=\"comment\">// 函数的 第 0 个参数 表示匹配到的内容</span></span><br><span class=\"line\">                                                    <span class=\"comment\">// 函数的 第 n 个参数 表示正则中的 第 n 组</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = g.<span class=\"title function_\">trim</span>(); <span class=\"comment\">// 写在双花括号里面的 东西</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = data[ key ];</span><br><span class=\"line\">            <span class=\"comment\">// 将 &#123;&#123; xxxx &#125;&#125; 用这个 值替换</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">          &#125; );</span><br><span class=\"line\">          <span class=\"comment\">// 注意:  txt 现在和 DOM 元素是没有关系</span></span><br><span class=\"line\">          childNodes[ i ].<span class=\"property\">nodeValue</span> = txt;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type === <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 元素, 考虑它有没有子元素, 是否需要将其子元素进行 判断是否要插值</span></span><br><span class=\"line\">          <span class=\"title function_\">compiler</span>( childNodes[ i ], data );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>放到页面中</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root.<span class=\"property\">parentNode</span>.<span class=\"title function_\">replaceChild</span>( generateNode, root );</span><br></pre></td></tr></table></figure>\n\n<p>来源: 腾讯课堂蒋坤公开课</p>\n","site":{"data":{}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","excerpt":"","more":"<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤:\"></a>使用步骤:</h3><ol>\n<li>编写 页面 模板 <ol>\n<li>直接在 HTML 标签中写 标签</li>\n<li>使用 template</li>\n<li>使用 单文件 <code>( &lt;template /&gt; )</code></li>\n</ol>\n</li>\n<li>创建 Vue 的实例<ul>\n<li>在 Vue 的构造函数中提供: data, methods, computed, watcher, props, …</li>\n</ul>\n</li>\n<li>将 Vue 挂载到 页面中 ( mount )</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 写模板 --&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    <span class=\"comment\">// 第二步 创建 实例</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>( &#123;</span><br><span class=\"line\">      <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#root&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">&#x27;张三&#x27;</span></span><br><span class=\"line\">        , <span class=\"attr\">message</span>: <span class=\"string\">&#x27;是一个男人&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">    <span class=\"comment\">// 第三步是挂载: 这种用法的挂载在 vue.js 中帮我们实现了</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Vue-的执行流程\"><a href=\"#Vue-的执行流程\" class=\"headerlink\" title=\"Vue 的执行流程\"></a>Vue 的执行流程</h3><ol>\n<li>获得模板: 模板中有 “坑”</li>\n<li>利用 Vue 构造函数中所提供的数据来 “填坑”, 得到可以在页面中显示的 “标签了”</li>\n<li>将标签替换页面中原来有坑的标签</li>\n</ol>\n<p>Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),<br>替换到了 页面中 放置模板的位置.</p>\n<h3 id=\"简单的模板渲染\"><a href=\"#简单的模板渲染\" class=\"headerlink\" title=\"简单的模板渲染\"></a>简单的模板渲染</h3><p>步骤:</p>\n<ol>\n<li>拿到模板</li>\n<li>拿到数据 ( data )</li>\n<li>将数据与模板结合, 得到 的是 HTML 元素 ( DOM 元素 )</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compiler</span>(<span class=\"params\"> template, data </span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> childNodes = template.<span class=\"property\">childNodes</span>; <span class=\"comment\">// 取出子元素</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childNodes.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> type = childNodes[ i ].<span class=\"property\">nodeType</span>; <span class=\"comment\">// 1 元素, 3 文本节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type === <span class=\"number\">3</span> ) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 文本节点, 可以判断里面是否有 需要 插值</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> txt = childNodes[ i ].<span class=\"property\">nodeValue</span>; <span class=\"comment\">// 该属性只有文本节点才有意义</span></span><br><span class=\"line\">          <span class=\"comment\">// 有没有双花括号??? </span></span><br><span class=\"line\">          txt = txt.<span class=\"title function_\">replace</span>( rkuohao, <span class=\"keyword\">function</span> (<span class=\"params\"> _, g </span>) &#123; <span class=\"comment\">// replace 使用正则匹配一次 函数就会被调用一次</span></span><br><span class=\"line\">                                                    <span class=\"comment\">// 函数的 第 0 个参数 表示匹配到的内容</span></span><br><span class=\"line\">                                                    <span class=\"comment\">// 函数的 第 n 个参数 表示正则中的 第 n 组</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> key = g.<span class=\"title function_\">trim</span>(); <span class=\"comment\">// 写在双花括号里面的 东西</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = data[ key ];</span><br><span class=\"line\">            <span class=\"comment\">// 将 &#123;&#123; xxxx &#125;&#125; 用这个 值替换</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">          &#125; );</span><br><span class=\"line\">          <span class=\"comment\">// 注意:  txt 现在和 DOM 元素是没有关系</span></span><br><span class=\"line\">          childNodes[ i ].<span class=\"property\">nodeValue</span> = txt;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type === <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 元素, 考虑它有没有子元素, 是否需要将其子元素进行 判断是否要插值</span></span><br><span class=\"line\">          <span class=\"title function_\">compiler</span>( childNodes[ i ], data );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>放到页面中</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root.<span class=\"property\">parentNode</span>.<span class=\"title function_\">replaceChild</span>( generateNode, root );</span><br></pre></td></tr></table></figure>\n\n<p>来源: 腾讯课堂蒋坤公开课</p>\n"},{"title":"浏览器的垃圾回收机制","date":"2021-09-15T08:12:01.000Z","description":"在日常的开发过程中，我们不断的定义变量和函数，然后使用、调用，但是是否没有想到过，当代码执行过后，这些变量都去了哪里。其实是浏览器自己会对没有用的对象进行清除。那怎么算是没有用的了？","cover":"https://i.loli.net/2021/09/15/LP1muf2TNSoc8WD.jpg","_content":"\n## 浏览器的垃圾回收机制\n\n在日常的开发过程中，我们不断的定义变量和函数，然后使用、调用，但是是否没有想到过，当代码执行过后，这些变量都去了哪里。其实是浏览器自己会对没有用的对象进行清除。那怎么算是没有用的了？\n\n**可达性**\n\n一个对象是否具有可达性决定了它时候还有用，或者说是有被用到。\n\n可达性表示对象是否可以被访问到，如果不能被访问到，就会被浏览器的垃圾回收机制回收。\n\n**回收策略**\n\n回收策略就是浏览器如何找出这些不可达对象的策略或者说是一种算法，然后把它们清除。\n\n常见的回收策略：\n\n* 引用计数算法\n* 标记清除算法\n* 标记整理算法\n\n> 引用计数算法\n\n引用计数算法很简单，如果对象没有被使用那么它的引用计数就为0，有被用到就增加1。一旦对象的引用计数为0之后，那么这个对象就会被清除\n\n引用计数算法的优点就是很清晰，引用计数为0，那么对象就是没有被用到，就立即直接清除掉。\n\n但是如果对象存在循环应用，那么他们的引用计数就不可能为0，所以对象就不会被清除，所以这也是该算法的缺点\n\n> 标记清除算法\n\n标记清除算法是大多数浏览器都在使用的垃圾回收算法，它将回收分为两个阶段：标记和清除阶段，标记阶段通过从根节点递归遍历，将能访问到的都加上一个标记，清除阶段就将没有标记的对象清除。\n\n优点\n\n* 解决了引用计数的循环引用的问题，因为标记清除算法采用了递归遍历对象的方式\n\n缺点\n\n* 内存碎片化\n\n标记清除算法清除之后，内存就会存在不同大小的内存块，而在分配内存的时候可能因为对象过大而找不到合适的内存块。\n\n> 标记整理算法\n\n标记整理算法和标记清除算法在垃圾回收都是一样的，标记整理算法会在清除之后，将没有被清除的对象统一复制到内存的一端。就解决了标记清除算法的内存碎片化的缺点。\n\n**V8的垃圾回收机制**\n\n> V8是一个Javascript引擎，相对于其他引擎做了很多的优化\n\n![3m7zv-knrhh.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-watermark.webp)\n\nV8的垃圾回收机制采用的分代式垃圾回收，将堆内存分为新生代和老生代两个内存块\n\n* 新生代\n\n新生代表示存活时间较短的对象，它能存储的对象很小只有1~8M\n\n新生代又将它内部分为使用区和空闲区，新加入的对象会放在使用区，当使用区快被存慢的时候，就会进行垃圾回收，将使用区中的活动对象加上标记，然后将加上标记的对象复制到空闲区，然后将使用区清空，再将使用区和空闲区对调，空闲区变成使用区。\n\n当空闲区占了25%，那么剩下的活动对象就会自动晋升到老生代。一个对象经历一次或多次回收之后依然存在新生代中，就会把该对象晋升到老生代。\n\n* 老生代\n\n老生代则是采用的是标记整理算法，通过标记清除来回收垃圾，再将存活的对象复制到内存的一端。\n\n**增量标记**\n\n增量标记是V8对垃圾回收机制的优化，当在回收比较大的对象的时候，如果一下全部清除，会花费比较大的时间，V8就采用了增量标记的方式，将垃圾回收分成很多小步，让js代码执行一会儿，再清理一次，再让js执行一会儿，减少每次回收的时间。","source":"_posts/1.Bowser_GC.md","raw":"---\ntitle: 浏览器的垃圾回收机制\ndate: 2021-09-15 16:12:01\ncategories: 浏览器\ntags: [浏览器]\ndescription: 在日常的开发过程中，我们不断的定义变量和函数，然后使用、调用，但是是否没有想到过，当代码执行过后，这些变量都去了哪里。其实是浏览器自己会对没有用的对象进行清除。那怎么算是没有用的了？\ncover: https://i.loli.net/2021/09/15/LP1muf2TNSoc8WD.jpg\n---\n\n## 浏览器的垃圾回收机制\n\n在日常的开发过程中，我们不断的定义变量和函数，然后使用、调用，但是是否没有想到过，当代码执行过后，这些变量都去了哪里。其实是浏览器自己会对没有用的对象进行清除。那怎么算是没有用的了？\n\n**可达性**\n\n一个对象是否具有可达性决定了它时候还有用，或者说是有被用到。\n\n可达性表示对象是否可以被访问到，如果不能被访问到，就会被浏览器的垃圾回收机制回收。\n\n**回收策略**\n\n回收策略就是浏览器如何找出这些不可达对象的策略或者说是一种算法，然后把它们清除。\n\n常见的回收策略：\n\n* 引用计数算法\n* 标记清除算法\n* 标记整理算法\n\n> 引用计数算法\n\n引用计数算法很简单，如果对象没有被使用那么它的引用计数就为0，有被用到就增加1。一旦对象的引用计数为0之后，那么这个对象就会被清除\n\n引用计数算法的优点就是很清晰，引用计数为0，那么对象就是没有被用到，就立即直接清除掉。\n\n但是如果对象存在循环应用，那么他们的引用计数就不可能为0，所以对象就不会被清除，所以这也是该算法的缺点\n\n> 标记清除算法\n\n标记清除算法是大多数浏览器都在使用的垃圾回收算法，它将回收分为两个阶段：标记和清除阶段，标记阶段通过从根节点递归遍历，将能访问到的都加上一个标记，清除阶段就将没有标记的对象清除。\n\n优点\n\n* 解决了引用计数的循环引用的问题，因为标记清除算法采用了递归遍历对象的方式\n\n缺点\n\n* 内存碎片化\n\n标记清除算法清除之后，内存就会存在不同大小的内存块，而在分配内存的时候可能因为对象过大而找不到合适的内存块。\n\n> 标记整理算法\n\n标记整理算法和标记清除算法在垃圾回收都是一样的，标记整理算法会在清除之后，将没有被清除的对象统一复制到内存的一端。就解决了标记清除算法的内存碎片化的缺点。\n\n**V8的垃圾回收机制**\n\n> V8是一个Javascript引擎，相对于其他引擎做了很多的优化\n\n![3m7zv-knrhh.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-watermark.webp)\n\nV8的垃圾回收机制采用的分代式垃圾回收，将堆内存分为新生代和老生代两个内存块\n\n* 新生代\n\n新生代表示存活时间较短的对象，它能存储的对象很小只有1~8M\n\n新生代又将它内部分为使用区和空闲区，新加入的对象会放在使用区，当使用区快被存慢的时候，就会进行垃圾回收，将使用区中的活动对象加上标记，然后将加上标记的对象复制到空闲区，然后将使用区清空，再将使用区和空闲区对调，空闲区变成使用区。\n\n当空闲区占了25%，那么剩下的活动对象就会自动晋升到老生代。一个对象经历一次或多次回收之后依然存在新生代中，就会把该对象晋升到老生代。\n\n* 老生代\n\n老生代则是采用的是标记整理算法，通过标记清除来回收垃圾，再将存活的对象复制到内存的一端。\n\n**增量标记**\n\n增量标记是V8对垃圾回收机制的优化，当在回收比较大的对象的时候，如果一下全部清除，会花费比较大的时间，V8就采用了增量标记的方式，将垃圾回收分成很多小步，让js代码执行一会儿，再清理一次，再让js执行一会儿，减少每次回收的时间。","slug":"1.Bowser_GC","published":1,"updated":"2021-09-15T08:40:06.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1l90004dswk32isdvn5","content":"<h2 id=\"浏览器的垃圾回收机制\"><a href=\"#浏览器的垃圾回收机制\" class=\"headerlink\" title=\"浏览器的垃圾回收机制\"></a>浏览器的垃圾回收机制</h2><p>在日常的开发过程中，我们不断的定义变量和函数，然后使用、调用，但是是否没有想到过，当代码执行过后，这些变量都去了哪里。其实是浏览器自己会对没有用的对象进行清除。那怎么算是没有用的了？</p>\n<p><strong>可达性</strong></p>\n<p>一个对象是否具有可达性决定了它时候还有用，或者说是有被用到。</p>\n<p>可达性表示对象是否可以被访问到，如果不能被访问到，就会被浏览器的垃圾回收机制回收。</p>\n<p><strong>回收策略</strong></p>\n<p>回收策略就是浏览器如何找出这些不可达对象的策略或者说是一种算法，然后把它们清除。</p>\n<p>常见的回收策略：</p>\n<ul>\n<li>引用计数算法</li>\n<li>标记清除算法</li>\n<li>标记整理算法</li>\n</ul>\n<blockquote>\n<p>引用计数算法</p>\n</blockquote>\n<p>引用计数算法很简单，如果对象没有被使用那么它的引用计数就为0，有被用到就增加1。一旦对象的引用计数为0之后，那么这个对象就会被清除</p>\n<p>引用计数算法的优点就是很清晰，引用计数为0，那么对象就是没有被用到，就立即直接清除掉。</p>\n<p>但是如果对象存在循环应用，那么他们的引用计数就不可能为0，所以对象就不会被清除，所以这也是该算法的缺点</p>\n<blockquote>\n<p>标记清除算法</p>\n</blockquote>\n<p>标记清除算法是大多数浏览器都在使用的垃圾回收算法，它将回收分为两个阶段：标记和清除阶段，标记阶段通过从根节点递归遍历，将能访问到的都加上一个标记，清除阶段就将没有标记的对象清除。</p>\n<p>优点</p>\n<ul>\n<li>解决了引用计数的循环引用的问题，因为标记清除算法采用了递归遍历对象的方式</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>内存碎片化</li>\n</ul>\n<p>标记清除算法清除之后，内存就会存在不同大小的内存块，而在分配内存的时候可能因为对象过大而找不到合适的内存块。</p>\n<blockquote>\n<p>标记整理算法</p>\n</blockquote>\n<p>标记整理算法和标记清除算法在垃圾回收都是一样的，标记整理算法会在清除之后，将没有被清除的对象统一复制到内存的一端。就解决了标记清除算法的内存碎片化的缺点。</p>\n<p><strong>V8的垃圾回收机制</strong></p>\n<blockquote>\n<p>V8是一个Javascript引擎，相对于其他引擎做了很多的优化</p>\n</blockquote>\n<p><img src= \"/img/loading.gif\" data-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-watermark.webp\" alt=\"3m7zv-knrhh.jpg\"></p>\n<p>V8的垃圾回收机制采用的分代式垃圾回收，将堆内存分为新生代和老生代两个内存块</p>\n<ul>\n<li>新生代</li>\n</ul>\n<p>新生代表示存活时间较短的对象，它能存储的对象很小只有1~8M</p>\n<p>新生代又将它内部分为使用区和空闲区，新加入的对象会放在使用区，当使用区快被存慢的时候，就会进行垃圾回收，将使用区中的活动对象加上标记，然后将加上标记的对象复制到空闲区，然后将使用区清空，再将使用区和空闲区对调，空闲区变成使用区。</p>\n<p>当空闲区占了25%，那么剩下的活动对象就会自动晋升到老生代。一个对象经历一次或多次回收之后依然存在新生代中，就会把该对象晋升到老生代。</p>\n<ul>\n<li>老生代</li>\n</ul>\n<p>老生代则是采用的是标记整理算法，通过标记清除来回收垃圾，再将存活的对象复制到内存的一端。</p>\n<p><strong>增量标记</strong></p>\n<p>增量标记是V8对垃圾回收机制的优化，当在回收比较大的对象的时候，如果一下全部清除，会花费比较大的时间，V8就采用了增量标记的方式，将垃圾回收分成很多小步，让js代码执行一会儿，再清理一次，再让js执行一会儿，减少每次回收的时间。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器的垃圾回收机制\"><a href=\"#浏览器的垃圾回收机制\" class=\"headerlink\" title=\"浏览器的垃圾回收机制\"></a>浏览器的垃圾回收机制</h2><p>在日常的开发过程中，我们不断的定义变量和函数，然后使用、调用，但是是否没有想到过，当代码执行过后，这些变量都去了哪里。其实是浏览器自己会对没有用的对象进行清除。那怎么算是没有用的了？</p>\n<p><strong>可达性</strong></p>\n<p>一个对象是否具有可达性决定了它时候还有用，或者说是有被用到。</p>\n<p>可达性表示对象是否可以被访问到，如果不能被访问到，就会被浏览器的垃圾回收机制回收。</p>\n<p><strong>回收策略</strong></p>\n<p>回收策略就是浏览器如何找出这些不可达对象的策略或者说是一种算法，然后把它们清除。</p>\n<p>常见的回收策略：</p>\n<ul>\n<li>引用计数算法</li>\n<li>标记清除算法</li>\n<li>标记整理算法</li>\n</ul>\n<blockquote>\n<p>引用计数算法</p>\n</blockquote>\n<p>引用计数算法很简单，如果对象没有被使用那么它的引用计数就为0，有被用到就增加1。一旦对象的引用计数为0之后，那么这个对象就会被清除</p>\n<p>引用计数算法的优点就是很清晰，引用计数为0，那么对象就是没有被用到，就立即直接清除掉。</p>\n<p>但是如果对象存在循环应用，那么他们的引用计数就不可能为0，所以对象就不会被清除，所以这也是该算法的缺点</p>\n<blockquote>\n<p>标记清除算法</p>\n</blockquote>\n<p>标记清除算法是大多数浏览器都在使用的垃圾回收算法，它将回收分为两个阶段：标记和清除阶段，标记阶段通过从根节点递归遍历，将能访问到的都加上一个标记，清除阶段就将没有标记的对象清除。</p>\n<p>优点</p>\n<ul>\n<li>解决了引用计数的循环引用的问题，因为标记清除算法采用了递归遍历对象的方式</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>内存碎片化</li>\n</ul>\n<p>标记清除算法清除之后，内存就会存在不同大小的内存块，而在分配内存的时候可能因为对象过大而找不到合适的内存块。</p>\n<blockquote>\n<p>标记整理算法</p>\n</blockquote>\n<p>标记整理算法和标记清除算法在垃圾回收都是一样的，标记整理算法会在清除之后，将没有被清除的对象统一复制到内存的一端。就解决了标记清除算法的内存碎片化的缺点。</p>\n<p><strong>V8的垃圾回收机制</strong></p>\n<blockquote>\n<p>V8是一个Javascript引擎，相对于其他引擎做了很多的优化</p>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-watermark.webp\" alt=\"3m7zv-knrhh.jpg\"></p>\n<p>V8的垃圾回收机制采用的分代式垃圾回收，将堆内存分为新生代和老生代两个内存块</p>\n<ul>\n<li>新生代</li>\n</ul>\n<p>新生代表示存活时间较短的对象，它能存储的对象很小只有1~8M</p>\n<p>新生代又将它内部分为使用区和空闲区，新加入的对象会放在使用区，当使用区快被存慢的时候，就会进行垃圾回收，将使用区中的活动对象加上标记，然后将加上标记的对象复制到空闲区，然后将使用区清空，再将使用区和空闲区对调，空闲区变成使用区。</p>\n<p>当空闲区占了25%，那么剩下的活动对象就会自动晋升到老生代。一个对象经历一次或多次回收之后依然存在新生代中，就会把该对象晋升到老生代。</p>\n<ul>\n<li>老生代</li>\n</ul>\n<p>老生代则是采用的是标记整理算法，通过标记清除来回收垃圾，再将存活的对象复制到内存的一端。</p>\n<p><strong>增量标记</strong></p>\n<p>增量标记是V8对垃圾回收机制的优化，当在回收比较大的对象的时候，如果一下全部清除，会花费比较大的时间，V8就采用了增量标记的方式，将垃圾回收分成很多小步，让js代码执行一会儿，再清理一次，再让js执行一会儿，减少每次回收的时间。</p>\n"},{"title":"webpack-开发环境配置","date":"2020-02-28T07:31:20.000Z","description":"webpack是一个现代JavasScript应用程序的模块打包器(module bunder)官方网站https://www.webpackjs.com/","cover":"https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg","_content":"\n## 基础知识\n\n### 五个核心概念\n\n`entry` 指定webpack打包的入口文件\n`output` 配置webpack打包输出\n`loader`  loader是一种打包的方案，webpack默认只识别js结尾的文件\n`plugins` 插件，有些类型loader不能完全解决，需要使用插件\n`mode` 指定webpack打包模式，包括开发模式、生产模式\n\n## 安装打包初体验\n\n初始package.json\n`npm init -y`\n全局安装 \n`npm i webpack webpack-cli -g`\n生产安装\n`npm i webpack webpack-cli -D`\n\n1、入口文件\n2、运行打包\n开发环境 :`webpack ./src/index.js -o ./build/built.js --mode=developent`\n  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js\n生产环境 :`webpack ./src/index.js -o ./build/built.js --mode=production`\n  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js\n3、查看是否打包成功\n（1）node命令\n\t`npm buil.js ` (打包完成的js文件）\n（2）script标签\n\t在build目录下新建一个html文件，在该文件中通过script标签引入打包完成的js文件\n\n## webpack.config.js\n\nwebpack默认只能打包js、json资源,要打包样式资源要使用loader\nloader在webpack.config.js中配置\n\nwebpack的配置文件,作用：指示 webpack 干那些活（当你运行 webpack 指令时，会加载里面的配置）\n\n基本配置\n```js\n// resolve用来拼接绝对路径的方法\nconst { resolve } = require('path');\n\nmodule.exports = {\n  // webpack配置\n  // 入口起点\n  entry: './src/index.js',\n  // 输出\n  output: {\n    // 输出文件名\n    filename: 'built.js',\n    // 输出路径\n    // __dirname nodejs的变量，代表当前文件的目录绝对路径\n    path: resolve(__dirname, 'build')\n  },\n  // loader的配置\n  module: {\n    rules: [\n\t//详细loader配置\n    ]\n  },\n  // plugins的配置\n  plugins: [\n    // 详细plugins的配置\n  ],\n  // 模式\n  mode: 'development', // 开发模式\n  // mode: 'production'\n}\n```\n## 打包样式资源\n\n打包样式资源（.css/.less）,在```module```中配置loader\n需要通过npm在目录中安装```css-loader```、```style-loader```、```less-loader```\n```js\nmodule: {\n    rules: [\n      // 详细loader配置\n      // 不同文件必须配置不同loader处理\n      {\n        // 匹配哪些文件\n        test: /\\.css$/,\n        // 使用哪些loader进行处理\n        use: [\n          // use数组中loader执行顺序：从右到左，从下到上 依次执行\n          // 创建style标签，将js中的样式资源插入进行，添加到head中生效\n          'style-loader',\n          // 将css文件变成commonjs模块加载js中，里面内容是样式字符串\n          'css-loader'\n        ]\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          // 将less文件编译成css文件\n          // 需要下载 less-loader和less\n          'less-loader'\n        ]\n      }\n    ]\n  }\n```\n## 打包HTML资源\n\n打包HTML资源需要在```plugins```中配置html-webpack-plugin:\n功能: 默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）\n需求：需要有结构的HTML文件\n注意：在配置```plugins```之前要导入```html-webpack-plugin```\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n```\n```js\nplugins: [\n    // plugins的配置\n    new HtmlWebpackPlugin({\n      // 复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS）\n      template: './src/index.html'\n    })\n  ]\n```\n## 打包图片资源\n\n打包图片资源（.jpg/.png/.gif）,在```module```中配置loader\n需要通过npm在目录中安装```url-loader```、```file-loader```\n\n```js\n module: {\n    rules: [\n      {\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        // 使用一个loader\n        loader: 'url-loader',\n        options: {\n          // 图片大小小于8kb，就会被base64处理\n          // 优点: 减少请求数量（减轻服务器压力）\n          // 缺点：图片体积会更大（文件请求速度更慢）\n          limit: 8 * 1024,\n          // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs\n          // 解析时会出问题：[object Module]\n          // 解决：关闭url-loader的es6模块化，使用commonjs解析\n          esModule: false,\n          // 给图片进行重命名\n          // [hash:10]取图片的hash的前10位\n          // [ext]取文件原来扩展名\n          name: '[hash:10].[ext]'\n        }\n      }\n    ]\n  }\n```\n## 打包图片资源\n\n打包图片资源（排除.css/.js/.html/.less）,在```module```中配置loader\n需要通过npm在目录中安装```file-loader```\n```js\n module: {\n    rules: [\n      // 打包其他资源(除了html/js/css资源以外的资源)\n      {\n        // 排除css/js/html资源\n        exclude: /\\.(css|js|html|less)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[hash:10].[ext]'\n        }\n      }\n    ]\n  }\n```\n## devServer\n\n开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~）\n特点：只会在内存中编译打包，不会有任何输出\n启动devServer指令为：npx webpack-dev-server\n```js\ndevServer: {\n    // 项目构建后路径\n    contentBase: resolve(__dirname, 'build'),\n    // 启动gzip压缩\n    compress: true,\n    // 端口号\n    port: 3000,\n    // 自动打开浏览器\n    open: true\n  }\n```\n## 开发环境配置\n\n开发环境配置：能让代码运行\n    运行项目指令：\n      webpack 会将打包结果输出出去\n      npx webpack-dev-server 只会在内存中编译打包，没有输出\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      // loader的配置\n      {\n        // 处理less资源\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      },\n      {\n        // 处理css资源\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        loader: 'url-loader',\n        options: {\n          limit: 8 * 1024,\n          name: '[hash:10].[ext]',\n          // 关闭es6模块化\n          esModule: false,\n          outputPath: 'imgs'\n        }\n      },\n      {\n        // 处理html中img资源\n        test: /\\.html$/,\n        loader: 'html-loader'\n      },\n      {\n        // 处理其他资源\n        exclude: /\\.(html|js|css|less|jpg|png|gif)/,\n        loader: 'file-loader',\n        options: {\n          name: '[hash:10].[ext]',\n          outputPath: 'media'\n        }\n      }\n    ]\n  },\n  plugins: [\n    // plugins的配置\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development',\n  devServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true\n  }\n};\n```\n","source":"_posts/1-webpack.md","raw":"---\ntitle: webpack-开发环境配置\ndate: 2020-02-28 15:31:20\ncategories: webpack\ntags: [webpack]\ndescription: webpack是一个现代JavasScript应用程序的模块打包器(module bunder)官方网站https://www.webpackjs.com/\ncover: https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg\n---\n\n## 基础知识\n\n### 五个核心概念\n\n`entry` 指定webpack打包的入口文件\n`output` 配置webpack打包输出\n`loader`  loader是一种打包的方案，webpack默认只识别js结尾的文件\n`plugins` 插件，有些类型loader不能完全解决，需要使用插件\n`mode` 指定webpack打包模式，包括开发模式、生产模式\n\n## 安装打包初体验\n\n初始package.json\n`npm init -y`\n全局安装 \n`npm i webpack webpack-cli -g`\n生产安装\n`npm i webpack webpack-cli -D`\n\n1、入口文件\n2、运行打包\n开发环境 :`webpack ./src/index.js -o ./build/built.js --mode=developent`\n  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js\n生产环境 :`webpack ./src/index.js -o ./build/built.js --mode=production`\n  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js\n3、查看是否打包成功\n（1）node命令\n\t`npm buil.js ` (打包完成的js文件）\n（2）script标签\n\t在build目录下新建一个html文件，在该文件中通过script标签引入打包完成的js文件\n\n## webpack.config.js\n\nwebpack默认只能打包js、json资源,要打包样式资源要使用loader\nloader在webpack.config.js中配置\n\nwebpack的配置文件,作用：指示 webpack 干那些活（当你运行 webpack 指令时，会加载里面的配置）\n\n基本配置\n```js\n// resolve用来拼接绝对路径的方法\nconst { resolve } = require('path');\n\nmodule.exports = {\n  // webpack配置\n  // 入口起点\n  entry: './src/index.js',\n  // 输出\n  output: {\n    // 输出文件名\n    filename: 'built.js',\n    // 输出路径\n    // __dirname nodejs的变量，代表当前文件的目录绝对路径\n    path: resolve(__dirname, 'build')\n  },\n  // loader的配置\n  module: {\n    rules: [\n\t//详细loader配置\n    ]\n  },\n  // plugins的配置\n  plugins: [\n    // 详细plugins的配置\n  ],\n  // 模式\n  mode: 'development', // 开发模式\n  // mode: 'production'\n}\n```\n## 打包样式资源\n\n打包样式资源（.css/.less）,在```module```中配置loader\n需要通过npm在目录中安装```css-loader```、```style-loader```、```less-loader```\n```js\nmodule: {\n    rules: [\n      // 详细loader配置\n      // 不同文件必须配置不同loader处理\n      {\n        // 匹配哪些文件\n        test: /\\.css$/,\n        // 使用哪些loader进行处理\n        use: [\n          // use数组中loader执行顺序：从右到左，从下到上 依次执行\n          // 创建style标签，将js中的样式资源插入进行，添加到head中生效\n          'style-loader',\n          // 将css文件变成commonjs模块加载js中，里面内容是样式字符串\n          'css-loader'\n        ]\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          // 将less文件编译成css文件\n          // 需要下载 less-loader和less\n          'less-loader'\n        ]\n      }\n    ]\n  }\n```\n## 打包HTML资源\n\n打包HTML资源需要在```plugins```中配置html-webpack-plugin:\n功能: 默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）\n需求：需要有结构的HTML文件\n注意：在配置```plugins```之前要导入```html-webpack-plugin```\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n```\n```js\nplugins: [\n    // plugins的配置\n    new HtmlWebpackPlugin({\n      // 复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS）\n      template: './src/index.html'\n    })\n  ]\n```\n## 打包图片资源\n\n打包图片资源（.jpg/.png/.gif）,在```module```中配置loader\n需要通过npm在目录中安装```url-loader```、```file-loader```\n\n```js\n module: {\n    rules: [\n      {\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        // 使用一个loader\n        loader: 'url-loader',\n        options: {\n          // 图片大小小于8kb，就会被base64处理\n          // 优点: 减少请求数量（减轻服务器压力）\n          // 缺点：图片体积会更大（文件请求速度更慢）\n          limit: 8 * 1024,\n          // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs\n          // 解析时会出问题：[object Module]\n          // 解决：关闭url-loader的es6模块化，使用commonjs解析\n          esModule: false,\n          // 给图片进行重命名\n          // [hash:10]取图片的hash的前10位\n          // [ext]取文件原来扩展名\n          name: '[hash:10].[ext]'\n        }\n      }\n    ]\n  }\n```\n## 打包图片资源\n\n打包图片资源（排除.css/.js/.html/.less）,在```module```中配置loader\n需要通过npm在目录中安装```file-loader```\n```js\n module: {\n    rules: [\n      // 打包其他资源(除了html/js/css资源以外的资源)\n      {\n        // 排除css/js/html资源\n        exclude: /\\.(css|js|html|less)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[hash:10].[ext]'\n        }\n      }\n    ]\n  }\n```\n## devServer\n\n开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~）\n特点：只会在内存中编译打包，不会有任何输出\n启动devServer指令为：npx webpack-dev-server\n```js\ndevServer: {\n    // 项目构建后路径\n    contentBase: resolve(__dirname, 'build'),\n    // 启动gzip压缩\n    compress: true,\n    // 端口号\n    port: 3000,\n    // 自动打开浏览器\n    open: true\n  }\n```\n## 开发环境配置\n\n开发环境配置：能让代码运行\n    运行项目指令：\n      webpack 会将打包结果输出出去\n      npx webpack-dev-server 只会在内存中编译打包，没有输出\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      // loader的配置\n      {\n        // 处理less资源\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      },\n      {\n        // 处理css资源\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        loader: 'url-loader',\n        options: {\n          limit: 8 * 1024,\n          name: '[hash:10].[ext]',\n          // 关闭es6模块化\n          esModule: false,\n          outputPath: 'imgs'\n        }\n      },\n      {\n        // 处理html中img资源\n        test: /\\.html$/,\n        loader: 'html-loader'\n      },\n      {\n        // 处理其他资源\n        exclude: /\\.(html|js|css|less|jpg|png|gif)/,\n        loader: 'file-loader',\n        options: {\n          name: '[hash:10].[ext]',\n          outputPath: 'media'\n        }\n      }\n    ]\n  },\n  plugins: [\n    // plugins的配置\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development',\n  devServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true\n  }\n};\n```\n","slug":"1-webpack","published":1,"updated":"2021-09-15T08:31:25.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1la0005dswk3mkqfghe","content":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"五个核心概念\"><a href=\"#五个核心概念\" class=\"headerlink\" title=\"五个核心概念\"></a>五个核心概念</h3><p><code>entry</code> 指定webpack打包的入口文件<br><code>output</code> 配置webpack打包输出<br><code>loader</code>  loader是一种打包的方案，webpack默认只识别js结尾的文件<br><code>plugins</code> 插件，有些类型loader不能完全解决，需要使用插件<br><code>mode</code> 指定webpack打包模式，包括开发模式、生产模式</p>\n<h2 id=\"安装打包初体验\"><a href=\"#安装打包初体验\" class=\"headerlink\" title=\"安装打包初体验\"></a>安装打包初体验</h2><p>初始package.json<br><code>npm init -y</code><br>全局安装<br><code>npm i webpack webpack-cli -g</code><br>生产安装<br><code>npm i webpack webpack-cli -D</code></p>\n<p>1、入口文件<br>2、运行打包<br>开发环境 :<code>webpack ./src/index.js -o ./build/built.js --mode=developent</code><br>  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js<br>生产环境 :<code>webpack ./src/index.js -o ./build/built.js --mode=production</code><br>  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js<br>3、查看是否打包成功<br>（1）node命令<br>    <code>npm buil.js</code> (打包完成的js文件）<br>（2）script标签<br>    在build目录下新建一个html文件，在该文件中通过script标签引入打包完成的js文件</p>\n<h2 id=\"webpack-config-js\"><a href=\"#webpack-config-js\" class=\"headerlink\" title=\"webpack.config.js\"></a>webpack.config.js</h2><p>webpack默认只能打包js、json资源,要打包样式资源要使用loader<br>loader在webpack.config.js中配置</p>\n<p>webpack的配置文件,作用：指示 webpack 干那些活（当你运行 webpack 指令时，会加载里面的配置）</p>\n<p>基本配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// resolve用来拼接绝对路径的方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">  <span class=\"comment\">// 入口起点</span></span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 输出</span></span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 输出文件名</span></span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;built.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 输出路径</span></span><br><span class=\"line\">    <span class=\"comment\">// __dirname nodejs的变量，代表当前文件的目录绝对路径</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// loader的配置</span></span><br><span class=\"line\">  <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">\t<span class=\"comment\">//详细loader配置</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// plugins的配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"comment\">// 详细plugins的配置</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">// 模式</span></span><br><span class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;development&#x27;</span>, <span class=\"comment\">// 开发模式</span></span><br><span class=\"line\">  <span class=\"comment\">// mode: &#x27;production&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包样式资源\"><a href=\"#打包样式资源\" class=\"headerlink\" title=\"打包样式资源\"></a>打包样式资源</h2><p>打包样式资源（.css/.less）,在<code>module</code>中配置loader<br>需要通过npm在目录中安装<code>css-loader</code>、<code>style-loader</code>、<code>less-loader</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      <span class=\"comment\">// 详细loader配置</span></span><br><span class=\"line\">      <span class=\"comment\">// 不同文件必须配置不同loader处理</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 匹配哪些文件</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 使用哪些loader进行处理</span></span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"comment\">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span></span><br><span class=\"line\">          <span class=\"comment\">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;style-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"string\">&#x27;style-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 将less文件编译成css文件</span></span><br><span class=\"line\">          <span class=\"comment\">// 需要下载 less-loader和less</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;less-loader&#x27;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包HTML资源\"><a href=\"#打包HTML资源\" class=\"headerlink\" title=\"打包HTML资源\"></a>打包HTML资源</h2><p>打包HTML资源需要在<code>plugins</code>中配置html-webpack-plugin:<br>功能: 默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）<br>需求：需要有结构的HTML文件<br>注意：在配置<code>plugins</code>之前要导入<code>html-webpack-plugin</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">HtmlWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;html-webpack-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"comment\">// plugins的配置</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlWebpackPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 复制 &#x27;./src/index.html&#x27; 文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">&#x27;./src/index.html&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包图片资源\"><a href=\"#打包图片资源\" class=\"headerlink\" title=\"打包图片资源\"></a>打包图片资源</h2><p>打包图片资源（.jpg/.png/.gif）,在<code>module</code>中配置loader<br>需要通过npm在目录中安装<code>url-loader</code>、<code>file-loader</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">   <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 处理图片资源</span></span><br><span class=\"line\">       <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(jpg|png|gif)$/</span>,</span><br><span class=\"line\">       <span class=\"comment\">// 使用一个loader</span></span><br><span class=\"line\">       <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;url-loader&#x27;</span>,</span><br><span class=\"line\">       <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 图片大小小于8kb，就会被base64处理</span></span><br><span class=\"line\">         <span class=\"comment\">// 优点: 减少请求数量（减轻服务器压力）</span></span><br><span class=\"line\">         <span class=\"comment\">// 缺点：图片体积会更大（文件请求速度更慢）</span></span><br><span class=\"line\">         <span class=\"attr\">limit</span>: <span class=\"number\">8</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">         <span class=\"comment\">// 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs</span></span><br><span class=\"line\">         <span class=\"comment\">// 解析时会出问题：[object Module]</span></span><br><span class=\"line\">         <span class=\"comment\">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class=\"line\">         <span class=\"attr\">esModule</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">         <span class=\"comment\">// 给图片进行重命名</span></span><br><span class=\"line\">         <span class=\"comment\">// [hash:10]取图片的hash的前10位</span></span><br><span class=\"line\">         <span class=\"comment\">// [ext]取文件原来扩展名</span></span><br><span class=\"line\">         <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包图片资源-1\"><a href=\"#打包图片资源-1\" class=\"headerlink\" title=\"打包图片资源\"></a>打包图片资源</h2><p>打包图片资源（排除.css/.js/.html/.less）,在<code>module</code>中配置loader<br>需要通过npm在目录中安装<code>file-loader</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">   <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">     <span class=\"comment\">// 打包其他资源(除了html/js/css资源以外的资源)</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 排除css/js/html资源</span></span><br><span class=\"line\">       <span class=\"attr\">exclude</span>: <span class=\"regexp\">/\\.(css|js|html|less)$/</span>,</span><br><span class=\"line\">       <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;file-loader&#x27;</span>,</span><br><span class=\"line\">       <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">         <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a>devServer</h2><p>开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~）<br>特点：只会在内存中编译打包，不会有任何输出<br>启动devServer指令为：npx webpack-dev-server</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 项目构建后路径</span></span><br><span class=\"line\">    <span class=\"attr\">contentBase</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 启动gzip压缩</span></span><br><span class=\"line\">    <span class=\"attr\">compress</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 端口号</span></span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">3000</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 自动打开浏览器</span></span><br><span class=\"line\">    <span class=\"attr\">open</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开发环境配置\"><a href=\"#开发环境配置\" class=\"headerlink\" title=\"开发环境配置\"></a>开发环境配置</h2><p>开发环境配置：能让代码运行<br>    运行项目指令：<br>      webpack 会将打包结果输出出去<br>      npx webpack-dev-server 只会在内存中编译打包，没有输出</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">HtmlWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;js/built.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      <span class=\"comment\">// loader的配置</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理less资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [<span class=\"string\">&#x27;style-loader&#x27;</span>, <span class=\"string\">&#x27;css-loader&#x27;</span>, <span class=\"string\">&#x27;less-loader&#x27;</span>]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理css资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [<span class=\"string\">&#x27;style-loader&#x27;</span>, <span class=\"string\">&#x27;css-loader&#x27;</span>]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理图片资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(jpg|png|gif)$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;url-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">limit</span>: <span class=\"number\">8</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 关闭es6模块化</span></span><br><span class=\"line\">          <span class=\"attr\">esModule</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"attr\">outputPath</span>: <span class=\"string\">&#x27;imgs&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理html中img资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.html$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;html-loader&#x27;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理其他资源</span></span><br><span class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/\\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;file-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">outputPath</span>: <span class=\"string\">&#x27;media&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"comment\">// plugins的配置</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlWebpackPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">&#x27;./src/index.html&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;development&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">contentBase</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">compress</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">3000</span>,</span><br><span class=\"line\">    <span class=\"attr\">open</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"五个核心概念\"><a href=\"#五个核心概念\" class=\"headerlink\" title=\"五个核心概念\"></a>五个核心概念</h3><p><code>entry</code> 指定webpack打包的入口文件<br><code>output</code> 配置webpack打包输出<br><code>loader</code>  loader是一种打包的方案，webpack默认只识别js结尾的文件<br><code>plugins</code> 插件，有些类型loader不能完全解决，需要使用插件<br><code>mode</code> 指定webpack打包模式，包括开发模式、生产模式</p>\n<h2 id=\"安装打包初体验\"><a href=\"#安装打包初体验\" class=\"headerlink\" title=\"安装打包初体验\"></a>安装打包初体验</h2><p>初始package.json<br><code>npm init -y</code><br>全局安装<br><code>npm i webpack webpack-cli -g</code><br>生产安装<br><code>npm i webpack webpack-cli -D</code></p>\n<p>1、入口文件<br>2、运行打包<br>开发环境 :<code>webpack ./src/index.js -o ./build/built.js --mode=developent</code><br>  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js<br>生产环境 :<code>webpack ./src/index.js -o ./build/built.js --mode=production</code><br>  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/buil.js<br>3、查看是否打包成功<br>（1）node命令<br>    <code>npm buil.js</code> (打包完成的js文件）<br>（2）script标签<br>    在build目录下新建一个html文件，在该文件中通过script标签引入打包完成的js文件</p>\n<h2 id=\"webpack-config-js\"><a href=\"#webpack-config-js\" class=\"headerlink\" title=\"webpack.config.js\"></a>webpack.config.js</h2><p>webpack默认只能打包js、json资源,要打包样式资源要使用loader<br>loader在webpack.config.js中配置</p>\n<p>webpack的配置文件,作用：指示 webpack 干那些活（当你运行 webpack 指令时，会加载里面的配置）</p>\n<p>基本配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// resolve用来拼接绝对路径的方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">  <span class=\"comment\">// 入口起点</span></span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 输出</span></span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 输出文件名</span></span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;built.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 输出路径</span></span><br><span class=\"line\">    <span class=\"comment\">// __dirname nodejs的变量，代表当前文件的目录绝对路径</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// loader的配置</span></span><br><span class=\"line\">  <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">\t<span class=\"comment\">//详细loader配置</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// plugins的配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"comment\">// 详细plugins的配置</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">// 模式</span></span><br><span class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;development&#x27;</span>, <span class=\"comment\">// 开发模式</span></span><br><span class=\"line\">  <span class=\"comment\">// mode: &#x27;production&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包样式资源\"><a href=\"#打包样式资源\" class=\"headerlink\" title=\"打包样式资源\"></a>打包样式资源</h2><p>打包样式资源（.css/.less）,在<code>module</code>中配置loader<br>需要通过npm在目录中安装<code>css-loader</code>、<code>style-loader</code>、<code>less-loader</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      <span class=\"comment\">// 详细loader配置</span></span><br><span class=\"line\">      <span class=\"comment\">// 不同文件必须配置不同loader处理</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 匹配哪些文件</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 使用哪些loader进行处理</span></span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"comment\">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span></span><br><span class=\"line\">          <span class=\"comment\">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;style-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"string\">&#x27;style-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 将less文件编译成css文件</span></span><br><span class=\"line\">          <span class=\"comment\">// 需要下载 less-loader和less</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;less-loader&#x27;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包HTML资源\"><a href=\"#打包HTML资源\" class=\"headerlink\" title=\"打包HTML资源\"></a>打包HTML资源</h2><p>打包HTML资源需要在<code>plugins</code>中配置html-webpack-plugin:<br>功能: 默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）<br>需求：需要有结构的HTML文件<br>注意：在配置<code>plugins</code>之前要导入<code>html-webpack-plugin</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">HtmlWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;html-webpack-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"comment\">// plugins的配置</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlWebpackPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 复制 &#x27;./src/index.html&#x27; 文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">&#x27;./src/index.html&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包图片资源\"><a href=\"#打包图片资源\" class=\"headerlink\" title=\"打包图片资源\"></a>打包图片资源</h2><p>打包图片资源（.jpg/.png/.gif）,在<code>module</code>中配置loader<br>需要通过npm在目录中安装<code>url-loader</code>、<code>file-loader</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">   <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 处理图片资源</span></span><br><span class=\"line\">       <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(jpg|png|gif)$/</span>,</span><br><span class=\"line\">       <span class=\"comment\">// 使用一个loader</span></span><br><span class=\"line\">       <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;url-loader&#x27;</span>,</span><br><span class=\"line\">       <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 图片大小小于8kb，就会被base64处理</span></span><br><span class=\"line\">         <span class=\"comment\">// 优点: 减少请求数量（减轻服务器压力）</span></span><br><span class=\"line\">         <span class=\"comment\">// 缺点：图片体积会更大（文件请求速度更慢）</span></span><br><span class=\"line\">         <span class=\"attr\">limit</span>: <span class=\"number\">8</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">         <span class=\"comment\">// 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs</span></span><br><span class=\"line\">         <span class=\"comment\">// 解析时会出问题：[object Module]</span></span><br><span class=\"line\">         <span class=\"comment\">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class=\"line\">         <span class=\"attr\">esModule</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">         <span class=\"comment\">// 给图片进行重命名</span></span><br><span class=\"line\">         <span class=\"comment\">// [hash:10]取图片的hash的前10位</span></span><br><span class=\"line\">         <span class=\"comment\">// [ext]取文件原来扩展名</span></span><br><span class=\"line\">         <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包图片资源-1\"><a href=\"#打包图片资源-1\" class=\"headerlink\" title=\"打包图片资源\"></a>打包图片资源</h2><p>打包图片资源（排除.css/.js/.html/.less）,在<code>module</code>中配置loader<br>需要通过npm在目录中安装<code>file-loader</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">   <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">     <span class=\"comment\">// 打包其他资源(除了html/js/css资源以外的资源)</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 排除css/js/html资源</span></span><br><span class=\"line\">       <span class=\"attr\">exclude</span>: <span class=\"regexp\">/\\.(css|js|html|less)$/</span>,</span><br><span class=\"line\">       <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;file-loader&#x27;</span>,</span><br><span class=\"line\">       <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">         <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a>devServer</h2><p>开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~）<br>特点：只会在内存中编译打包，不会有任何输出<br>启动devServer指令为：npx webpack-dev-server</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 项目构建后路径</span></span><br><span class=\"line\">    <span class=\"attr\">contentBase</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 启动gzip压缩</span></span><br><span class=\"line\">    <span class=\"attr\">compress</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 端口号</span></span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">3000</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 自动打开浏览器</span></span><br><span class=\"line\">    <span class=\"attr\">open</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开发环境配置\"><a href=\"#开发环境配置\" class=\"headerlink\" title=\"开发环境配置\"></a>开发环境配置</h2><p>开发环境配置：能让代码运行<br>    运行项目指令：<br>      webpack 会将打包结果输出出去<br>      npx webpack-dev-server 只会在内存中编译打包，没有输出</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; resolve &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">HtmlWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;js/built.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      <span class=\"comment\">// loader的配置</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理less资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [<span class=\"string\">&#x27;style-loader&#x27;</span>, <span class=\"string\">&#x27;css-loader&#x27;</span>, <span class=\"string\">&#x27;less-loader&#x27;</span>]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理css资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [<span class=\"string\">&#x27;style-loader&#x27;</span>, <span class=\"string\">&#x27;css-loader&#x27;</span>]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理图片资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(jpg|png|gif)$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;url-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">limit</span>: <span class=\"number\">8</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 关闭es6模块化</span></span><br><span class=\"line\">          <span class=\"attr\">esModule</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"attr\">outputPath</span>: <span class=\"string\">&#x27;imgs&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理html中img资源</span></span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.html$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;html-loader&#x27;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理其他资源</span></span><br><span class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/\\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;file-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">outputPath</span>: <span class=\"string\">&#x27;media&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"comment\">// plugins的配置</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlWebpackPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">&#x27;./src/index.html&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;development&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">contentBase</span>: <span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;build&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">compress</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">port</span>: <span class=\"number\">3000</span>,</span><br><span class=\"line\">    <span class=\"attr\">open</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"vue源码分析-手写模拟简单源码(2)","date":"2020-02-24T04:31:20.000Z","description":"Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.","_content":"\n要解决一个问题: 使用 'xxx.yyy.zzz' 可以来访问某一个对象，就是用字符串路径来访问对象的成员。\n\n```js\n function getValueByPath( obj, path ) {\n      let paths = path.split( '.' ); // [ xxx, yyy, zzz ]\n      let res = obj;\n      let prop;\n      while( prop = paths.shift() ) {\n        res = res[ prop ];\n      }\n      return res;\n    }\n```\n\n将上一篇的方法改进一下:\n\n```js\nfunction compiler( template, data ) {\n      let childNodes = template.childNodes; // 取出子元素\n      for ( let i = 0; i < childNodes.length; i++ ) {\n        let type = childNodes[ i ].nodeType; // 1 元素, 3 文本节点\n        if ( type === 3 ) {\n          // 文本节点, 可以判断里面是否有 需要 插值\n          let txt = childNodes[ i ].nodeValue; // 该属性只有文本节点才有意义\n          // 有没有双花括号??? \n          txt = txt.replace( rkuohao, function ( _, g ) { // replace 使用正则匹配一次 函数就会被调用一次\n\t\t\t// 函数的 第 0 个参数 表示匹配到的内容\n\t\t\t// 函数的 第 n 个参数 表示正则中的 第 n 组\n\tlet path = g.trim(); // 写在双花括号里面的 东西\n           let value = getValueByPath( data, path );\n            // 将 {{ xxxx }} 用这个 值替换\n            return value;\n          } );\n```\n\n来源: 腾讯课堂蒋坤公开课","source":"_posts/2-Vue.md","raw":"---\ntitle: vue源码分析-手写模拟简单源码(2)\ndate: 2020-02-24 12:31:20\ncategories: vue\ntags: [vue]\ndescription: Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.\n---\n\n要解决一个问题: 使用 'xxx.yyy.zzz' 可以来访问某一个对象，就是用字符串路径来访问对象的成员。\n\n```js\n function getValueByPath( obj, path ) {\n      let paths = path.split( '.' ); // [ xxx, yyy, zzz ]\n      let res = obj;\n      let prop;\n      while( prop = paths.shift() ) {\n        res = res[ prop ];\n      }\n      return res;\n    }\n```\n\n将上一篇的方法改进一下:\n\n```js\nfunction compiler( template, data ) {\n      let childNodes = template.childNodes; // 取出子元素\n      for ( let i = 0; i < childNodes.length; i++ ) {\n        let type = childNodes[ i ].nodeType; // 1 元素, 3 文本节点\n        if ( type === 3 ) {\n          // 文本节点, 可以判断里面是否有 需要 插值\n          let txt = childNodes[ i ].nodeValue; // 该属性只有文本节点才有意义\n          // 有没有双花括号??? \n          txt = txt.replace( rkuohao, function ( _, g ) { // replace 使用正则匹配一次 函数就会被调用一次\n\t\t\t// 函数的 第 0 个参数 表示匹配到的内容\n\t\t\t// 函数的 第 n 个参数 表示正则中的 第 n 组\n\tlet path = g.trim(); // 写在双花括号里面的 东西\n           let value = getValueByPath( data, path );\n            // 将 {{ xxxx }} 用这个 值替换\n            return value;\n          } );\n```\n\n来源: 腾讯课堂蒋坤公开课","slug":"2-Vue","published":1,"updated":"2021-09-08T14:15:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lb0006dswkc03s3xdj","content":"<p>要解决一个问题: 使用 ‘xxx.yyy.zzz’ 可以来访问某一个对象，就是用字符串路径来访问对象的成员。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getValueByPath</span>(<span class=\"params\"> obj, path </span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> paths = path.<span class=\"title function_\">split</span>( <span class=\"string\">&#x27;.&#x27;</span> ); <span class=\"comment\">// [ xxx, yyy, zzz ]</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> res = obj;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> prop;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>( prop = paths.<span class=\"title function_\">shift</span>() ) &#123;</span><br><span class=\"line\">       res = res[ prop ];</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>将上一篇的方法改进一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compiler</span>(<span class=\"params\"> template, data </span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> childNodes = template.<span class=\"property\">childNodes</span>; <span class=\"comment\">// 取出子元素</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childNodes.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> type = childNodes[ i ].<span class=\"property\">nodeType</span>; <span class=\"comment\">// 1 元素, 3 文本节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type === <span class=\"number\">3</span> ) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 文本节点, 可以判断里面是否有 需要 插值</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> txt = childNodes[ i ].<span class=\"property\">nodeValue</span>; <span class=\"comment\">// 该属性只有文本节点才有意义</span></span><br><span class=\"line\">          <span class=\"comment\">// 有没有双花括号??? </span></span><br><span class=\"line\">          txt = txt.<span class=\"title function_\">replace</span>( rkuohao, <span class=\"keyword\">function</span> (<span class=\"params\"> _, g </span>) &#123; <span class=\"comment\">// replace 使用正则匹配一次 函数就会被调用一次</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 函数的 第 0 个参数 表示匹配到的内容</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 函数的 第 n 个参数 表示正则中的 第 n 组</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> path = g.<span class=\"title function_\">trim</span>(); <span class=\"comment\">// 写在双花括号里面的 东西</span></span><br><span class=\"line\">           <span class=\"keyword\">let</span> value = <span class=\"title function_\">getValueByPath</span>( data, path );</span><br><span class=\"line\">            <span class=\"comment\">// 将 &#123;&#123; xxxx &#125;&#125; 用这个 值替换</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">          &#125; );</span><br></pre></td></tr></table></figure>\n\n<p>来源: 腾讯课堂蒋坤公开课</p>\n","site":{"data":{}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","excerpt":"","more":"<p>要解决一个问题: 使用 ‘xxx.yyy.zzz’ 可以来访问某一个对象，就是用字符串路径来访问对象的成员。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getValueByPath</span>(<span class=\"params\"> obj, path </span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> paths = path.<span class=\"title function_\">split</span>( <span class=\"string\">&#x27;.&#x27;</span> ); <span class=\"comment\">// [ xxx, yyy, zzz ]</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> res = obj;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> prop;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>( prop = paths.<span class=\"title function_\">shift</span>() ) &#123;</span><br><span class=\"line\">       res = res[ prop ];</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>将上一篇的方法改进一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compiler</span>(<span class=\"params\"> template, data </span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> childNodes = template.<span class=\"property\">childNodes</span>; <span class=\"comment\">// 取出子元素</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childNodes.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> type = childNodes[ i ].<span class=\"property\">nodeType</span>; <span class=\"comment\">// 1 元素, 3 文本节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type === <span class=\"number\">3</span> ) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 文本节点, 可以判断里面是否有 需要 插值</span></span><br><span class=\"line\">          <span class=\"keyword\">let</span> txt = childNodes[ i ].<span class=\"property\">nodeValue</span>; <span class=\"comment\">// 该属性只有文本节点才有意义</span></span><br><span class=\"line\">          <span class=\"comment\">// 有没有双花括号??? </span></span><br><span class=\"line\">          txt = txt.<span class=\"title function_\">replace</span>( rkuohao, <span class=\"keyword\">function</span> (<span class=\"params\"> _, g </span>) &#123; <span class=\"comment\">// replace 使用正则匹配一次 函数就会被调用一次</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 函数的 第 0 个参数 表示匹配到的内容</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 函数的 第 n 个参数 表示正则中的 第 n 组</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> path = g.<span class=\"title function_\">trim</span>(); <span class=\"comment\">// 写在双花括号里面的 东西</span></span><br><span class=\"line\">           <span class=\"keyword\">let</span> value = <span class=\"title function_\">getValueByPath</span>( data, path );</span><br><span class=\"line\">            <span class=\"comment\">// 将 &#123;&#123; xxxx &#125;&#125; 用这个 值替换</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">          &#125; );</span><br></pre></td></tr></table></figure>\n\n<p>来源: 腾讯课堂蒋坤公开课</p>\n"},{"title":"webpack-开发环境配置 2","date":"2020-02-29T06:44:20.000Z","description":"webpack是一个现代JavasScript应用程序的模块打包器(module bunder)官方网站https://www.webpackjs.com/","cover":"https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg","_content":"\n## 提取css成单独文件\n\n一般webpack打包，会把css打包到js文件中，如果在生产环境时，需要把css文件提取成单独的一个文件，减小打包结果的js文件的体积\n提取css成单独文件需要使用插件`mini-css-extract-plugin`,我们需要通过npm下载，然后导入\n```js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n```\n在插件`plugins`中配置\n```js\n plugins: [\n    new MiniCssExtractPlugin({\n      // 对输出的css文件进行重命名\n      filename: 'css/built.css'\n    })\n  ]\n```\n然后将处理css的'style-loader'替换，'style-loader'会在html添加style标签\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 这个loader取代style-loader。作用：提取js中的css成单独文件\n          MiniCssExtractPlugin.loader,\n          // 将css文件整合到js文件中\n          'css-loader'\n        ]\n      }\n    ]\n  }\n```\n\n## css兼容性处理\n\ncss兼容性处理：postcss --> postcss-loader postcss-preset-env\n需要通过npm下载`postcss-loader`、`postcss-preset-env`\n\n还需要在文件夹得package.json中配置`browserslist`,而`postcss-preset-env`帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式\n\npackage.json\n```js\n\tbrowserslist\": {\n              // 开发环境 --> 设置node环境变量：process.env.NODE_ENV = development\n              \"development\": [\n                \"last 1 chrome version\",//兼容chrome 最近得版本\n                \"last 1 firefox version\",\n                \"last 1 safari version\"\n              ],\n              // 生产环境：默认就是看生产环境\n              \"production\": [\n                \">0.2%\",\n               \"not dead\",//已经死掉得版本\n                \"not op_mini all\"//不要op_mini的浏览器\n              ]\n            }\n```\n在开发环境的时候，需要设置node环境变量:\n```js\nprocess.env.NODE_ENV = development\n```\n使用`postcss-loader`的默认配置\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n\t//提取css成单独文件\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          // 使用loader的默认配置\n           'postcss-loader',\n\n          } ] }] }\n```\n修改`postcss-loader`的配置\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          // 修改loader的配置\n          {\n            loader: 'postcss-loader',\n            options: {\n              ident: 'postcss',\n              plugins: () => [\n                // postcss的插件\n                require('postcss-preset-env')()\n              ] } \n         }]} ]}\n```\n## 压缩css文件\n\n压缩只需要npm下载插件`optimize-css-assets-webpack-plugin`\n```js\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n```\n```js\n plugins: [\n    // 压缩css\n    new OptimizeCssAssetsWebpackPlugin()\n  ]\n```\n\n## js语法检查\n\njs语法检查需要npm下载： eslint-loader  eslint\n 注意：只检查自己写的源代码，第三方的库是不用检查的\n```js\n\tpackage.json中eslintConfig中设置~\n \t\"eslintConfig\": {\n                \"extends\": \"airbnb-base\"\n              }\n```\n```js\nwebpack.config.js的loader配置\nmodule: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,//第三方的库是不用检查的\n        loader: 'eslint-loader',\n        options: {\n          // 自动修复eslint的错误\n          fix: true\n        }\n      }]}\n```\n\n## js兼容性处理\n\n  js兼容性处理：babel-loader @babel/core \n1. 基本js兼容性处理 --> @babel/preset-env\n         问题：只能转换基本语法，如promise高级语法不能转换\n2. 全部js兼容性处理 --> @babel/polyfill  //直接在js中引入`import \"@babel/polyfill \"`\n         问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~\n3. 需要做兼容性处理的就做：按需加载  --> core-js\n```js\nnpm i babel-loader @babel/preset-env @babel/core -D\nnpm i core-js -D\n```\n```js\nwebpack.config.js的loader配置\n module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,//只需要兼容我们自己写的js\n        loader: 'babel-loader',\n        options: {\n          // 预设：指示babel做怎么样的兼容性处理\n          presets: [\n            [\n              '@babel/preset-env',\n              {\n                // 按需加载\n                useBuiltIns: 'usage',\n                // 指定core-js版本\n                corejs: {\n                  version: 3\n                },\n                // 指定兼容性做到哪个版本浏览器\n                targets: {\n                  chrome: '60',\n                  firefox: '60',\n                  ie: '9',\n                  safari: '10',\n                  edge: '17'\n                }\n              }]]} }]}\n```\n## js压缩\n\n // 生产环境下会自动压缩js代码\n `mode: 'production'`\n\n## html压缩\n\nheml压缩需要使用插件`html-webpack-plugin`\n```js\n//导入插件\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n//配置插件\nplugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      // 压缩html代码\n      minify: {\n        // 移除空格\n        collapseWhitespace: true,\n        // 移除注释\n        removeComments: true\n      }\n    })]\n```","source":"_posts/2-webpack.md","raw":"---\ntitle: webpack-开发环境配置 2\ndate: 2020-02-29 14:44:20\ncategories: webpack\ntags: [webpack]\ndescription: webpack是一个现代JavasScript应用程序的模块打包器(module bunder)官方网站https://www.webpackjs.com/\ncover: https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg\n---\n\n## 提取css成单独文件\n\n一般webpack打包，会把css打包到js文件中，如果在生产环境时，需要把css文件提取成单独的一个文件，减小打包结果的js文件的体积\n提取css成单独文件需要使用插件`mini-css-extract-plugin`,我们需要通过npm下载，然后导入\n```js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n```\n在插件`plugins`中配置\n```js\n plugins: [\n    new MiniCssExtractPlugin({\n      // 对输出的css文件进行重命名\n      filename: 'css/built.css'\n    })\n  ]\n```\n然后将处理css的'style-loader'替换，'style-loader'会在html添加style标签\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 这个loader取代style-loader。作用：提取js中的css成单独文件\n          MiniCssExtractPlugin.loader,\n          // 将css文件整合到js文件中\n          'css-loader'\n        ]\n      }\n    ]\n  }\n```\n\n## css兼容性处理\n\ncss兼容性处理：postcss --> postcss-loader postcss-preset-env\n需要通过npm下载`postcss-loader`、`postcss-preset-env`\n\n还需要在文件夹得package.json中配置`browserslist`,而`postcss-preset-env`帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式\n\npackage.json\n```js\n\tbrowserslist\": {\n              // 开发环境 --> 设置node环境变量：process.env.NODE_ENV = development\n              \"development\": [\n                \"last 1 chrome version\",//兼容chrome 最近得版本\n                \"last 1 firefox version\",\n                \"last 1 safari version\"\n              ],\n              // 生产环境：默认就是看生产环境\n              \"production\": [\n                \">0.2%\",\n               \"not dead\",//已经死掉得版本\n                \"not op_mini all\"//不要op_mini的浏览器\n              ]\n            }\n```\n在开发环境的时候，需要设置node环境变量:\n```js\nprocess.env.NODE_ENV = development\n```\n使用`postcss-loader`的默认配置\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n\t//提取css成单独文件\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          // 使用loader的默认配置\n           'postcss-loader',\n\n          } ] }] }\n```\n修改`postcss-loader`的配置\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          // 修改loader的配置\n          {\n            loader: 'postcss-loader',\n            options: {\n              ident: 'postcss',\n              plugins: () => [\n                // postcss的插件\n                require('postcss-preset-env')()\n              ] } \n         }]} ]}\n```\n## 压缩css文件\n\n压缩只需要npm下载插件`optimize-css-assets-webpack-plugin`\n```js\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n```\n```js\n plugins: [\n    // 压缩css\n    new OptimizeCssAssetsWebpackPlugin()\n  ]\n```\n\n## js语法检查\n\njs语法检查需要npm下载： eslint-loader  eslint\n 注意：只检查自己写的源代码，第三方的库是不用检查的\n```js\n\tpackage.json中eslintConfig中设置~\n \t\"eslintConfig\": {\n                \"extends\": \"airbnb-base\"\n              }\n```\n```js\nwebpack.config.js的loader配置\nmodule: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,//第三方的库是不用检查的\n        loader: 'eslint-loader',\n        options: {\n          // 自动修复eslint的错误\n          fix: true\n        }\n      }]}\n```\n\n## js兼容性处理\n\n  js兼容性处理：babel-loader @babel/core \n1. 基本js兼容性处理 --> @babel/preset-env\n         问题：只能转换基本语法，如promise高级语法不能转换\n2. 全部js兼容性处理 --> @babel/polyfill  //直接在js中引入`import \"@babel/polyfill \"`\n         问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~\n3. 需要做兼容性处理的就做：按需加载  --> core-js\n```js\nnpm i babel-loader @babel/preset-env @babel/core -D\nnpm i core-js -D\n```\n```js\nwebpack.config.js的loader配置\n module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,//只需要兼容我们自己写的js\n        loader: 'babel-loader',\n        options: {\n          // 预设：指示babel做怎么样的兼容性处理\n          presets: [\n            [\n              '@babel/preset-env',\n              {\n                // 按需加载\n                useBuiltIns: 'usage',\n                // 指定core-js版本\n                corejs: {\n                  version: 3\n                },\n                // 指定兼容性做到哪个版本浏览器\n                targets: {\n                  chrome: '60',\n                  firefox: '60',\n                  ie: '9',\n                  safari: '10',\n                  edge: '17'\n                }\n              }]]} }]}\n```\n## js压缩\n\n // 生产环境下会自动压缩js代码\n `mode: 'production'`\n\n## html压缩\n\nheml压缩需要使用插件`html-webpack-plugin`\n```js\n//导入插件\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n//配置插件\nplugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      // 压缩html代码\n      minify: {\n        // 移除空格\n        collapseWhitespace: true,\n        // 移除注释\n        removeComments: true\n      }\n    })]\n```","slug":"2-webpack","published":1,"updated":"2021-09-15T08:31:25.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1ld000adswkdrrq9zol","content":"<h2 id=\"提取css成单独文件\"><a href=\"#提取css成单独文件\" class=\"headerlink\" title=\"提取css成单独文件\"></a>提取css成单独文件</h2><p>一般webpack打包，会把css打包到js文件中，如果在生产环境时，需要把css文件提取成单独的一个文件，减小打包结果的js文件的体积<br>提取css成单独文件需要使用插件<code>mini-css-extract-plugin</code>,我们需要通过npm下载，然后导入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MiniCssExtractPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>在插件<code>plugins</code>中配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">   <span class=\"keyword\">new</span> <span class=\"title class_\">MiniCssExtractPlugin</span>(&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 对输出的css文件进行重命名</span></span><br><span class=\"line\">     <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;css/built.css&#x27;</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n<p>然后将处理css的’style-loader’替换，’style-loader’会在html添加style标签</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"comment\">// 这个loader取代style-loader。作用：提取js中的css成单独文件</span></span><br><span class=\"line\">          <span class=\"title class_\">MiniCssExtractPlugin</span>.<span class=\"property\">loader</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 将css文件整合到js文件中</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"css兼容性处理\"><a href=\"#css兼容性处理\" class=\"headerlink\" title=\"css兼容性处理\"></a>css兼容性处理</h2><p>css兼容性处理：postcss –&gt; postcss-loader postcss-preset-env<br>需要通过npm下载<code>postcss-loader</code>、<code>postcss-preset-env</code></p>\n<p>还需要在文件夹得package.json中配置<code>browserslist</code>,而<code>postcss-preset-env</code>帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式</p>\n<p>package.json</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browserslist<span class=\"string\">&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">             // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span></span><br><span class=\"line\"><span class=\"string\">             &quot;</span>development<span class=\"string\">&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>last <span class=\"number\">1</span> chrome version<span class=\"string\">&quot;,//兼容chrome 最近得版本</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>last <span class=\"number\">1</span> firefox version<span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>last <span class=\"number\">1</span> safari version<span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">             ],</span></span><br><span class=\"line\"><span class=\"string\">             // 生产环境：默认就是看生产环境</span></span><br><span class=\"line\"><span class=\"string\">             &quot;</span>production<span class=\"string\">&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>&gt;<span class=\"number\">0.2</span>%<span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">              &quot;</span>not dead<span class=\"string\">&quot;,//已经死掉得版本</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>not op_mini all<span class=\"string\">&quot;//不要op_mini的浏览器</span></span><br><span class=\"line\"><span class=\"string\">             ]</span></span><br><span class=\"line\"><span class=\"string\">           &#125;</span></span><br></pre></td></tr></table></figure>\n<p>在开发环境的时候，需要设置node环境变量:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> = development</span><br></pre></td></tr></table></figure>\n<p>使用<code>postcss-loader</code>的默认配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">\t<span class=\"comment\">//提取css成单独文件</span></span><br><span class=\"line\">          <span class=\"title class_\">MiniCssExtractPlugin</span>.<span class=\"property\">loader</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 使用loader的默认配置</span></span><br><span class=\"line\">           <span class=\"string\">&#x27;postcss-loader&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">          &#125; ] &#125;] &#125;</span><br></pre></td></tr></table></figure>\n<p>修改<code>postcss-loader</code>的配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"title class_\">MiniCssExtractPlugin</span>.<span class=\"property\">loader</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 修改loader的配置</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;postcss-loader&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">ident</span>: <span class=\"string\">&#x27;postcss&#x27;</span>,</span><br><span class=\"line\">              <span class=\"attr\">plugins</span>: <span class=\"function\">() =&gt;</span> [</span><br><span class=\"line\">                <span class=\"comment\">// postcss的插件</span></span><br><span class=\"line\">                <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;postcss-preset-env&#x27;</span>)()</span><br><span class=\"line\">              ] &#125; </span><br><span class=\"line\">         &#125;]&#125; ]&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"压缩css文件\"><a href=\"#压缩css文件\" class=\"headerlink\" title=\"压缩css文件\"></a>压缩css文件</h2><p>压缩只需要npm下载插件<code>optimize-css-assets-webpack-plugin</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">OptimizeCssAssetsWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">   <span class=\"comment\">// 压缩css</span></span><br><span class=\"line\">   <span class=\"keyword\">new</span> <span class=\"title class_\">OptimizeCssAssetsWebpackPlugin</span>()</span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"js语法检查\"><a href=\"#js语法检查\" class=\"headerlink\" title=\"js语法检查\"></a>js语法检查</h2><p>js语法检查需要npm下载： eslint-loader  eslint<br> 注意：只检查自己写的源代码，第三方的库是不用检查的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.<span class=\"property\">json</span>中eslintConfig中设置~</span><br><span class=\"line\">\t<span class=\"string\">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class=\"line\">               <span class=\"string\">&quot;extends&quot;</span>: <span class=\"string\">&quot;airbnb-base&quot;</span></span><br><span class=\"line\">             &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.<span class=\"property\">config</span>.<span class=\"property\">js</span>的loader配置</span><br><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>,<span class=\"comment\">//第三方的库是不用检查的</span></span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;eslint-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 自动修复eslint的错误</span></span><br><span class=\"line\">          <span class=\"attr\">fix</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"js兼容性处理\"><a href=\"#js兼容性处理\" class=\"headerlink\" title=\"js兼容性处理\"></a>js兼容性处理</h2><p>  js兼容性处理：babel-loader @babel/core </p>\n<ol>\n<li><p>基本js兼容性处理 –&gt; @babel/preset-env</p>\n<pre><code>问题：只能转换基本语法，如promise高级语法不能转换</code></pre></li>\n<li><p>全部js兼容性处理 –&gt; @babel/polyfill  //直接在js中引入<code>import &quot;@babel/polyfill &quot;</code></p>\n<pre><code>问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~</code></pre></li>\n<li><p>需要做兼容性处理的就做：按需加载  –&gt; core-js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i babel-loader @babel/preset-env @babel/core -D</span><br><span class=\"line\">npm i core-js -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.<span class=\"property\">config</span>.<span class=\"property\">js</span>的loader配置</span><br><span class=\"line\"> <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>,<span class=\"comment\">//只需要兼容我们自己写的js</span></span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;babel-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 预设：指示babel做怎么样的兼容性处理</span></span><br><span class=\"line\">          <span class=\"attr\">presets</span>: [</span><br><span class=\"line\">            [</span><br><span class=\"line\">              <span class=\"string\">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 按需加载</span></span><br><span class=\"line\">                <span class=\"attr\">useBuiltIns</span>: <span class=\"string\">&#x27;usage&#x27;</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 指定core-js版本</span></span><br><span class=\"line\">                <span class=\"attr\">corejs</span>: &#123;</span><br><span class=\"line\">                  <span class=\"attr\">version</span>: <span class=\"number\">3</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"comment\">// 指定兼容性做到哪个版本浏览器</span></span><br><span class=\"line\">                <span class=\"attr\">targets</span>: &#123;</span><br><span class=\"line\">                  <span class=\"attr\">chrome</span>: <span class=\"string\">&#x27;60&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">firefox</span>: <span class=\"string\">&#x27;60&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">ie</span>: <span class=\"string\">&#x27;9&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">safari</span>: <span class=\"string\">&#x27;10&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">edge</span>: <span class=\"string\">&#x27;17&#x27;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;]]&#125; &#125;]&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"js压缩\"><a href=\"#js压缩\" class=\"headerlink\" title=\"js压缩\"></a>js压缩</h2><p>// 生产环境下会自动压缩js代码<br><code>mode: &#39;production&#39;</code></p>\n</li>\n</ol>\n<h2 id=\"html压缩\"><a href=\"#html压缩\" class=\"headerlink\" title=\"html压缩\"></a>html压缩</h2><p>heml压缩需要使用插件<code>html-webpack-plugin</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//导入插件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">HtmlWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//配置插件</span></span><br><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlWebpackPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">&#x27;./src/index.html&#x27;</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 压缩html代码</span></span><br><span class=\"line\">      <span class=\"attr\">minify</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 移除空格</span></span><br><span class=\"line\">        <span class=\"attr\">collapseWhitespace</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 移除注释</span></span><br><span class=\"line\">        <span class=\"attr\">removeComments</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"提取css成单独文件\"><a href=\"#提取css成单独文件\" class=\"headerlink\" title=\"提取css成单独文件\"></a>提取css成单独文件</h2><p>一般webpack打包，会把css打包到js文件中，如果在生产环境时，需要把css文件提取成单独的一个文件，减小打包结果的js文件的体积<br>提取css成单独文件需要使用插件<code>mini-css-extract-plugin</code>,我们需要通过npm下载，然后导入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MiniCssExtractPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>在插件<code>plugins</code>中配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">   <span class=\"keyword\">new</span> <span class=\"title class_\">MiniCssExtractPlugin</span>(&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 对输出的css文件进行重命名</span></span><br><span class=\"line\">     <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;css/built.css&#x27;</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n<p>然后将处理css的’style-loader’替换，’style-loader’会在html添加style标签</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"comment\">// 这个loader取代style-loader。作用：提取js中的css成单独文件</span></span><br><span class=\"line\">          <span class=\"title class_\">MiniCssExtractPlugin</span>.<span class=\"property\">loader</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 将css文件整合到js文件中</span></span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"css兼容性处理\"><a href=\"#css兼容性处理\" class=\"headerlink\" title=\"css兼容性处理\"></a>css兼容性处理</h2><p>css兼容性处理：postcss –&gt; postcss-loader postcss-preset-env<br>需要通过npm下载<code>postcss-loader</code>、<code>postcss-preset-env</code></p>\n<p>还需要在文件夹得package.json中配置<code>browserslist</code>,而<code>postcss-preset-env</code>帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式</p>\n<p>package.json</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browserslist<span class=\"string\">&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">             // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span></span><br><span class=\"line\"><span class=\"string\">             &quot;</span>development<span class=\"string\">&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>last <span class=\"number\">1</span> chrome version<span class=\"string\">&quot;,//兼容chrome 最近得版本</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>last <span class=\"number\">1</span> firefox version<span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>last <span class=\"number\">1</span> safari version<span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">             ],</span></span><br><span class=\"line\"><span class=\"string\">             // 生产环境：默认就是看生产环境</span></span><br><span class=\"line\"><span class=\"string\">             &quot;</span>production<span class=\"string\">&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>&gt;<span class=\"number\">0.2</span>%<span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">              &quot;</span>not dead<span class=\"string\">&quot;,//已经死掉得版本</span></span><br><span class=\"line\"><span class=\"string\">               &quot;</span>not op_mini all<span class=\"string\">&quot;//不要op_mini的浏览器</span></span><br><span class=\"line\"><span class=\"string\">             ]</span></span><br><span class=\"line\"><span class=\"string\">           &#125;</span></span><br></pre></td></tr></table></figure>\n<p>在开发环境的时候，需要设置node环境变量:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> = development</span><br></pre></td></tr></table></figure>\n<p>使用<code>postcss-loader</code>的默认配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">\t<span class=\"comment\">//提取css成单独文件</span></span><br><span class=\"line\">          <span class=\"title class_\">MiniCssExtractPlugin</span>.<span class=\"property\">loader</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 使用loader的默认配置</span></span><br><span class=\"line\">           <span class=\"string\">&#x27;postcss-loader&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">          &#125; ] &#125;] &#125;</span><br></pre></td></tr></table></figure>\n<p>修改<code>postcss-loader</code>的配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">use</span>: [</span><br><span class=\"line\">          <span class=\"title class_\">MiniCssExtractPlugin</span>.<span class=\"property\">loader</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 修改loader的配置</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;postcss-loader&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">ident</span>: <span class=\"string\">&#x27;postcss&#x27;</span>,</span><br><span class=\"line\">              <span class=\"attr\">plugins</span>: <span class=\"function\">() =&gt;</span> [</span><br><span class=\"line\">                <span class=\"comment\">// postcss的插件</span></span><br><span class=\"line\">                <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;postcss-preset-env&#x27;</span>)()</span><br><span class=\"line\">              ] &#125; </span><br><span class=\"line\">         &#125;]&#125; ]&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"压缩css文件\"><a href=\"#压缩css文件\" class=\"headerlink\" title=\"压缩css文件\"></a>压缩css文件</h2><p>压缩只需要npm下载插件<code>optimize-css-assets-webpack-plugin</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">OptimizeCssAssetsWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">   <span class=\"comment\">// 压缩css</span></span><br><span class=\"line\">   <span class=\"keyword\">new</span> <span class=\"title class_\">OptimizeCssAssetsWebpackPlugin</span>()</span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"js语法检查\"><a href=\"#js语法检查\" class=\"headerlink\" title=\"js语法检查\"></a>js语法检查</h2><p>js语法检查需要npm下载： eslint-loader  eslint<br> 注意：只检查自己写的源代码，第三方的库是不用检查的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.<span class=\"property\">json</span>中eslintConfig中设置~</span><br><span class=\"line\">\t<span class=\"string\">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class=\"line\">               <span class=\"string\">&quot;extends&quot;</span>: <span class=\"string\">&quot;airbnb-base&quot;</span></span><br><span class=\"line\">             &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.<span class=\"property\">config</span>.<span class=\"property\">js</span>的loader配置</span><br><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>,<span class=\"comment\">//第三方的库是不用检查的</span></span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;eslint-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 自动修复eslint的错误</span></span><br><span class=\"line\">          <span class=\"attr\">fix</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"js兼容性处理\"><a href=\"#js兼容性处理\" class=\"headerlink\" title=\"js兼容性处理\"></a>js兼容性处理</h2><p>  js兼容性处理：babel-loader @babel/core </p>\n<ol>\n<li><p>基本js兼容性处理 –&gt; @babel/preset-env</p>\n<pre><code>问题：只能转换基本语法，如promise高级语法不能转换</code></pre></li>\n<li><p>全部js兼容性处理 –&gt; @babel/polyfill  //直接在js中引入<code>import &quot;@babel/polyfill &quot;</code></p>\n<pre><code>问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~</code></pre></li>\n<li><p>需要做兼容性处理的就做：按需加载  –&gt; core-js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i babel-loader @babel/preset-env @babel/core -D</span><br><span class=\"line\">npm i core-js -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.<span class=\"property\">config</span>.<span class=\"property\">js</span>的loader配置</span><br><span class=\"line\"> <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>,<span class=\"comment\">//只需要兼容我们自己写的js</span></span><br><span class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;babel-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 预设：指示babel做怎么样的兼容性处理</span></span><br><span class=\"line\">          <span class=\"attr\">presets</span>: [</span><br><span class=\"line\">            [</span><br><span class=\"line\">              <span class=\"string\">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 按需加载</span></span><br><span class=\"line\">                <span class=\"attr\">useBuiltIns</span>: <span class=\"string\">&#x27;usage&#x27;</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 指定core-js版本</span></span><br><span class=\"line\">                <span class=\"attr\">corejs</span>: &#123;</span><br><span class=\"line\">                  <span class=\"attr\">version</span>: <span class=\"number\">3</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"comment\">// 指定兼容性做到哪个版本浏览器</span></span><br><span class=\"line\">                <span class=\"attr\">targets</span>: &#123;</span><br><span class=\"line\">                  <span class=\"attr\">chrome</span>: <span class=\"string\">&#x27;60&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">firefox</span>: <span class=\"string\">&#x27;60&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">ie</span>: <span class=\"string\">&#x27;9&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">safari</span>: <span class=\"string\">&#x27;10&#x27;</span>,</span><br><span class=\"line\">                  <span class=\"attr\">edge</span>: <span class=\"string\">&#x27;17&#x27;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;]]&#125; &#125;]&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"js压缩\"><a href=\"#js压缩\" class=\"headerlink\" title=\"js压缩\"></a>js压缩</h2><p>// 生产环境下会自动压缩js代码<br><code>mode: &#39;production&#39;</code></p>\n</li>\n</ol>\n<h2 id=\"html压缩\"><a href=\"#html压缩\" class=\"headerlink\" title=\"html压缩\"></a>html压缩</h2><p>heml压缩需要使用插件<code>html-webpack-plugin</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//导入插件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">HtmlWebpackPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//配置插件</span></span><br><span class=\"line\"><span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">HtmlWebpackPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">&#x27;./src/index.html&#x27;</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 压缩html代码</span></span><br><span class=\"line\">      <span class=\"attr\">minify</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 移除空格</span></span><br><span class=\"line\">        <span class=\"attr\">collapseWhitespace</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 移除注释</span></span><br><span class=\"line\">        <span class=\"attr\">removeComments</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)]</span><br></pre></td></tr></table></figure>"},{"title":"vue源码分析-手写模拟简单源码(3)","date":"2020-02-24T04:36:18.000Z","description":"Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.","cover":"https://i.loli.net/2021/09/15/iqmJedx4ahWXZSb.jpg","_content":"\n### 函数科里化\n\n概念:\n1. 科里化: 一个函数原本有多个参数, 之传入**一个**参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.\n2. 偏函数: 一个函数原本有多个参数, 之传入**一部分**参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.\n3. 高阶函数: 一个函数**参数是一个函数**, 该函数对参数这个函数进行加工, 得到一个函数, 这个加工用的函数就是高阶函数.\n为什么要使用科里化? 为了提升性能. 使用科里化可以缓存一部分能力.\n使用两个案例来说明:\n1. 判断元素\n2. 虚拟 DOM 的 render 方法\n1. 判断元素:\n\nVue 本质上是使用 HTML 的字符串作为模板的, 将字符串的 模板 转换为 AST, 再转换为 VNode.\n\n- 模板 -> AST\n- AST -> VNode\n- VNode -> DOM\n\n最消耗性能是字符串解析 ( 模板 -> AST )\n\n在 Vue 中每一个标签可以是真正的 HTML 标签, 也可以是自定义组件, 问怎么区分???\n在 Vue 源码中其实将所有可以用的 HTML 标签已经存起来了.\n假设这里是考虑几个标签:\n\n```js\nlet tags = 'div,p,a,img,ul,li'.split(',');\n```\n\n需要一个函数, 判断一个标签名是否为 内置的 标签\n\n```js\nfunction isHTMLTag( tagName ) {\n  tagName = tagName.toLowerCase();\n  if ( tags.indexOf( tagName ) > -1 ) return true;\n  return false;\n}\n```\n\n2. 虚拟 DOM 的 render 方法\n\n思考: vue 项目 *模板 转换为 抽象语法树* 需要执行几次??? \n\n- 页面一开始加载需要渲染\n- 每一个属性 ( 响应式 ) 数据在发生变化的时候 要渲染\n- watch, computed 等等\n\n以前写的代码 每次需要渲染的时候, 模板就会被解析一次 ( 注意, 这里我们简化了解析方法 )\n\nrender 的作用是将 虚拟 DOM 转换为 真正的 DOM 加到页面中\n\n- 虚拟 DOM 可以降级理解为 AST\n- 一个项目运行的时候 模板是不会变 的, 就表示 AST 是不会变的\n\n我们可以将代码进行优化, 将 虚拟 DOM 缓存起来, 生成一个函数, 函数只需要传入数据 就可以得到 真正的 DOM\n\n```js\nJGVue.prototype.createRenderFn = function () {\n      let ast = getVNode( this._template );\n      // Vue: 将 AST + data => VNode\n      // 我们: 带有坑的 VNode + data => 含有数据的 VNode\n      return function render () {//返回一个方法\n        // 将 带有 坑的 VNode 转换为 待数据的 VNode\n        let _tmp = combine( ast, this._data );\n        return _tmp;\n      }\n    }\n```\n\n在真正的 Vue 中使用了 二次提交的 设计结构\n\n1. 在 页面中 的 DOM 和 虚拟 DOM 是一一对应的关系\n2. 先 有 AST 和 数据 生成 VNode ( 新, render )\n3. 将 就的 VNode 和 新的 VNode 比较 ( diff ), 更新 ( update )\n\n参考资料:\n\n- [函数式编程](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)\n- [维基百科](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)\n\n来源: 腾讯课堂蒋坤公开课","source":"_posts/3-Vue.md","raw":"---\ntitle: vue源码分析-手写模拟简单源码(3)\ndate: 2020-02-24 12:36:18\ncategories: vue\ntags: [vue]\ndescription: Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.\ncover: https://i.loli.net/2021/09/15/iqmJedx4ahWXZSb.jpg\n---\n\n### 函数科里化\n\n概念:\n1. 科里化: 一个函数原本有多个参数, 之传入**一个**参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.\n2. 偏函数: 一个函数原本有多个参数, 之传入**一部分**参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.\n3. 高阶函数: 一个函数**参数是一个函数**, 该函数对参数这个函数进行加工, 得到一个函数, 这个加工用的函数就是高阶函数.\n为什么要使用科里化? 为了提升性能. 使用科里化可以缓存一部分能力.\n使用两个案例来说明:\n1. 判断元素\n2. 虚拟 DOM 的 render 方法\n1. 判断元素:\n\nVue 本质上是使用 HTML 的字符串作为模板的, 将字符串的 模板 转换为 AST, 再转换为 VNode.\n\n- 模板 -> AST\n- AST -> VNode\n- VNode -> DOM\n\n最消耗性能是字符串解析 ( 模板 -> AST )\n\n在 Vue 中每一个标签可以是真正的 HTML 标签, 也可以是自定义组件, 问怎么区分???\n在 Vue 源码中其实将所有可以用的 HTML 标签已经存起来了.\n假设这里是考虑几个标签:\n\n```js\nlet tags = 'div,p,a,img,ul,li'.split(',');\n```\n\n需要一个函数, 判断一个标签名是否为 内置的 标签\n\n```js\nfunction isHTMLTag( tagName ) {\n  tagName = tagName.toLowerCase();\n  if ( tags.indexOf( tagName ) > -1 ) return true;\n  return false;\n}\n```\n\n2. 虚拟 DOM 的 render 方法\n\n思考: vue 项目 *模板 转换为 抽象语法树* 需要执行几次??? \n\n- 页面一开始加载需要渲染\n- 每一个属性 ( 响应式 ) 数据在发生变化的时候 要渲染\n- watch, computed 等等\n\n以前写的代码 每次需要渲染的时候, 模板就会被解析一次 ( 注意, 这里我们简化了解析方法 )\n\nrender 的作用是将 虚拟 DOM 转换为 真正的 DOM 加到页面中\n\n- 虚拟 DOM 可以降级理解为 AST\n- 一个项目运行的时候 模板是不会变 的, 就表示 AST 是不会变的\n\n我们可以将代码进行优化, 将 虚拟 DOM 缓存起来, 生成一个函数, 函数只需要传入数据 就可以得到 真正的 DOM\n\n```js\nJGVue.prototype.createRenderFn = function () {\n      let ast = getVNode( this._template );\n      // Vue: 将 AST + data => VNode\n      // 我们: 带有坑的 VNode + data => 含有数据的 VNode\n      return function render () {//返回一个方法\n        // 将 带有 坑的 VNode 转换为 待数据的 VNode\n        let _tmp = combine( ast, this._data );\n        return _tmp;\n      }\n    }\n```\n\n在真正的 Vue 中使用了 二次提交的 设计结构\n\n1. 在 页面中 的 DOM 和 虚拟 DOM 是一一对应的关系\n2. 先 有 AST 和 数据 生成 VNode ( 新, render )\n3. 将 就的 VNode 和 新的 VNode 比较 ( diff ), 更新 ( update )\n\n参考资料:\n\n- [函数式编程](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)\n- [维基百科](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)\n\n来源: 腾讯课堂蒋坤公开课","slug":"3-Vue","published":1,"updated":"2021-09-15T08:36:55.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1le000bdswk6b0i8khf","content":"<h3 id=\"函数科里化\"><a href=\"#函数科里化\" class=\"headerlink\" title=\"函数科里化\"></a>函数科里化</h3><p>概念:</p>\n<ol>\n<li>科里化: 一个函数原本有多个参数, 之传入<strong>一个</strong>参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.</li>\n<li>偏函数: 一个函数原本有多个参数, 之传入<strong>一部分</strong>参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.</li>\n<li>高阶函数: 一个函数<strong>参数是一个函数</strong>, 该函数对参数这个函数进行加工, 得到一个函数, 这个加工用的函数就是高阶函数.<br>为什么要使用科里化? 为了提升性能. 使用科里化可以缓存一部分能力.<br>使用两个案例来说明:</li>\n<li>判断元素</li>\n<li>虚拟 DOM 的 render 方法</li>\n<li>判断元素:</li>\n</ol>\n<p>Vue 本质上是使用 HTML 的字符串作为模板的, 将字符串的 模板 转换为 AST, 再转换为 VNode.</p>\n<ul>\n<li>模板 -&gt; AST</li>\n<li>AST -&gt; VNode</li>\n<li>VNode -&gt; DOM</li>\n</ul>\n<p>最消耗性能是字符串解析 ( 模板 -&gt; AST )</p>\n<p>在 Vue 中每一个标签可以是真正的 HTML 标签, 也可以是自定义组件, 问怎么区分???<br>在 Vue 源码中其实将所有可以用的 HTML 标签已经存起来了.<br>假设这里是考虑几个标签:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tags = <span class=\"string\">&#x27;div,p,a,img,ul,li&#x27;</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>需要一个函数, 判断一个标签名是否为 内置的 标签</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isHTMLTag</span>(<span class=\"params\"> tagName </span>) &#123;</span><br><span class=\"line\">  tagName = tagName.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( tags.<span class=\"title function_\">indexOf</span>( tagName ) &gt; -<span class=\"number\">1</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>虚拟 DOM 的 render 方法</li>\n</ol>\n<p>思考: vue 项目 <em>模板 转换为 抽象语法树</em> 需要执行几次??? </p>\n<ul>\n<li>页面一开始加载需要渲染</li>\n<li>每一个属性 ( 响应式 ) 数据在发生变化的时候 要渲染</li>\n<li>watch, computed 等等</li>\n</ul>\n<p>以前写的代码 每次需要渲染的时候, 模板就会被解析一次 ( 注意, 这里我们简化了解析方法 )</p>\n<p>render 的作用是将 虚拟 DOM 转换为 真正的 DOM 加到页面中</p>\n<ul>\n<li>虚拟 DOM 可以降级理解为 AST</li>\n<li>一个项目运行的时候 模板是不会变 的, 就表示 AST 是不会变的</li>\n</ul>\n<p>我们可以将代码进行优化, 将 虚拟 DOM 缓存起来, 生成一个函数, 函数只需要传入数据 就可以得到 真正的 DOM</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JGVue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">createRenderFn</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> ast = <span class=\"title function_\">getVNode</span>( <span class=\"variable language_\">this</span>.<span class=\"property\">_template</span> );</span><br><span class=\"line\">      <span class=\"comment\">// Vue: 将 AST + data =&gt; VNode</span></span><br><span class=\"line\">      <span class=\"comment\">// 我们: 带有坑的 VNode + data =&gt; 含有数据的 VNode</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">render</span> () &#123;<span class=\"comment\">//返回一个方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 将 带有 坑的 VNode 转换为 待数据的 VNode</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> _tmp = <span class=\"title function_\">combine</span>( ast, <span class=\"variable language_\">this</span>.<span class=\"property\">_data</span> );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在真正的 Vue 中使用了 二次提交的 设计结构</p>\n<ol>\n<li>在 页面中 的 DOM 和 虚拟 DOM 是一一对应的关系</li>\n<li>先 有 AST 和 数据 生成 VNode ( 新, render )</li>\n<li>将 就的 VNode 和 新的 VNode 比较 ( diff ), 更新 ( update )</li>\n</ol>\n<p>参考资料:</p>\n<ul>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\">函数式编程</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\">维基百科</a></li>\n</ul>\n<p>来源: 腾讯课堂蒋坤公开课</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"函数科里化\"><a href=\"#函数科里化\" class=\"headerlink\" title=\"函数科里化\"></a>函数科里化</h3><p>概念:</p>\n<ol>\n<li>科里化: 一个函数原本有多个参数, 之传入<strong>一个</strong>参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.</li>\n<li>偏函数: 一个函数原本有多个参数, 之传入<strong>一部分</strong>参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.</li>\n<li>高阶函数: 一个函数<strong>参数是一个函数</strong>, 该函数对参数这个函数进行加工, 得到一个函数, 这个加工用的函数就是高阶函数.<br>为什么要使用科里化? 为了提升性能. 使用科里化可以缓存一部分能力.<br>使用两个案例来说明:</li>\n<li>判断元素</li>\n<li>虚拟 DOM 的 render 方法</li>\n<li>判断元素:</li>\n</ol>\n<p>Vue 本质上是使用 HTML 的字符串作为模板的, 将字符串的 模板 转换为 AST, 再转换为 VNode.</p>\n<ul>\n<li>模板 -&gt; AST</li>\n<li>AST -&gt; VNode</li>\n<li>VNode -&gt; DOM</li>\n</ul>\n<p>最消耗性能是字符串解析 ( 模板 -&gt; AST )</p>\n<p>在 Vue 中每一个标签可以是真正的 HTML 标签, 也可以是自定义组件, 问怎么区分???<br>在 Vue 源码中其实将所有可以用的 HTML 标签已经存起来了.<br>假设这里是考虑几个标签:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tags = <span class=\"string\">&#x27;div,p,a,img,ul,li&#x27;</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>需要一个函数, 判断一个标签名是否为 内置的 标签</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isHTMLTag</span>(<span class=\"params\"> tagName </span>) &#123;</span><br><span class=\"line\">  tagName = tagName.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( tags.<span class=\"title function_\">indexOf</span>( tagName ) &gt; -<span class=\"number\">1</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>虚拟 DOM 的 render 方法</li>\n</ol>\n<p>思考: vue 项目 <em>模板 转换为 抽象语法树</em> 需要执行几次??? </p>\n<ul>\n<li>页面一开始加载需要渲染</li>\n<li>每一个属性 ( 响应式 ) 数据在发生变化的时候 要渲染</li>\n<li>watch, computed 等等</li>\n</ul>\n<p>以前写的代码 每次需要渲染的时候, 模板就会被解析一次 ( 注意, 这里我们简化了解析方法 )</p>\n<p>render 的作用是将 虚拟 DOM 转换为 真正的 DOM 加到页面中</p>\n<ul>\n<li>虚拟 DOM 可以降级理解为 AST</li>\n<li>一个项目运行的时候 模板是不会变 的, 就表示 AST 是不会变的</li>\n</ul>\n<p>我们可以将代码进行优化, 将 虚拟 DOM 缓存起来, 生成一个函数, 函数只需要传入数据 就可以得到 真正的 DOM</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JGVue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">createRenderFn</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> ast = <span class=\"title function_\">getVNode</span>( <span class=\"variable language_\">this</span>.<span class=\"property\">_template</span> );</span><br><span class=\"line\">      <span class=\"comment\">// Vue: 将 AST + data =&gt; VNode</span></span><br><span class=\"line\">      <span class=\"comment\">// 我们: 带有坑的 VNode + data =&gt; 含有数据的 VNode</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">render</span> () &#123;<span class=\"comment\">//返回一个方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 将 带有 坑的 VNode 转换为 待数据的 VNode</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> _tmp = <span class=\"title function_\">combine</span>( ast, <span class=\"variable language_\">this</span>.<span class=\"property\">_data</span> );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在真正的 Vue 中使用了 二次提交的 设计结构</p>\n<ol>\n<li>在 页面中 的 DOM 和 虚拟 DOM 是一一对应的关系</li>\n<li>先 有 AST 和 数据 生成 VNode ( 新, render )</li>\n<li>将 就的 VNode 和 新的 VNode 比较 ( diff ), 更新 ( update )</li>\n</ol>\n<p>参考资料:</p>\n<ul>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\">函数式编程</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\">维基百科</a></li>\n</ul>\n<p>来源: 腾讯课堂蒋坤公开课</p>\n"},{"title":"vue源码分析-手写模拟简单源码(4)","date":"2020-02-24T11:36:18.000Z","description":"Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.","cover":"https://i.loli.net/2021/09/15/iqmJedx4ahWXZSb.jpg","_content":"\n### 响应式原理\n\n- 我们在使用 Vue 时候, 赋值属性获得属性都是直接使用的 Vue 实例\n- 我们在设计属性值的时候, 页面的数据更新\n\n```js\nObject.defineProperty( 对象, '设置什么属性名', {\n  writeable\n  configurable\n  enumerable:  控制属性是否可枚举, 是不是可以被 for-in 取出来\n  set() {}  赋值触发\n  get() {}  取值触发\n} )\n```\n\n```js\n// 简化后的版本\nfunction defineReactive( target, key, value, enumerable ) {\n  // 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )\n  Object.defineProperty( target, key, {\n    configurable: true,\n    enumerable: !!enumerable,\n\n    get () {\n      console.log( `读取 o 的 ${key} 属性` ); // 额外\n      return value;\n    },\n    set ( newVal ) {\n      console.log( `设置 o 的 ${key} 属性为: ${newVal}` ); // 额外\n      value = newVal;\n    }\n  } )\n}\n```\n\n实际开发中对象一般是有多级\n\n```js\nlet o = {\n  list: [\n    {  }\n  ],\n  ads: [\n    { }\n  ],\n  user: {\n\n  }\n}\n```\n对于对象可以使用 递归来响应式化, 但是数组我们也需要处理\n\n- push\n- pop\n- shift\n- unshift\n- reverse\n- sort\n- splice\n\n要做什么事情呢?\n\n1. 在改变数组的数据的时候, 要发出通知\n   - Vue 2 中的缺陷, 数组发生变化, 设置 length 没法通知 ( Vue 3 中使用 Proxy 语法 ES6 的语法解决了这个问题 )\n2. 加入的元素应该变成响应式的\n\n技巧: 如果一个函数已经定义了, 但是我们需要扩展其功能, 我们一般的处理办法:\n\n1. 使用一个临时的函数名存储函数\n2. 重新定义原来的函数\n3. 定义扩展的功能\n4. 调用临时的那个函数\n\n例子:\n\n```js\n function func() {\n      console.log( '原始的功能' );\n    }\n    // 1\n    let _tmpFn = func;\n    // 2\n    func = function () {\n      // 4\n      _tmpFn();\n      // 3\n      console.log( '新的扩展的功能' );\n    };\n    func(); // 1. 打印出 原始的功能\n            // 2. 打印出 新的扩展功能\n```\n\n扩展数组的 push 和 pop 怎么处理呢???\n\n- 直接修改 prototype **不行**\n- 修改要进行响应式化的数组的原型 ( __proto__ )\n\n```\n// 继承关系: arr -> Array.prototype -> Object.prototype -> ...\n// 继承关系: arr -> 改写的方法 -> Array.prototype -> Object.prototype -> ...\n```\n代码:\n\n```js\n // 响应式化的部分\n    let ARRAY_METHOD = ['push','pop','shift','unshift','reverse','sort','splice'];\n    let array_methods = Object.create( Array.prototype );\n    ARRAY_METHOD.forEach( method => {\n      array_methods[ method ] = function () {\n        // 调用原来的方法\n        console.log( '调用的是拦截的 ' + method + ' 方法' );\n        // 将数据进行响应式化\n        for( let i = 0; i < arguments.length; i++ ) {\n          reactify( arguments[ i ] );\n        } \n        let res = Array.prototype[ method ].apply( this, arguments );\n        // Array.prototype[ method ].call( this, ...arguments ); // 类比\n        return res;\n      }\n    } );\n\n    // 简化后的版本 \n    function defineReactive( target, key, value, enumerable ) {\n      // 折中处理后, this 就是 Vue 实例\n      let that = this;\n      // 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )\n      if ( typeof value === 'object' && value != null && !Array.isArray( value ) ) {\n        // 是非数组的引用类型\n        reactify( value ); // 递归\n      }\n\n      Object.defineProperty( target, key, {\n        configurable: true,\n        enumerable: !!enumerable,\n        get () {\n          console.log( `读取 ${key} 属性` ); // 额外\n          return value;\n        },\n        set ( newVal ) {\n          console.log( `设置 ${key} 属性为: ${newVal}` ); // 额外\n\n          value = newVal;\n\n          // 模板刷新 ( 这现在是假的, 只是演示 )\n          // vue 实例??? watcher 就不会有这个问题\n          that.mountComponent(); // 修改数据的时候, 模板要刷新\n\n        }\n      } );\n    }\n    // 将对象 o 响应式化\n    function reactify( o, vm ) {\n      let keys = Object.keys( o );\n\n      for ( let i = 0; i < keys.length; i++ ) {\n        let key = keys[ i ]; // 属性名\n        let value = o[ key ];\n        if ( Array.isArray( value ) ) {\n          // 数组\n          value.__proto__ = array_methods; // 数组就响应式了\n          for ( let j = 0; j < value.length; j++ ) {\n            reactify( value[ j ], vm ); // 递归\n          }\n        } else {\n          // 对象或值类型\n          defineReactive.call( vm, o, key, value, true );\n        }\n      }\n    }\n```\n来源: 腾讯课堂蒋坤公开课\n\n\n","source":"_posts/4-Vue.md","raw":"---\ntitle: vue源码分析-手写模拟简单源码(4)\ndate: 2020-02-24 19:36:18\ncategories: vue\ntags: [vue]\ndescription: Vue 利用 我们提供的数据 和 页面中 模板 生成了 一个新的 HTML 标签 ( node 元素 ),替换到了 页面中 放置模板的位置.\ncover: https://i.loli.net/2021/09/15/iqmJedx4ahWXZSb.jpg\n---\n\n### 响应式原理\n\n- 我们在使用 Vue 时候, 赋值属性获得属性都是直接使用的 Vue 实例\n- 我们在设计属性值的时候, 页面的数据更新\n\n```js\nObject.defineProperty( 对象, '设置什么属性名', {\n  writeable\n  configurable\n  enumerable:  控制属性是否可枚举, 是不是可以被 for-in 取出来\n  set() {}  赋值触发\n  get() {}  取值触发\n} )\n```\n\n```js\n// 简化后的版本\nfunction defineReactive( target, key, value, enumerable ) {\n  // 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )\n  Object.defineProperty( target, key, {\n    configurable: true,\n    enumerable: !!enumerable,\n\n    get () {\n      console.log( `读取 o 的 ${key} 属性` ); // 额外\n      return value;\n    },\n    set ( newVal ) {\n      console.log( `设置 o 的 ${key} 属性为: ${newVal}` ); // 额外\n      value = newVal;\n    }\n  } )\n}\n```\n\n实际开发中对象一般是有多级\n\n```js\nlet o = {\n  list: [\n    {  }\n  ],\n  ads: [\n    { }\n  ],\n  user: {\n\n  }\n}\n```\n对于对象可以使用 递归来响应式化, 但是数组我们也需要处理\n\n- push\n- pop\n- shift\n- unshift\n- reverse\n- sort\n- splice\n\n要做什么事情呢?\n\n1. 在改变数组的数据的时候, 要发出通知\n   - Vue 2 中的缺陷, 数组发生变化, 设置 length 没法通知 ( Vue 3 中使用 Proxy 语法 ES6 的语法解决了这个问题 )\n2. 加入的元素应该变成响应式的\n\n技巧: 如果一个函数已经定义了, 但是我们需要扩展其功能, 我们一般的处理办法:\n\n1. 使用一个临时的函数名存储函数\n2. 重新定义原来的函数\n3. 定义扩展的功能\n4. 调用临时的那个函数\n\n例子:\n\n```js\n function func() {\n      console.log( '原始的功能' );\n    }\n    // 1\n    let _tmpFn = func;\n    // 2\n    func = function () {\n      // 4\n      _tmpFn();\n      // 3\n      console.log( '新的扩展的功能' );\n    };\n    func(); // 1. 打印出 原始的功能\n            // 2. 打印出 新的扩展功能\n```\n\n扩展数组的 push 和 pop 怎么处理呢???\n\n- 直接修改 prototype **不行**\n- 修改要进行响应式化的数组的原型 ( __proto__ )\n\n```\n// 继承关系: arr -> Array.prototype -> Object.prototype -> ...\n// 继承关系: arr -> 改写的方法 -> Array.prototype -> Object.prototype -> ...\n```\n代码:\n\n```js\n // 响应式化的部分\n    let ARRAY_METHOD = ['push','pop','shift','unshift','reverse','sort','splice'];\n    let array_methods = Object.create( Array.prototype );\n    ARRAY_METHOD.forEach( method => {\n      array_methods[ method ] = function () {\n        // 调用原来的方法\n        console.log( '调用的是拦截的 ' + method + ' 方法' );\n        // 将数据进行响应式化\n        for( let i = 0; i < arguments.length; i++ ) {\n          reactify( arguments[ i ] );\n        } \n        let res = Array.prototype[ method ].apply( this, arguments );\n        // Array.prototype[ method ].call( this, ...arguments ); // 类比\n        return res;\n      }\n    } );\n\n    // 简化后的版本 \n    function defineReactive( target, key, value, enumerable ) {\n      // 折中处理后, this 就是 Vue 实例\n      let that = this;\n      // 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )\n      if ( typeof value === 'object' && value != null && !Array.isArray( value ) ) {\n        // 是非数组的引用类型\n        reactify( value ); // 递归\n      }\n\n      Object.defineProperty( target, key, {\n        configurable: true,\n        enumerable: !!enumerable,\n        get () {\n          console.log( `读取 ${key} 属性` ); // 额外\n          return value;\n        },\n        set ( newVal ) {\n          console.log( `设置 ${key} 属性为: ${newVal}` ); // 额外\n\n          value = newVal;\n\n          // 模板刷新 ( 这现在是假的, 只是演示 )\n          // vue 实例??? watcher 就不会有这个问题\n          that.mountComponent(); // 修改数据的时候, 模板要刷新\n\n        }\n      } );\n    }\n    // 将对象 o 响应式化\n    function reactify( o, vm ) {\n      let keys = Object.keys( o );\n\n      for ( let i = 0; i < keys.length; i++ ) {\n        let key = keys[ i ]; // 属性名\n        let value = o[ key ];\n        if ( Array.isArray( value ) ) {\n          // 数组\n          value.__proto__ = array_methods; // 数组就响应式了\n          for ( let j = 0; j < value.length; j++ ) {\n            reactify( value[ j ], vm ); // 递归\n          }\n        } else {\n          // 对象或值类型\n          defineReactive.call( vm, o, key, value, true );\n        }\n      }\n    }\n```\n来源: 腾讯课堂蒋坤公开课\n\n\n","slug":"4-Vue","published":1,"updated":"2021-09-15T08:36:55.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lf000fdswkgd79222q","content":"<h3 id=\"响应式原理\"><a href=\"#响应式原理\" class=\"headerlink\" title=\"响应式原理\"></a>响应式原理</h3><ul>\n<li>我们在使用 Vue 时候, 赋值属性获得属性都是直接使用的 Vue 实例</li>\n<li>我们在设计属性值的时候, 页面的数据更新</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( 对象, <span class=\"string\">&#x27;设置什么属性名&#x27;</span>, &#123;</span><br><span class=\"line\">  writeable</span><br><span class=\"line\">  configurable</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>:  控制属性是否可枚举, 是不是可以被 <span class=\"keyword\">for</span>-<span class=\"keyword\">in</span> 取出来</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\"></span>) &#123;&#125;  赋值触发</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;&#125;  取值触发</span><br><span class=\"line\">&#125; )</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化后的版本</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">defineReactive</span>(<span class=\"params\"> target, key, value, enumerable </span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( target, key, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: !!enumerable,</span><br><span class=\"line\"></span><br><span class=\"line\">    get () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`读取 o 的 <span class=\"subst\">$&#123;key&#125;</span> 属性`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set ( newVal ) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`设置 o 的 <span class=\"subst\">$&#123;key&#125;</span> 属性为: <span class=\"subst\">$&#123;newVal&#125;</span>`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\">      value = newVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际开发中对象一般是有多级</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">  <span class=\"attr\">list</span>: [</span><br><span class=\"line\">    &#123;  &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">ads</span>: [</span><br><span class=\"line\">    &#123; &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于对象可以使用 递归来响应式化, 但是数组我们也需要处理</p>\n<ul>\n<li>push</li>\n<li>pop</li>\n<li>shift</li>\n<li>unshift</li>\n<li>reverse</li>\n<li>sort</li>\n<li>splice</li>\n</ul>\n<p>要做什么事情呢?</p>\n<ol>\n<li>在改变数组的数据的时候, 要发出通知<ul>\n<li>Vue 2 中的缺陷, 数组发生变化, 设置 length 没法通知 ( Vue 3 中使用 Proxy 语法 ES6 的语法解决了这个问题 )</li>\n</ul>\n</li>\n<li>加入的元素应该变成响应式的</li>\n</ol>\n<p>技巧: 如果一个函数已经定义了, 但是我们需要扩展其功能, 我们一般的处理办法:</p>\n<ol>\n<li>使用一个临时的函数名存储函数</li>\n<li>重新定义原来的函数</li>\n<li>定义扩展的功能</li>\n<li>调用临时的那个函数</li>\n</ol>\n<p>例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;原始的功能&#x27;</span> );</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 1</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> _tmpFn = func;</span><br><span class=\"line\">   <span class=\"comment\">// 2</span></span><br><span class=\"line\">   func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 4</span></span><br><span class=\"line\">     <span class=\"title function_\">_tmpFn</span>();</span><br><span class=\"line\">     <span class=\"comment\">// 3</span></span><br><span class=\"line\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;新的扩展的功能&#x27;</span> );</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   <span class=\"title function_\">func</span>(); <span class=\"comment\">// 1. 打印出 原始的功能</span></span><br><span class=\"line\">           <span class=\"comment\">// 2. 打印出 新的扩展功能</span></span><br></pre></td></tr></table></figure>\n\n<p>扩展数组的 push 和 pop 怎么处理呢???</p>\n<ul>\n<li>直接修改 prototype <strong>不行</strong></li>\n<li>修改要进行响应式化的数组的原型 ( <strong>proto</strong> )</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 继承关系: arr -&gt; Array.prototype -&gt; Object.prototype -&gt; ...</span><br><span class=\"line\">// 继承关系: arr -&gt; 改写的方法 -&gt; Array.prototype -&gt; Object.prototype -&gt; ...</span><br></pre></td></tr></table></figure>\n<p>代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 响应式化的部分</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable constant_\">ARRAY_METHOD</span> = [<span class=\"string\">&#x27;push&#x27;</span>,<span class=\"string\">&#x27;pop&#x27;</span>,<span class=\"string\">&#x27;shift&#x27;</span>,<span class=\"string\">&#x27;unshift&#x27;</span>,<span class=\"string\">&#x27;reverse&#x27;</span>,<span class=\"string\">&#x27;sort&#x27;</span>,<span class=\"string\">&#x27;splice&#x27;</span>];</span><br><span class=\"line\">   <span class=\"keyword\">let</span> array_methods = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> );</span><br><span class=\"line\">   <span class=\"variable constant_\">ARRAY_METHOD</span>.<span class=\"title function_\">forEach</span>( <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> &#123;</span><br><span class=\"line\">     array_methods[ method ] = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 调用原来的方法</span></span><br><span class=\"line\">       <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;调用的是拦截的 &#x27;</span> + method + <span class=\"string\">&#x27; 方法&#x27;</span> );</span><br><span class=\"line\">       <span class=\"comment\">// 将数据进行响应式化</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">         <span class=\"title function_\">reactify</span>( <span class=\"variable language_\">arguments</span>[ i ] );</span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       <span class=\"keyword\">let</span> res = <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>[ method ].<span class=\"title function_\">apply</span>( <span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span> );</span><br><span class=\"line\">       <span class=\"comment\">// Array.prototype[ method ].call( this, ...arguments ); // 类比</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 简化后的版本 </span></span><br><span class=\"line\">   <span class=\"keyword\">function</span> <span class=\"title function_\">defineReactive</span>(<span class=\"params\"> target, key, value, enumerable </span>) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 折中处理后, this 就是 Vue 实例</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> that = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value != <span class=\"literal\">null</span> &amp;&amp; !<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>( value ) ) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 是非数组的引用类型</span></span><br><span class=\"line\">       <span class=\"title function_\">reactify</span>( value ); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( target, key, &#123;</span><br><span class=\"line\">       <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">       <span class=\"attr\">enumerable</span>: !!enumerable,</span><br><span class=\"line\">       get () &#123;</span><br><span class=\"line\">         <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`读取 <span class=\"subst\">$&#123;key&#125;</span> 属性`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       set ( newVal ) &#123;</span><br><span class=\"line\">         <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`设置 <span class=\"subst\">$&#123;key&#125;</span> 属性为: <span class=\"subst\">$&#123;newVal&#125;</span>`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\"></span><br><span class=\"line\">         value = newVal;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 模板刷新 ( 这现在是假的, 只是演示 )</span></span><br><span class=\"line\">         <span class=\"comment\">// vue 实例??? watcher 就不会有这个问题</span></span><br><span class=\"line\">         that.<span class=\"title function_\">mountComponent</span>(); <span class=\"comment\">// 修改数据的时候, 模板要刷新</span></span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125; );</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 将对象 o 响应式化</span></span><br><span class=\"line\">   <span class=\"keyword\">function</span> <span class=\"title function_\">reactify</span>(<span class=\"params\"> o, vm </span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>( o );</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> key = keys[ i ]; <span class=\"comment\">// 属性名</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> value = o[ key ];</span><br><span class=\"line\">       <span class=\"keyword\">if</span> ( <span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>( value ) ) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 数组</span></span><br><span class=\"line\">         value.<span class=\"property\">__proto__</span> = array_methods; <span class=\"comment\">// 数组就响应式了</span></span><br><span class=\"line\">         <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; value.<span class=\"property\">length</span>; j++ ) &#123;</span><br><span class=\"line\">           <span class=\"title function_\">reactify</span>( value[ j ], vm ); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 对象或值类型</span></span><br><span class=\"line\">         defineReactive.<span class=\"title function_\">call</span>( vm, o, key, value, <span class=\"literal\">true</span> );</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>来源: 腾讯课堂蒋坤公开课</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"响应式原理\"><a href=\"#响应式原理\" class=\"headerlink\" title=\"响应式原理\"></a>响应式原理</h3><ul>\n<li>我们在使用 Vue 时候, 赋值属性获得属性都是直接使用的 Vue 实例</li>\n<li>我们在设计属性值的时候, 页面的数据更新</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( 对象, <span class=\"string\">&#x27;设置什么属性名&#x27;</span>, &#123;</span><br><span class=\"line\">  writeable</span><br><span class=\"line\">  configurable</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>:  控制属性是否可枚举, 是不是可以被 <span class=\"keyword\">for</span>-<span class=\"keyword\">in</span> 取出来</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\"></span>) &#123;&#125;  赋值触发</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;&#125;  取值触发</span><br><span class=\"line\">&#125; )</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化后的版本</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">defineReactive</span>(<span class=\"params\"> target, key, value, enumerable </span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( target, key, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: !!enumerable,</span><br><span class=\"line\"></span><br><span class=\"line\">    get () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`读取 o 的 <span class=\"subst\">$&#123;key&#125;</span> 属性`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set ( newVal ) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`设置 o 的 <span class=\"subst\">$&#123;key&#125;</span> 属性为: <span class=\"subst\">$&#123;newVal&#125;</span>`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\">      value = newVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际开发中对象一般是有多级</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">  <span class=\"attr\">list</span>: [</span><br><span class=\"line\">    &#123;  &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">ads</span>: [</span><br><span class=\"line\">    &#123; &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于对象可以使用 递归来响应式化, 但是数组我们也需要处理</p>\n<ul>\n<li>push</li>\n<li>pop</li>\n<li>shift</li>\n<li>unshift</li>\n<li>reverse</li>\n<li>sort</li>\n<li>splice</li>\n</ul>\n<p>要做什么事情呢?</p>\n<ol>\n<li>在改变数组的数据的时候, 要发出通知<ul>\n<li>Vue 2 中的缺陷, 数组发生变化, 设置 length 没法通知 ( Vue 3 中使用 Proxy 语法 ES6 的语法解决了这个问题 )</li>\n</ul>\n</li>\n<li>加入的元素应该变成响应式的</li>\n</ol>\n<p>技巧: 如果一个函数已经定义了, 但是我们需要扩展其功能, 我们一般的处理办法:</p>\n<ol>\n<li>使用一个临时的函数名存储函数</li>\n<li>重新定义原来的函数</li>\n<li>定义扩展的功能</li>\n<li>调用临时的那个函数</li>\n</ol>\n<p>例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;原始的功能&#x27;</span> );</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 1</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> _tmpFn = func;</span><br><span class=\"line\">   <span class=\"comment\">// 2</span></span><br><span class=\"line\">   func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 4</span></span><br><span class=\"line\">     <span class=\"title function_\">_tmpFn</span>();</span><br><span class=\"line\">     <span class=\"comment\">// 3</span></span><br><span class=\"line\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;新的扩展的功能&#x27;</span> );</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   <span class=\"title function_\">func</span>(); <span class=\"comment\">// 1. 打印出 原始的功能</span></span><br><span class=\"line\">           <span class=\"comment\">// 2. 打印出 新的扩展功能</span></span><br></pre></td></tr></table></figure>\n\n<p>扩展数组的 push 和 pop 怎么处理呢???</p>\n<ul>\n<li>直接修改 prototype <strong>不行</strong></li>\n<li>修改要进行响应式化的数组的原型 ( <strong>proto</strong> )</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 继承关系: arr -&gt; Array.prototype -&gt; Object.prototype -&gt; ...</span><br><span class=\"line\">// 继承关系: arr -&gt; 改写的方法 -&gt; Array.prototype -&gt; Object.prototype -&gt; ...</span><br></pre></td></tr></table></figure>\n<p>代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 响应式化的部分</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable constant_\">ARRAY_METHOD</span> = [<span class=\"string\">&#x27;push&#x27;</span>,<span class=\"string\">&#x27;pop&#x27;</span>,<span class=\"string\">&#x27;shift&#x27;</span>,<span class=\"string\">&#x27;unshift&#x27;</span>,<span class=\"string\">&#x27;reverse&#x27;</span>,<span class=\"string\">&#x27;sort&#x27;</span>,<span class=\"string\">&#x27;splice&#x27;</span>];</span><br><span class=\"line\">   <span class=\"keyword\">let</span> array_methods = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>( <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> );</span><br><span class=\"line\">   <span class=\"variable constant_\">ARRAY_METHOD</span>.<span class=\"title function_\">forEach</span>( <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> &#123;</span><br><span class=\"line\">     array_methods[ method ] = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 调用原来的方法</span></span><br><span class=\"line\">       <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;调用的是拦截的 &#x27;</span> + method + <span class=\"string\">&#x27; 方法&#x27;</span> );</span><br><span class=\"line\">       <span class=\"comment\">// 将数据进行响应式化</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">         <span class=\"title function_\">reactify</span>( <span class=\"variable language_\">arguments</span>[ i ] );</span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       <span class=\"keyword\">let</span> res = <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>[ method ].<span class=\"title function_\">apply</span>( <span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span> );</span><br><span class=\"line\">       <span class=\"comment\">// Array.prototype[ method ].call( this, ...arguments ); // 类比</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 简化后的版本 </span></span><br><span class=\"line\">   <span class=\"keyword\">function</span> <span class=\"title function_\">defineReactive</span>(<span class=\"params\"> target, key, value, enumerable </span>) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 折中处理后, this 就是 Vue 实例</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> that = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">     <span class=\"comment\">// 函数内部就是一个局部作用域, 这个 value 就只在函数内使用的变量 ( 闭包 )</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value != <span class=\"literal\">null</span> &amp;&amp; !<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>( value ) ) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 是非数组的引用类型</span></span><br><span class=\"line\">       <span class=\"title function_\">reactify</span>( value ); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( target, key, &#123;</span><br><span class=\"line\">       <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">       <span class=\"attr\">enumerable</span>: !!enumerable,</span><br><span class=\"line\">       get () &#123;</span><br><span class=\"line\">         <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`读取 <span class=\"subst\">$&#123;key&#125;</span> 属性`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       set ( newVal ) &#123;</span><br><span class=\"line\">         <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">`设置 <span class=\"subst\">$&#123;key&#125;</span> 属性为: <span class=\"subst\">$&#123;newVal&#125;</span>`</span> ); <span class=\"comment\">// 额外</span></span><br><span class=\"line\"></span><br><span class=\"line\">         value = newVal;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 模板刷新 ( 这现在是假的, 只是演示 )</span></span><br><span class=\"line\">         <span class=\"comment\">// vue 实例??? watcher 就不会有这个问题</span></span><br><span class=\"line\">         that.<span class=\"title function_\">mountComponent</span>(); <span class=\"comment\">// 修改数据的时候, 模板要刷新</span></span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125; );</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 将对象 o 响应式化</span></span><br><span class=\"line\">   <span class=\"keyword\">function</span> <span class=\"title function_\">reactify</span>(<span class=\"params\"> o, vm </span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>( o );</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.<span class=\"property\">length</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> key = keys[ i ]; <span class=\"comment\">// 属性名</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> value = o[ key ];</span><br><span class=\"line\">       <span class=\"keyword\">if</span> ( <span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>( value ) ) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 数组</span></span><br><span class=\"line\">         value.<span class=\"property\">__proto__</span> = array_methods; <span class=\"comment\">// 数组就响应式了</span></span><br><span class=\"line\">         <span class=\"keyword\">for</span> ( <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; value.<span class=\"property\">length</span>; j++ ) &#123;</span><br><span class=\"line\">           <span class=\"title function_\">reactify</span>( value[ j ], vm ); <span class=\"comment\">// 递归</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 对象或值类型</span></span><br><span class=\"line\">         defineReactive.<span class=\"title function_\">call</span>( vm, o, key, value, <span class=\"literal\">true</span> );</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>来源: 腾讯课堂蒋坤公开课</p>\n"},{"title":"165. 比较版本号","date":"2021-12-22T07:01:27.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg","_content":"# 165. 比较版本号\n给你两个版本号 version1 和 version2 ，请你比较它们。\n\n版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。\n\n比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。\n\n返回规则如下：\n\n如果 version1 > version2 返回 1，\n如果 version1 < version2 返回 -1，\n除此之外返回 0。\n\n示例 1：\n> 输入：version1 = \"1.01\", version2 = \"1.001\"\n> \n> 输出：0\n> \n> 解释：忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\"\n```js\nvar compareVersion = function(version1, version2) {\n    //拆分为数组\n    let v1 = version1.split('.')\n    let v2 = version2.split('.')\n    v1 = v1.map((item)=>Number.parseInt(item))\n    v2 = v2.map((item)=>Number.parseInt(item))\n    //补0成一样长度\n    let len = Math.max(v1.length,v2.length)\n    while(v1.length < len) v1.push(0)\n    while(v2.length < len) v2.push(0)\n    //逐个比较\n    for(let i = 0; i < len; i++){\n        if(v1[i] > v2[i]) return 1\n        else if(v1[i] < v2[i]) return -1\n    }\n    return 0\n};\n```\n","source":"_posts/Algorithm-165.md","raw":"---\ntitle: 165. 比较版本号\ndate: 2021-12-22 15:01:27\ncategories: 算法\ntags: [算法]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg\n---\n# 165. 比较版本号\n给你两个版本号 version1 和 version2 ，请你比较它们。\n\n版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。\n\n比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。\n\n返回规则如下：\n\n如果 version1 > version2 返回 1，\n如果 version1 < version2 返回 -1，\n除此之外返回 0。\n\n示例 1：\n> 输入：version1 = \"1.01\", version2 = \"1.001\"\n> \n> 输出：0\n> \n> 解释：忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\"\n```js\nvar compareVersion = function(version1, version2) {\n    //拆分为数组\n    let v1 = version1.split('.')\n    let v2 = version2.split('.')\n    v1 = v1.map((item)=>Number.parseInt(item))\n    v2 = v2.map((item)=>Number.parseInt(item))\n    //补0成一样长度\n    let len = Math.max(v1.length,v2.length)\n    while(v1.length < len) v1.push(0)\n    while(v2.length < len) v2.push(0)\n    //逐个比较\n    for(let i = 0; i < len; i++){\n        if(v1[i] > v2[i]) return 1\n        else if(v1[i] < v2[i]) return -1\n    }\n    return 0\n};\n```\n","slug":"Algorithm-165","published":1,"updated":"2022-02-18T03:39:37.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lf000hdswkh7fmcoi6","content":"<h1 id=\"165-比较版本号\"><a href=\"#165-比较版本号\" class=\"headerlink\" title=\"165. 比较版本号\"></a>165. 比较版本号</h1><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p>\n<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>\n<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>\n<p>返回规则如下：</p>\n<p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p>\n<p>示例 1：</p>\n<blockquote>\n<p>输入：version1 = “1.01”, version2 = “1.001”</p>\n<p>输出：0</p>\n<p>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> compareVersion = <span class=\"keyword\">function</span>(<span class=\"params\">version1, version2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//拆分为数组</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> v1 = version1.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v2 = version2.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">    v1 = v1.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(item))</span><br><span class=\"line\">    v2 = v2.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(item))</span><br><span class=\"line\">    <span class=\"comment\">//补0成一样长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(v1.<span class=\"property\">length</span>,v2.<span class=\"property\">length</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(v1.<span class=\"property\">length</span> &lt; len) v1.<span class=\"title function_\">push</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(v2.<span class=\"property\">length</span> &lt; len) v2.<span class=\"title function_\">push</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//逐个比较</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v1[i] &gt; v2[i]) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(v1[i] &lt; v2[i]) <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"165-比较版本号\"><a href=\"#165-比较版本号\" class=\"headerlink\" title=\"165. 比较版本号\"></a>165. 比较版本号</h1><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p>\n<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>\n<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>\n<p>返回规则如下：</p>\n<p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p>\n<p>示例 1：</p>\n<blockquote>\n<p>输入：version1 = “1.01”, version2 = “1.001”</p>\n<p>输出：0</p>\n<p>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> compareVersion = <span class=\"keyword\">function</span>(<span class=\"params\">version1, version2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//拆分为数组</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> v1 = version1.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v2 = version2.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">    v1 = v1.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(item))</span><br><span class=\"line\">    v2 = v2.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(item))</span><br><span class=\"line\">    <span class=\"comment\">//补0成一样长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(v1.<span class=\"property\">length</span>,v2.<span class=\"property\">length</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(v1.<span class=\"property\">length</span> &lt; len) v1.<span class=\"title function_\">push</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(v2.<span class=\"property\">length</span> &lt; len) v2.<span class=\"title function_\">push</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//逐个比较</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v1[i] &gt; v2[i]) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(v1[i] &lt; v2[i]) <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"300. 最长递增子序列","date":"2022-04-05T06:18:27.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg","_content":"# 5. 最长回文子串\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n\n\n\n> 示例 1：\n> \n> 输入：nums = [10,9,2,5,3,7,101,18]\n> \n> 输出：4\n> \n> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 \n> \n> 示例 2：\n> \n> nums = [0,1,0,3,2,3]\n> \n> 输出：4\n\n```js\nvar lengthOfLIS = function(nums) {\n    const dp = new Array(nums.length).fill(1);//初始化dp 赋值 1\n    let res = 1;//最大递增序列数\n    for(let i=1;i<nums.length;i++){\n        for(let j=0;j<i;j++){\n            if(nums[i] > nums[j]){//如果当前nums[i]>nums[0<j<i] 那么dp[i]=Math.max(dp[i]，dp[0<j<i]+1)\n                dp[i] = Math.max(dp[i],dp[j]+1);\n            }\n        }\n        res = Math.max(dp[i],res);\n    }\n    return res;\n};\n```\n","source":"_posts/Algorithm-300.md","raw":"---\ntitle: 300. 最长递增子序列\ndate: 2022-04-05 14:18:27\ncategories: 算法\ntags: [算法]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg\n---\n# 5. 最长回文子串\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n\n\n\n> 示例 1：\n> \n> 输入：nums = [10,9,2,5,3,7,101,18]\n> \n> 输出：4\n> \n> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 \n> \n> 示例 2：\n> \n> nums = [0,1,0,3,2,3]\n> \n> 输出：4\n\n```js\nvar lengthOfLIS = function(nums) {\n    const dp = new Array(nums.length).fill(1);//初始化dp 赋值 1\n    let res = 1;//最大递增序列数\n    for(let i=1;i<nums.length;i++){\n        for(let j=0;j<i;j++){\n            if(nums[i] > nums[j]){//如果当前nums[i]>nums[0<j<i] 那么dp[i]=Math.max(dp[i]，dp[0<j<i]+1)\n                dp[i] = Math.max(dp[i],dp[j]+1);\n            }\n        }\n        res = Math.max(dp[i],res);\n    }\n    return res;\n};\n```\n","slug":"Algorithm-300","published":1,"updated":"2022-04-15T04:28:18.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lh000mdswk5zwb9j8l","content":"<h1 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a>5. 最长回文子串</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>\n<blockquote>\n<p>示例 1：</p>\n<p>输入：nums = [10,9,2,5,3,7,101,18]</p>\n<p>输出：4</p>\n<p>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 </p>\n<p>示例 2：</p>\n<p>nums = [0,1,0,3,2,3]</p>\n<p>输出：4</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLIS = <span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dp = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(nums.<span class=\"property\">length</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);<span class=\"comment\">//初始化dp 赋值 1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>;<span class=\"comment\">//最大递增序列数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>;i&lt;nums.<span class=\"property\">length</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &gt; nums[j])&#123;<span class=\"comment\">//如果当前nums[i]&gt;nums[0&lt;j&lt;i] 那么dp[i]=Math.max(dp[i]，dp[0&lt;j&lt;i]+1)</span></span><br><span class=\"line\">                dp[i] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dp[i],dp[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dp[i],res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a>5. 最长回文子串</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>\n<blockquote>\n<p>示例 1：</p>\n<p>输入：nums = [10,9,2,5,3,7,101,18]</p>\n<p>输出：4</p>\n<p>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 </p>\n<p>示例 2：</p>\n<p>nums = [0,1,0,3,2,3]</p>\n<p>输出：4</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLIS = <span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dp = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(nums.<span class=\"property\">length</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);<span class=\"comment\">//初始化dp 赋值 1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>;<span class=\"comment\">//最大递增序列数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>;i&lt;nums.<span class=\"property\">length</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &gt; nums[j])&#123;<span class=\"comment\">//如果当前nums[i]&gt;nums[0&lt;j&lt;i] 那么dp[i]=Math.max(dp[i]，dp[0&lt;j&lt;i]+1)</span></span><br><span class=\"line\">                dp[i] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dp[i],dp[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dp[i],res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"42. 接雨水","date":"2022-03-17T03:14:27.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg","_content":"# 42. 接雨水\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n> 示例 1：\n> \n> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n> \n> 输出：6\n> \n> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n```js\nvar trap = function(height) {\n    let sum = 0;\n    let left = 0,right = height.length-1;\n    let lMax = 0;rMax = 0;\n    while(left < right){\n        lMax = Math.max(lMax,height[left]);//左边最大值\n        rMax = Math.max(rMax,height[right]);//右边最大值\n        if(height[left] < height[right]){\n            sum += lMax - height[left];\n            left ++;\n        }else{\n            sum += rMax - height[right];\n            right --;\n        }\n    }\n    return sum;\n};\n```\n\n","source":"_posts/Algorithm-42.md","raw":"---\ntitle: 42. 接雨水\ndate: 2022-03-17 11:14:27\ncategories: 算法\ntags: [算法]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg\n---\n# 42. 接雨水\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n> 示例 1：\n> \n> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n> \n> 输出：6\n> \n> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n```js\nvar trap = function(height) {\n    let sum = 0;\n    let left = 0,right = height.length-1;\n    let lMax = 0;rMax = 0;\n    while(left < right){\n        lMax = Math.max(lMax,height[left]);//左边最大值\n        rMax = Math.max(rMax,height[right]);//右边最大值\n        if(height[left] < height[right]){\n            sum += lMax - height[left];\n            left ++;\n        }else{\n            sum += rMax - height[right];\n            right --;\n        }\n    }\n    return sum;\n};\n```\n\n","slug":"Algorithm-42","published":1,"updated":"2022-03-17T03:25:25.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lj000pdswk8cx36cd5","content":"<h1 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" alt=\"\"></p>\n<blockquote>\n<p>示例 1：</p>\n<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</p>\n<p>输出：6</p>\n<p>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> trap = <span class=\"keyword\">function</span>(<span class=\"params\">height</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>,right = height.<span class=\"property\">length</span>-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lMax = <span class=\"number\">0</span>;rMax = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">        lMax = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(lMax,height[left]);<span class=\"comment\">//左边最大值</span></span><br><span class=\"line\">        rMax = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rMax,height[right]);<span class=\"comment\">//右边最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height[left] &lt; height[right])&#123;</span><br><span class=\"line\">            sum += lMax - height[left];</span><br><span class=\"line\">            left ++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sum += rMax - height[right];</span><br><span class=\"line\">            right --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" alt=\"\"></p>\n<blockquote>\n<p>示例 1：</p>\n<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</p>\n<p>输出：6</p>\n<p>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> trap = <span class=\"keyword\">function</span>(<span class=\"params\">height</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>,right = height.<span class=\"property\">length</span>-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lMax = <span class=\"number\">0</span>;rMax = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">        lMax = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(lMax,height[left]);<span class=\"comment\">//左边最大值</span></span><br><span class=\"line\">        rMax = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rMax,height[right]);<span class=\"comment\">//右边最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height[left] &lt; height[right])&#123;</span><br><span class=\"line\">            sum += lMax - height[left];</span><br><span class=\"line\">            left ++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sum += rMax - height[right];</span><br><span class=\"line\">            right --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"5. 最长回文子串","date":"2022-03-15T02:08:27.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg","_content":"# 5. 最长回文子串\n给你一个字符串 s，找到 s 中最长的回文子串。\n\n\n> 示例 1：\n> \n> 输入：s = \"babad\"\n> \n> 输出：\"bab\"\n> \n> 解释：\"aba\" 同样是符合题意的答案。 \n> \n> 示例 2：\n> \n> 输入：s = \"cbbd\"\n> \n> 输出：\"bb\"\n\n```js\nvar longestPalindrome = function(s) {\n    let res = '';\n    const n = s.length;\n    const dp = Array.from(Array(n), () => Array(n).fill(false));\n    for(let i = n - 1;i >= 0;i--){\n        for(let j = i;j < n;j++){\n            dp[i][j] = s[i] === s[j] && (j - i < 2 || dp[i+1][j-1]);\n            if(dp[i][j] && j-i+1 > res.length){\n                res = s.substring(i,j+1);\n            }\n        }\n    }\n    return res;\n};\n```\n\n**解析**\n\n> 1、先创建一个`s`长度的二位数组，并填充为`false`（`dp[i][j]`代表的是i~j是否为回文字符串）\n> \n> 2、从`s`字符串的尾部开始遍历\n> \n> `dp[i][j]`为回文字符串有三种情况（前提`s[i] === s[j]`）\n> \n> * `j - i === 0` 代表一个字符，一个字符肯定是回文字符串\n> \n> * `j - i < 2` 代表两个字符（包括第一种情况）,两个字符且`s[i] === s[j]`那么一定是回文字符串\n> \n> * `j - i > 2` 代表两个字符以上且`s[i] === s[j]`，那么如果`s[i+1] ~ s[j-1]`是回文，也就是`dp[i+1][j-1]`为`true`\n> 比如: `abba`，`i=0,j=3`，`s[i] === s[j]`，`s[i+1] ~ s[j-1]`也就是`bb`，也是一个回文字符串，所以`abba`也是一个回文字符串","source":"_posts/Algorithm-5.md","raw":"---\ntitle: 5. 最长回文子串\ndate: 2022-03-15 10:08:27\ncategories: 算法\ntags: [算法]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/02/18/TBbHCRsA2L59zng.jpg\n---\n# 5. 最长回文子串\n给你一个字符串 s，找到 s 中最长的回文子串。\n\n\n> 示例 1：\n> \n> 输入：s = \"babad\"\n> \n> 输出：\"bab\"\n> \n> 解释：\"aba\" 同样是符合题意的答案。 \n> \n> 示例 2：\n> \n> 输入：s = \"cbbd\"\n> \n> 输出：\"bb\"\n\n```js\nvar longestPalindrome = function(s) {\n    let res = '';\n    const n = s.length;\n    const dp = Array.from(Array(n), () => Array(n).fill(false));\n    for(let i = n - 1;i >= 0;i--){\n        for(let j = i;j < n;j++){\n            dp[i][j] = s[i] === s[j] && (j - i < 2 || dp[i+1][j-1]);\n            if(dp[i][j] && j-i+1 > res.length){\n                res = s.substring(i,j+1);\n            }\n        }\n    }\n    return res;\n};\n```\n\n**解析**\n\n> 1、先创建一个`s`长度的二位数组，并填充为`false`（`dp[i][j]`代表的是i~j是否为回文字符串）\n> \n> 2、从`s`字符串的尾部开始遍历\n> \n> `dp[i][j]`为回文字符串有三种情况（前提`s[i] === s[j]`）\n> \n> * `j - i === 0` 代表一个字符，一个字符肯定是回文字符串\n> \n> * `j - i < 2` 代表两个字符（包括第一种情况）,两个字符且`s[i] === s[j]`那么一定是回文字符串\n> \n> * `j - i > 2` 代表两个字符以上且`s[i] === s[j]`，那么如果`s[i+1] ~ s[j-1]`是回文，也就是`dp[i+1][j-1]`为`true`\n> 比如: `abba`，`i=0,j=3`，`s[i] === s[j]`，`s[i+1] ~ s[j-1]`也就是`bb`，也是一个回文字符串，所以`abba`也是一个回文字符串","slug":"Algorithm-5","published":1,"updated":"2022-03-15T02:26:07.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lk000udswkgzgxau1c","content":"<h1 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a>5. 最长回文子串</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<blockquote>\n<p>示例 1：</p>\n<p>输入：s = “babad”</p>\n<p>输出：”bab”</p>\n<p>解释：”aba” 同样是符合题意的答案。 </p>\n<p>示例 2：</p>\n<p>输入：s = “cbbd”</p>\n<p>输出：”bb”</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"keyword\">function</span>(<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dp = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(n), <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"literal\">false</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i;j &lt; n;j++)&#123;</span><br><span class=\"line\">            dp[i][j] = s[i] === s[j] &amp;&amp; (j - i &lt; <span class=\"number\">2</span> || dp[i+<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i][j] &amp;&amp; j-i+<span class=\"number\">1</span> &gt; res.<span class=\"property\">length</span>)&#123;</span><br><span class=\"line\">                res = s.<span class=\"title function_\">substring</span>(i,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong></p>\n<blockquote>\n<p>1、先创建一个<code>s</code>长度的二位数组，并填充为<code>false</code>（<code>dp[i][j]</code>代表的是i~j是否为回文字符串）</p>\n<p>2、从<code>s</code>字符串的尾部开始遍历</p>\n<p><code>dp[i][j]</code>为回文字符串有三种情况（前提<code>s[i] === s[j]</code>）</p>\n<ul>\n<li><p><code>j - i === 0</code> 代表一个字符，一个字符肯定是回文字符串</p>\n</li>\n<li><p><code>j - i &lt; 2</code> 代表两个字符（包括第一种情况）,两个字符且<code>s[i] === s[j]</code>那么一定是回文字符串</p>\n</li>\n<li><p><code>j - i &gt; 2</code> 代表两个字符以上且<code>s[i] === s[j]</code>，那么如果<code>s[i+1] ~ s[j-1]</code>是回文，也就是<code>dp[i+1][j-1]</code>为<code>true</code><br>比如: <code>abba</code>，<code>i=0,j=3</code>，<code>s[i] === s[j]</code>，<code>s[i+1] ~ s[j-1]</code>也就是<code>bb</code>，也是一个回文字符串，所以<code>abba</code>也是一个回文字符串</p>\n</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a>5. 最长回文子串</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<blockquote>\n<p>示例 1：</p>\n<p>输入：s = “babad”</p>\n<p>输出：”bab”</p>\n<p>解释：”aba” 同样是符合题意的答案。 </p>\n<p>示例 2：</p>\n<p>输入：s = “cbbd”</p>\n<p>输出：”bb”</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"keyword\">function</span>(<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dp = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(n), <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"literal\">false</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i;j &lt; n;j++)&#123;</span><br><span class=\"line\">            dp[i][j] = s[i] === s[j] &amp;&amp; (j - i &lt; <span class=\"number\">2</span> || dp[i+<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i][j] &amp;&amp; j-i+<span class=\"number\">1</span> &gt; res.<span class=\"property\">length</span>)&#123;</span><br><span class=\"line\">                res = s.<span class=\"title function_\">substring</span>(i,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong></p>\n<blockquote>\n<p>1、先创建一个<code>s</code>长度的二位数组，并填充为<code>false</code>（<code>dp[i][j]</code>代表的是i~j是否为回文字符串）</p>\n<p>2、从<code>s</code>字符串的尾部开始遍历</p>\n<p><code>dp[i][j]</code>为回文字符串有三种情况（前提<code>s[i] === s[j]</code>）</p>\n<ul>\n<li><p><code>j - i === 0</code> 代表一个字符，一个字符肯定是回文字符串</p>\n</li>\n<li><p><code>j - i &lt; 2</code> 代表两个字符（包括第一种情况）,两个字符且<code>s[i] === s[j]</code>那么一定是回文字符串</p>\n</li>\n<li><p><code>j - i &gt; 2</code> 代表两个字符以上且<code>s[i] === s[j]</code>，那么如果<code>s[i+1] ~ s[j-1]</code>是回文，也就是<code>dp[i+1][j-1]</code>为<code>true</code><br>比如: <code>abba</code>，<code>i=0,j=3</code>，<code>s[i] === s[j]</code>，<code>s[i+1] ~ s[j-1]</code>也就是<code>bb</code>，也是一个回文字符串，所以<code>abba</code>也是一个回文字符串</p>\n</li>\n</ul>\n</blockquote>\n"},{"title":"浏览器：跨域","date":"2021-11-27T07:26:10.000Z","description":"学习总结","cover":"https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg","_content":"\n# 浏览器：跨域\n\n受浏览器的`同源策略`影响，不能向不同于自己的域名发起请求，也就是跨域\n\n## 同源策略\n\n同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n\n**同源策略限制内容有：**\n\n- Cookie、LocalStorage、IndexedDB 等存储性内容\n- DOM 节点\n- AJAX 请求发送后，结果被浏览器拦截了\n\n但是有三个标签是允许跨域加载资源：\n\n- `<img src=XXX>`\n- `<link href=XXX>`\n- `<script src=XXX>`\n\n什么情况会发生跨域：\n\n* 同一域名，不同端口\n* 同一域名，不同协议\n* 域名和域名对应相同ip \n* 主域相同，子域不同\n* 不同域名\n\n注意两点：\n\n* **在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”**\n* **跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。\n\n## 跨域解决方案\n\n### 一、JSONP\n\n**利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**\n\nJSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**\n\n流程：\n\n1. 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。\n\n2. 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。\n\n3. 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。\n\n4. 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。\n\n**手撕JSONP方法**：\n\n```js\nfunction jsonp({ url, params, callback }) {\n  return new Promise((resolve, reject) => {\n    let script = document.createElement('script')\n    window[callback] = function(data) {\n      resolve(data)\n      document.body.removeChild(script)\n    }\n    params = { ...params, callback } // wd=b&callback=show\n    let arrs = []\n    for (let key in params) {\n      arrs.push(`${key}=${params[key]}`)\n    }\n    script.src = `${url}?${arrs.join('&')}`\n    document.body.appendChild(script)\n  })\n}\n\njsonp({\n  url: 'http://localhost:3000/say',\n  params: { wd: 'Iloveyou' },\n  callback: 'show'\n}).then(data => {\n  console.log(data)\n})\n```\n\n### 二、CORS\n\n**CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现**。\n\n浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n\n服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n\n虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。\n\n1. **简单请求**\n\n   只要同时满足以下两大条件，就属于简单请求\n\n   条件1：使用下列方法之一：\n\n   - GET\n   - HEAD\n   - POST\n\n   条件2：Content-Type 的值仅限于下列三者之一：\n\n   - text/plain\n   - multipart/form-data\n   - application/x-www-form-urlencoded\n\n   对于简单请求来说，浏览器会直接发出CORS请求，就是在这个请求的头信息中，自动添加一个 `Origin` 字段来说明本次请求的来源（协议 + 域名 + 端口），而后服务器会根据这个值，决定是否同意这次请求\n\n2. **复杂请求**\n\n   不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。\n\n   \"预检\"请求头，一般会包括如下几个：\n\n   * **Access-Control-Allow-Origin**：**允许跨域的来源**，必需项，它表示服务端允许跨域访问的地址来源，你可以写入需要跨域的域名，也可以设为`*`，表示同意任意跨源请求\n\n     注意，将此字段设置为 `*` 是很不安全的，建议指定来源，并且设置为 `*` 号后，游览器将不会发送 `Cookie`，即使你的 `XHR` 设置了 `withCredentials`，也不会发送 `Cookie`\n\n   * **Access-Control-Allow-Methods**：**允许跨域请求的方法**，必需项，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法\n\n   * **Access-Control-Allow-Headers**：**允许的请求头字段**，必需项，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段\n\n   * **Access-Control-Allow-Credentials**：**允许发送Cookie**，该字段可选，它的值是一个布尔值，表示是否允许发送Cookie，默认情况下，Cookie不包括在CORS请求之中\n\n     如果想要发送Cookie，客户端在发送Ajax是也需要配置\n\n     ```js\n     xhr = new XMLHttpRequest()\n     xhr.withCredentials = true\n     ```\n\n   * **Access-Control-Max-Age**：**本次预检请求的有效期**，该字段可选，用来指定本次预检请求的有效期，单位为秒\n\n### 三、服务器代理\n\n利用服务器发送请求不存在跨域来解决跨域，分为`正向代理`和`反向代理`\n\n**正向代理**\n\n指代理服务器与客户端是同源的\n\n**反向代理**\n\n指代理服务器与服务器是同源的\n\n### 四、WebSocket\n\n`WebSocket` 是一种在单个 TCP 连接上进行全双工通信的协议，2008年诞生，2011年被 IETF 定为标准 `RFC 6455`，并由 `RFC7936` 补充规范，`WebSocket API` 也被 W3C 定为标准\n\n`WebSocket` 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据， 在 `WebSocket API` 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，同时，它也是跨域的一种解决方案\n\n### 五、其他\n\n1. **postMessage**\n\n   **postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。\n\n2. **window.name + iframe**\n\n   window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n   通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n3. **location.hash + iframe**\n\n   实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n\n   具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是`http://localhost:3000`;而c.html是`http://localhost:4000`\n\n4. **document.domain + iframe**\n\n   **该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式**。 只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。\n\n   实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。","source":"_posts/Browser-Cross_domain.md","raw":"---\ntitle: 浏览器：跨域\ndate: 2021-11-27 15:26:10\ncategories: 浏览器\ntags: [浏览器]\ndescription: 学习总结\ncover: https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg\n---\n\n# 浏览器：跨域\n\n受浏览器的`同源策略`影响，不能向不同于自己的域名发起请求，也就是跨域\n\n## 同源策略\n\n同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n\n**同源策略限制内容有：**\n\n- Cookie、LocalStorage、IndexedDB 等存储性内容\n- DOM 节点\n- AJAX 请求发送后，结果被浏览器拦截了\n\n但是有三个标签是允许跨域加载资源：\n\n- `<img src=XXX>`\n- `<link href=XXX>`\n- `<script src=XXX>`\n\n什么情况会发生跨域：\n\n* 同一域名，不同端口\n* 同一域名，不同协议\n* 域名和域名对应相同ip \n* 主域相同，子域不同\n* 不同域名\n\n注意两点：\n\n* **在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”**\n* **跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。\n\n## 跨域解决方案\n\n### 一、JSONP\n\n**利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**\n\nJSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**\n\n流程：\n\n1. 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。\n\n2. 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。\n\n3. 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。\n\n4. 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。\n\n**手撕JSONP方法**：\n\n```js\nfunction jsonp({ url, params, callback }) {\n  return new Promise((resolve, reject) => {\n    let script = document.createElement('script')\n    window[callback] = function(data) {\n      resolve(data)\n      document.body.removeChild(script)\n    }\n    params = { ...params, callback } // wd=b&callback=show\n    let arrs = []\n    for (let key in params) {\n      arrs.push(`${key}=${params[key]}`)\n    }\n    script.src = `${url}?${arrs.join('&')}`\n    document.body.appendChild(script)\n  })\n}\n\njsonp({\n  url: 'http://localhost:3000/say',\n  params: { wd: 'Iloveyou' },\n  callback: 'show'\n}).then(data => {\n  console.log(data)\n})\n```\n\n### 二、CORS\n\n**CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现**。\n\n浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n\n服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n\n虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。\n\n1. **简单请求**\n\n   只要同时满足以下两大条件，就属于简单请求\n\n   条件1：使用下列方法之一：\n\n   - GET\n   - HEAD\n   - POST\n\n   条件2：Content-Type 的值仅限于下列三者之一：\n\n   - text/plain\n   - multipart/form-data\n   - application/x-www-form-urlencoded\n\n   对于简单请求来说，浏览器会直接发出CORS请求，就是在这个请求的头信息中，自动添加一个 `Origin` 字段来说明本次请求的来源（协议 + 域名 + 端口），而后服务器会根据这个值，决定是否同意这次请求\n\n2. **复杂请求**\n\n   不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。\n\n   \"预检\"请求头，一般会包括如下几个：\n\n   * **Access-Control-Allow-Origin**：**允许跨域的来源**，必需项，它表示服务端允许跨域访问的地址来源，你可以写入需要跨域的域名，也可以设为`*`，表示同意任意跨源请求\n\n     注意，将此字段设置为 `*` 是很不安全的，建议指定来源，并且设置为 `*` 号后，游览器将不会发送 `Cookie`，即使你的 `XHR` 设置了 `withCredentials`，也不会发送 `Cookie`\n\n   * **Access-Control-Allow-Methods**：**允许跨域请求的方法**，必需项，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法\n\n   * **Access-Control-Allow-Headers**：**允许的请求头字段**，必需项，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段\n\n   * **Access-Control-Allow-Credentials**：**允许发送Cookie**，该字段可选，它的值是一个布尔值，表示是否允许发送Cookie，默认情况下，Cookie不包括在CORS请求之中\n\n     如果想要发送Cookie，客户端在发送Ajax是也需要配置\n\n     ```js\n     xhr = new XMLHttpRequest()\n     xhr.withCredentials = true\n     ```\n\n   * **Access-Control-Max-Age**：**本次预检请求的有效期**，该字段可选，用来指定本次预检请求的有效期，单位为秒\n\n### 三、服务器代理\n\n利用服务器发送请求不存在跨域来解决跨域，分为`正向代理`和`反向代理`\n\n**正向代理**\n\n指代理服务器与客户端是同源的\n\n**反向代理**\n\n指代理服务器与服务器是同源的\n\n### 四、WebSocket\n\n`WebSocket` 是一种在单个 TCP 连接上进行全双工通信的协议，2008年诞生，2011年被 IETF 定为标准 `RFC 6455`，并由 `RFC7936` 补充规范，`WebSocket API` 也被 W3C 定为标准\n\n`WebSocket` 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据， 在 `WebSocket API` 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，同时，它也是跨域的一种解决方案\n\n### 五、其他\n\n1. **postMessage**\n\n   **postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。\n\n2. **window.name + iframe**\n\n   window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n   通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n3. **location.hash + iframe**\n\n   实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n\n   具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是`http://localhost:3000`;而c.html是`http://localhost:4000`\n\n4. **document.domain + iframe**\n\n   **该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式**。 只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。\n\n   实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。","slug":"Browser-Cross_domain","published":1,"updated":"2021-12-02T07:25:58.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lm000xdswkh8ur4evz","content":"<h1 id=\"浏览器：跨域\"><a href=\"#浏览器：跨域\" class=\"headerlink\" title=\"浏览器：跨域\"></a>浏览器：跨域</h1><p>受浏览器的<code>同源策略</code>影响，不能向不同于自己的域名发起请求，也就是跨域</p>\n<h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>\n<p><strong>同源策略限制内容有：</strong></p>\n<ul>\n<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>\n<li>DOM 节点</li>\n<li>AJAX 请求发送后，结果被浏览器拦截了</li>\n</ul>\n<p>但是有三个标签是允许跨域加载资源：</p>\n<ul>\n<li><code>&lt;img src=XXX&gt;</code></li>\n<li><code>&lt;link href=XXX&gt;</code></li>\n<li><code>&lt;script src=XXX&gt;</code></li>\n</ul>\n<p>什么情况会发生跨域：</p>\n<ul>\n<li>同一域名，不同端口</li>\n<li>同一域名，不同协议</li>\n<li>域名和域名对应相同ip </li>\n<li>主域相同，子域不同</li>\n<li>不同域名</li>\n</ul>\n<p>注意两点：</p>\n<ul>\n<li><strong>在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong></li>\n<li><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。</li>\n</ul>\n<h2 id=\"跨域解决方案\"><a href=\"#跨域解决方案\" class=\"headerlink\" title=\"跨域解决方案\"></a>跨域解决方案</h2><h3 id=\"一、JSONP\"><a href=\"#一、JSONP\" class=\"headerlink\" title=\"一、JSONP\"></a>一、JSONP</h3><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p>\n<p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p>\n<p>流程：</p>\n<ol>\n<li><p>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</p>\n</li>\n<li><p>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</p>\n</li>\n<li><p>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</p>\n</li>\n<li><p>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</p>\n</li>\n</ol>\n<p><strong>手撕JSONP方法</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jsonp</span>(<span class=\"params\">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> script = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;script&#x27;</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>[callback] = <span class=\"keyword\">function</span>(<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(data)</span><br><span class=\"line\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(script)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    params = &#123; ...params, callback &#125; <span class=\"comment\">// wd=b&amp;callback=show</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">      arrs.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;params[key]&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.<span class=\"property\">src</span> = <span class=\"string\">`<span class=\"subst\">$&#123;url&#125;</span>?<span class=\"subst\">$&#123;arrs.join(<span class=\"string\">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(script)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">jsonp</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">&#x27;http://localhost:3000/say&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">params</span>: &#123; <span class=\"attr\">wd</span>: <span class=\"string\">&#x27;Iloveyou&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">callback</span>: <span class=\"string\">&#x27;show&#x27;</span></span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、CORS\"><a href=\"#二、CORS\" class=\"headerlink\" title=\"二、CORS\"></a>二、CORS</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>\n<ol>\n<li><p><strong>简单请求</strong></p>\n<p>只要同时满足以下两大条件，就属于简单请求</p>\n<p>条件1：使用下列方法之一：</p>\n<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n<p>条件2：Content-Type 的值仅限于下列三者之一：</p>\n<ul>\n<li>text/plain</li>\n<li>multipart/form-data</li>\n<li>application/x-www-form-urlencoded</li>\n</ul>\n<p>对于简单请求来说，浏览器会直接发出CORS请求，就是在这个请求的头信息中，自动添加一个 <code>Origin</code> 字段来说明本次请求的来源（协议 + 域名 + 端口），而后服务器会根据这个值，决定是否同意这次请求</p>\n</li>\n<li><p><strong>复杂请求</strong></p>\n<p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>\n<p>“预检”请求头，一般会包括如下几个：</p>\n<ul>\n<li><p><strong>Access-Control-Allow-Origin</strong>：<strong>允许跨域的来源</strong>，必需项，它表示服务端允许跨域访问的地址来源，你可以写入需要跨域的域名，也可以设为<code>*</code>，表示同意任意跨源请求</p>\n<p>注意，将此字段设置为 <code>*</code> 是很不安全的，建议指定来源，并且设置为 <code>*</code> 号后，游览器将不会发送 <code>Cookie</code>，即使你的 <code>XHR</code> 设置了 <code>withCredentials</code>，也不会发送 <code>Cookie</code></p>\n</li>\n<li><p><strong>Access-Control-Allow-Methods</strong>：<strong>允许跨域请求的方法</strong>，必需项，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</p>\n</li>\n<li><p><strong>Access-Control-Allow-Headers</strong>：<strong>允许的请求头字段</strong>，必需项，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段</p>\n</li>\n<li><p><strong>Access-Control-Allow-Credentials</strong>：<strong>允许发送Cookie</strong>，该字段可选，它的值是一个布尔值，表示是否允许发送Cookie，默认情况下，Cookie不包括在CORS请求之中</p>\n<p>如果想要发送Cookie，客户端在发送Ajax是也需要配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\">xhr.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Access-Control-Max-Age</strong>：<strong>本次预检请求的有效期</strong>，该字段可选，用来指定本次预检请求的有效期，单位为秒</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"三、服务器代理\"><a href=\"#三、服务器代理\" class=\"headerlink\" title=\"三、服务器代理\"></a>三、服务器代理</h3><p>利用服务器发送请求不存在跨域来解决跨域，分为<code>正向代理</code>和<code>反向代理</code></p>\n<p><strong>正向代理</strong></p>\n<p>指代理服务器与客户端是同源的</p>\n<p><strong>反向代理</strong></p>\n<p>指代理服务器与服务器是同源的</p>\n<h3 id=\"四、WebSocket\"><a href=\"#四、WebSocket\" class=\"headerlink\" title=\"四、WebSocket\"></a>四、WebSocket</h3><p><code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，2008年诞生，2011年被 IETF 定为标准 <code>RFC 6455</code>，并由 <code>RFC7936</code> 补充规范，<code>WebSocket API</code> 也被 W3C 定为标准</p>\n<p><code>WebSocket</code> 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据， 在 <code>WebSocket API</code> 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，同时，它也是跨域的一种解决方案</p>\n<h3 id=\"五、其他\"><a href=\"#五、其他\" class=\"headerlink\" title=\"五、其他\"></a>五、其他</h3><ol>\n<li><p><strong>postMessage</strong></p>\n<p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p>\n</li>\n<li><p><strong>window.name + iframe</strong></p>\n<p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\n</li>\n<li><p><strong>location.hash + iframe</strong></p>\n<p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>\n<p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p>\n</li>\n<li><p><strong>document.domain + iframe</strong></p>\n<p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p>\n<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器：跨域\"><a href=\"#浏览器：跨域\" class=\"headerlink\" title=\"浏览器：跨域\"></a>浏览器：跨域</h1><p>受浏览器的<code>同源策略</code>影响，不能向不同于自己的域名发起请求，也就是跨域</p>\n<h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>\n<p><strong>同源策略限制内容有：</strong></p>\n<ul>\n<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>\n<li>DOM 节点</li>\n<li>AJAX 请求发送后，结果被浏览器拦截了</li>\n</ul>\n<p>但是有三个标签是允许跨域加载资源：</p>\n<ul>\n<li><code>&lt;img src=XXX&gt;</code></li>\n<li><code>&lt;link href=XXX&gt;</code></li>\n<li><code>&lt;script src=XXX&gt;</code></li>\n</ul>\n<p>什么情况会发生跨域：</p>\n<ul>\n<li>同一域名，不同端口</li>\n<li>同一域名，不同协议</li>\n<li>域名和域名对应相同ip </li>\n<li>主域相同，子域不同</li>\n<li>不同域名</li>\n</ul>\n<p>注意两点：</p>\n<ul>\n<li><strong>在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong></li>\n<li><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。</li>\n</ul>\n<h2 id=\"跨域解决方案\"><a href=\"#跨域解决方案\" class=\"headerlink\" title=\"跨域解决方案\"></a>跨域解决方案</h2><h3 id=\"一、JSONP\"><a href=\"#一、JSONP\" class=\"headerlink\" title=\"一、JSONP\"></a>一、JSONP</h3><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p>\n<p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p>\n<p>流程：</p>\n<ol>\n<li><p>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</p>\n</li>\n<li><p>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</p>\n</li>\n<li><p>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</p>\n</li>\n<li><p>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</p>\n</li>\n</ol>\n<p><strong>手撕JSONP方法</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jsonp</span>(<span class=\"params\">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> script = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;script&#x27;</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>[callback] = <span class=\"keyword\">function</span>(<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(data)</span><br><span class=\"line\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(script)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    params = &#123; ...params, callback &#125; <span class=\"comment\">// wd=b&amp;callback=show</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">      arrs.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;params[key]&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.<span class=\"property\">src</span> = <span class=\"string\">`<span class=\"subst\">$&#123;url&#125;</span>?<span class=\"subst\">$&#123;arrs.join(<span class=\"string\">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(script)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">jsonp</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">&#x27;http://localhost:3000/say&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">params</span>: &#123; <span class=\"attr\">wd</span>: <span class=\"string\">&#x27;Iloveyou&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">callback</span>: <span class=\"string\">&#x27;show&#x27;</span></span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、CORS\"><a href=\"#二、CORS\" class=\"headerlink\" title=\"二、CORS\"></a>二、CORS</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>\n<ol>\n<li><p><strong>简单请求</strong></p>\n<p>只要同时满足以下两大条件，就属于简单请求</p>\n<p>条件1：使用下列方法之一：</p>\n<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n<p>条件2：Content-Type 的值仅限于下列三者之一：</p>\n<ul>\n<li>text/plain</li>\n<li>multipart/form-data</li>\n<li>application/x-www-form-urlencoded</li>\n</ul>\n<p>对于简单请求来说，浏览器会直接发出CORS请求，就是在这个请求的头信息中，自动添加一个 <code>Origin</code> 字段来说明本次请求的来源（协议 + 域名 + 端口），而后服务器会根据这个值，决定是否同意这次请求</p>\n</li>\n<li><p><strong>复杂请求</strong></p>\n<p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>\n<p>“预检”请求头，一般会包括如下几个：</p>\n<ul>\n<li><p><strong>Access-Control-Allow-Origin</strong>：<strong>允许跨域的来源</strong>，必需项，它表示服务端允许跨域访问的地址来源，你可以写入需要跨域的域名，也可以设为<code>*</code>，表示同意任意跨源请求</p>\n<p>注意，将此字段设置为 <code>*</code> 是很不安全的，建议指定来源，并且设置为 <code>*</code> 号后，游览器将不会发送 <code>Cookie</code>，即使你的 <code>XHR</code> 设置了 <code>withCredentials</code>，也不会发送 <code>Cookie</code></p>\n</li>\n<li><p><strong>Access-Control-Allow-Methods</strong>：<strong>允许跨域请求的方法</strong>，必需项，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</p>\n</li>\n<li><p><strong>Access-Control-Allow-Headers</strong>：<strong>允许的请求头字段</strong>，必需项，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段</p>\n</li>\n<li><p><strong>Access-Control-Allow-Credentials</strong>：<strong>允许发送Cookie</strong>，该字段可选，它的值是一个布尔值，表示是否允许发送Cookie，默认情况下，Cookie不包括在CORS请求之中</p>\n<p>如果想要发送Cookie，客户端在发送Ajax是也需要配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\">xhr.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Access-Control-Max-Age</strong>：<strong>本次预检请求的有效期</strong>，该字段可选，用来指定本次预检请求的有效期，单位为秒</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"三、服务器代理\"><a href=\"#三、服务器代理\" class=\"headerlink\" title=\"三、服务器代理\"></a>三、服务器代理</h3><p>利用服务器发送请求不存在跨域来解决跨域，分为<code>正向代理</code>和<code>反向代理</code></p>\n<p><strong>正向代理</strong></p>\n<p>指代理服务器与客户端是同源的</p>\n<p><strong>反向代理</strong></p>\n<p>指代理服务器与服务器是同源的</p>\n<h3 id=\"四、WebSocket\"><a href=\"#四、WebSocket\" class=\"headerlink\" title=\"四、WebSocket\"></a>四、WebSocket</h3><p><code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，2008年诞生，2011年被 IETF 定为标准 <code>RFC 6455</code>，并由 <code>RFC7936</code> 补充规范，<code>WebSocket API</code> 也被 W3C 定为标准</p>\n<p><code>WebSocket</code> 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据， 在 <code>WebSocket API</code> 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，同时，它也是跨域的一种解决方案</p>\n<h3 id=\"五、其他\"><a href=\"#五、其他\" class=\"headerlink\" title=\"五、其他\"></a>五、其他</h3><ol>\n<li><p><strong>postMessage</strong></p>\n<p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p>\n</li>\n<li><p><strong>window.name + iframe</strong></p>\n<p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\n</li>\n<li><p><strong>location.hash + iframe</strong></p>\n<p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>\n<p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p>\n</li>\n<li><p><strong>document.domain + iframe</strong></p>\n<p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p>\n<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>\n</li>\n</ol>\n"},{"title":"浏览器：发展历程","date":"2021-11-25T03:44:20.000Z","description":"学习总结","cover":"https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg","_content":"\n# 浏览器：发展历程\n\n从第一个诞生的浏览器到如今，浏览器发生了怎样的变化？\n\n## 一、架构\n\n1. **单进程浏览器**\n\n   **单进程浏览器是指浏览器所以模块都运行再同一个进程里**，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。\n\n   2007年之前，所有的浏览器都是单进程的，页面的所有的功能模块都运行在同一个进程里，这个模块包括但不限于：网络、渲染引擎、JavaScript运行环境、第三方插件等。\n\n   **缺点**：\n\n   * **不稳定**：早期的浏览器都是通过插件来实现视频、游戏等功能，插件、渲染引擎等都运行在浏览器进程之中，一个意外崩溃就会导致整个浏览器的奔溃。\n\n   * **不流畅**：因为所有页面的功能模块都运行在同一个线程之中，因此同一时刻只有一个模块可以执行，这就很有可能出现一个模块发生阻塞的时候而导致其他模块无法运行的情况。\n\n   * **不安全**：不安全主要是处于两个方面的，一个是插件一个是页面脚本。页面中运行的插件可以读取电脑的资源，执行一些命令。而页面脚本则可以通过浏览器漏洞来获取系统权限，从而应发一系列安全问题。\n\n2. **多进程浏览器**\n\n   浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。\n\n   * **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n\n   * **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n\n   * **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n   * **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n   * **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n   多进程的浏览器存在着一些**问题**：\n\n   > 资源占用更多了\n   > 更为复杂的体系结构\n\n## 二、厂商\n\n1995年，网景公司推出的Navigator浏览器\n\n1996年，微软推出的Internet Explore浏览器（IE浏览器）\n\n2002年，IE浏览器完胜，占据96%的市场份额（一家独大，浏览器没有完全按照W3C/ECMA的标准去解析HTML/CSS/JS代码，导致了IE中有很多的兼容问题，IE6~8）\n\n2004年，Firefox火狐浏览器诞生\n\n2008年，Chrome谷歌浏览器（webkit内核，特色：V8引擎处理性能优越，缺点吃内存）\n\n## 三、内核\n\n内核可以分成两部分：渲染引擎（layout engineer）或（Rendering Engine）和 JS 引擎。内核负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。\n\n常见的内核：\n\n* **Trident（IE(4~11)）**：该内核开放接口，但不是开源，所以曾经出现过很多基于IE内核的浏览器\n* **Gecko（Firefox）**：NetSpace是Firefox的前生，故也是该内核，且该内核开源\n* **Presto（Opera(1~14)）**：不开放接口也不开源，Opera14之后改用了Blink，限制Presto发展的原因主要是只有Opera采用了该内核，而Opera也主要只在Windows下运行\n* **WebKit（Safari, Chrome(1~27)）**：该内核开源，由早期的KHTML演化而来\n* **Blink（Chrome(28 ), Opera(15 )）**：该内核由Google和Opera Software一起开发，基于WebKit中的WebCore引擎，开源\n* **Edge（Edge）**：微软代替IE的一个新兴浏览器，捆绑在Windows10上，不开放接口也不开源\n\n\n\n参考文章：\n\n[浏览器发展史](https://www.jianshu.com/p/b1a033083b0e)\n\n[全面了解浏览器（内核）发展史](https://blog.csdn.net/a3192048/article/details/80834027)\n\n","source":"_posts/Browser-History.md","raw":"---\ntitle: 浏览器：发展历程\ndate: 2021-11-25 11:44:20\ncategories: 浏览器\ntags: [浏览器]\ndescription: 学习总结\ncover: https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg\n---\n\n# 浏览器：发展历程\n\n从第一个诞生的浏览器到如今，浏览器发生了怎样的变化？\n\n## 一、架构\n\n1. **单进程浏览器**\n\n   **单进程浏览器是指浏览器所以模块都运行再同一个进程里**，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。\n\n   2007年之前，所有的浏览器都是单进程的，页面的所有的功能模块都运行在同一个进程里，这个模块包括但不限于：网络、渲染引擎、JavaScript运行环境、第三方插件等。\n\n   **缺点**：\n\n   * **不稳定**：早期的浏览器都是通过插件来实现视频、游戏等功能，插件、渲染引擎等都运行在浏览器进程之中，一个意外崩溃就会导致整个浏览器的奔溃。\n\n   * **不流畅**：因为所有页面的功能模块都运行在同一个线程之中，因此同一时刻只有一个模块可以执行，这就很有可能出现一个模块发生阻塞的时候而导致其他模块无法运行的情况。\n\n   * **不安全**：不安全主要是处于两个方面的，一个是插件一个是页面脚本。页面中运行的插件可以读取电脑的资源，执行一些命令。而页面脚本则可以通过浏览器漏洞来获取系统权限，从而应发一系列安全问题。\n\n2. **多进程浏览器**\n\n   浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。\n\n   * **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n\n   * **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n\n   * **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n   * **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n   * **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n   多进程的浏览器存在着一些**问题**：\n\n   > 资源占用更多了\n   > 更为复杂的体系结构\n\n## 二、厂商\n\n1995年，网景公司推出的Navigator浏览器\n\n1996年，微软推出的Internet Explore浏览器（IE浏览器）\n\n2002年，IE浏览器完胜，占据96%的市场份额（一家独大，浏览器没有完全按照W3C/ECMA的标准去解析HTML/CSS/JS代码，导致了IE中有很多的兼容问题，IE6~8）\n\n2004年，Firefox火狐浏览器诞生\n\n2008年，Chrome谷歌浏览器（webkit内核，特色：V8引擎处理性能优越，缺点吃内存）\n\n## 三、内核\n\n内核可以分成两部分：渲染引擎（layout engineer）或（Rendering Engine）和 JS 引擎。内核负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。\n\n常见的内核：\n\n* **Trident（IE(4~11)）**：该内核开放接口，但不是开源，所以曾经出现过很多基于IE内核的浏览器\n* **Gecko（Firefox）**：NetSpace是Firefox的前生，故也是该内核，且该内核开源\n* **Presto（Opera(1~14)）**：不开放接口也不开源，Opera14之后改用了Blink，限制Presto发展的原因主要是只有Opera采用了该内核，而Opera也主要只在Windows下运行\n* **WebKit（Safari, Chrome(1~27)）**：该内核开源，由早期的KHTML演化而来\n* **Blink（Chrome(28 ), Opera(15 )）**：该内核由Google和Opera Software一起开发，基于WebKit中的WebCore引擎，开源\n* **Edge（Edge）**：微软代替IE的一个新兴浏览器，捆绑在Windows10上，不开放接口也不开源\n\n\n\n参考文章：\n\n[浏览器发展史](https://www.jianshu.com/p/b1a033083b0e)\n\n[全面了解浏览器（内核）发展史](https://blog.csdn.net/a3192048/article/details/80834027)\n\n","slug":"Browser-History","published":1,"updated":"2021-12-02T07:25:58.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1ln0011dswk5yzo9lm1","content":"<h1 id=\"浏览器：发展历程\"><a href=\"#浏览器：发展历程\" class=\"headerlink\" title=\"浏览器：发展历程\"></a>浏览器：发展历程</h1><p>从第一个诞生的浏览器到如今，浏览器发生了怎样的变化？</p>\n<h2 id=\"一、架构\"><a href=\"#一、架构\" class=\"headerlink\" title=\"一、架构\"></a>一、架构</h2><ol>\n<li><p><strong>单进程浏览器</strong></p>\n<p><strong>单进程浏览器是指浏览器所以模块都运行再同一个进程里</strong>，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。</p>\n<p>2007年之前，所有的浏览器都是单进程的，页面的所有的功能模块都运行在同一个进程里，这个模块包括但不限于：网络、渲染引擎、JavaScript运行环境、第三方插件等。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><p><strong>不稳定</strong>：早期的浏览器都是通过插件来实现视频、游戏等功能，插件、渲染引擎等都运行在浏览器进程之中，一个意外崩溃就会导致整个浏览器的奔溃。</p>\n</li>\n<li><p><strong>不流畅</strong>：因为所有页面的功能模块都运行在同一个线程之中，因此同一时刻只有一个模块可以执行，这就很有可能出现一个模块发生阻塞的时候而导致其他模块无法运行的情况。</p>\n</li>\n<li><p><strong>不安全</strong>：不安全主要是处于两个方面的，一个是插件一个是页面脚本。页面中运行的插件可以读取电脑的资源，执行一些命令。而页面脚本则可以通过浏览器漏洞来获取系统权限，从而应发一系列安全问题。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>多进程浏览器</strong></p>\n<p>浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p>\n<ul>\n<li><p><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>\n</li>\n<li><p><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>\n</li>\n<li><p><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>\n</li>\n<li><p><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>\n</li>\n<li><p><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>\n</li>\n</ul>\n<p>多进程的浏览器存在着一些<strong>问题</strong>：</p>\n<blockquote>\n<p>资源占用更多了<br>更为复杂的体系结构</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"二、厂商\"><a href=\"#二、厂商\" class=\"headerlink\" title=\"二、厂商\"></a>二、厂商</h2><p>1995年，网景公司推出的Navigator浏览器</p>\n<p>1996年，微软推出的Internet Explore浏览器（IE浏览器）</p>\n<p>2002年，IE浏览器完胜，占据96%的市场份额（一家独大，浏览器没有完全按照W3C/ECMA的标准去解析HTML/CSS/JS代码，导致了IE中有很多的兼容问题，IE6~8）</p>\n<p>2004年，Firefox火狐浏览器诞生</p>\n<p>2008年，Chrome谷歌浏览器（webkit内核，特色：V8引擎处理性能优越，缺点吃内存）</p>\n<h2 id=\"三、内核\"><a href=\"#三、内核\" class=\"headerlink\" title=\"三、内核\"></a>三、内核</h2><p>内核可以分成两部分：渲染引擎（layout engineer）或（Rendering Engine）和 JS 引擎。内核负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。</p>\n<p>常见的内核：</p>\n<ul>\n<li><strong>Trident（IE(4~11)）</strong>：该内核开放接口，但不是开源，所以曾经出现过很多基于IE内核的浏览器</li>\n<li><strong>Gecko（Firefox）</strong>：NetSpace是Firefox的前生，故也是该内核，且该内核开源</li>\n<li><strong>Presto（Opera(1~14)）</strong>：不开放接口也不开源，Opera14之后改用了Blink，限制Presto发展的原因主要是只有Opera采用了该内核，而Opera也主要只在Windows下运行</li>\n<li><strong>WebKit（Safari, Chrome(1~27)）</strong>：该内核开源，由早期的KHTML演化而来</li>\n<li><strong>Blink（Chrome(28 ), Opera(15 )）</strong>：该内核由Google和Opera Software一起开发，基于WebKit中的WebCore引擎，开源</li>\n<li><strong>Edge（Edge）</strong>：微软代替IE的一个新兴浏览器，捆绑在Windows10上，不开放接口也不开源</li>\n</ul>\n<p>参考文章：</p>\n<p><a href=\"https://www.jianshu.com/p/b1a033083b0e\">浏览器发展史</a></p>\n<p><a href=\"https://blog.csdn.net/a3192048/article/details/80834027\">全面了解浏览器（内核）发展史</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器：发展历程\"><a href=\"#浏览器：发展历程\" class=\"headerlink\" title=\"浏览器：发展历程\"></a>浏览器：发展历程</h1><p>从第一个诞生的浏览器到如今，浏览器发生了怎样的变化？</p>\n<h2 id=\"一、架构\"><a href=\"#一、架构\" class=\"headerlink\" title=\"一、架构\"></a>一、架构</h2><ol>\n<li><p><strong>单进程浏览器</strong></p>\n<p><strong>单进程浏览器是指浏览器所以模块都运行再同一个进程里</strong>，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。</p>\n<p>2007年之前，所有的浏览器都是单进程的，页面的所有的功能模块都运行在同一个进程里，这个模块包括但不限于：网络、渲染引擎、JavaScript运行环境、第三方插件等。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><p><strong>不稳定</strong>：早期的浏览器都是通过插件来实现视频、游戏等功能，插件、渲染引擎等都运行在浏览器进程之中，一个意外崩溃就会导致整个浏览器的奔溃。</p>\n</li>\n<li><p><strong>不流畅</strong>：因为所有页面的功能模块都运行在同一个线程之中，因此同一时刻只有一个模块可以执行，这就很有可能出现一个模块发生阻塞的时候而导致其他模块无法运行的情况。</p>\n</li>\n<li><p><strong>不安全</strong>：不安全主要是处于两个方面的，一个是插件一个是页面脚本。页面中运行的插件可以读取电脑的资源，执行一些命令。而页面脚本则可以通过浏览器漏洞来获取系统权限，从而应发一系列安全问题。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>多进程浏览器</strong></p>\n<p>浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p>\n<ul>\n<li><p><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>\n</li>\n<li><p><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>\n</li>\n<li><p><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>\n</li>\n<li><p><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>\n</li>\n<li><p><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>\n</li>\n</ul>\n<p>多进程的浏览器存在着一些<strong>问题</strong>：</p>\n<blockquote>\n<p>资源占用更多了<br>更为复杂的体系结构</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"二、厂商\"><a href=\"#二、厂商\" class=\"headerlink\" title=\"二、厂商\"></a>二、厂商</h2><p>1995年，网景公司推出的Navigator浏览器</p>\n<p>1996年，微软推出的Internet Explore浏览器（IE浏览器）</p>\n<p>2002年，IE浏览器完胜，占据96%的市场份额（一家独大，浏览器没有完全按照W3C/ECMA的标准去解析HTML/CSS/JS代码，导致了IE中有很多的兼容问题，IE6~8）</p>\n<p>2004年，Firefox火狐浏览器诞生</p>\n<p>2008年，Chrome谷歌浏览器（webkit内核，特色：V8引擎处理性能优越，缺点吃内存）</p>\n<h2 id=\"三、内核\"><a href=\"#三、内核\" class=\"headerlink\" title=\"三、内核\"></a>三、内核</h2><p>内核可以分成两部分：渲染引擎（layout engineer）或（Rendering Engine）和 JS 引擎。内核负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。</p>\n<p>常见的内核：</p>\n<ul>\n<li><strong>Trident（IE(4~11)）</strong>：该内核开放接口，但不是开源，所以曾经出现过很多基于IE内核的浏览器</li>\n<li><strong>Gecko（Firefox）</strong>：NetSpace是Firefox的前生，故也是该内核，且该内核开源</li>\n<li><strong>Presto（Opera(1~14)）</strong>：不开放接口也不开源，Opera14之后改用了Blink，限制Presto发展的原因主要是只有Opera采用了该内核，而Opera也主要只在Windows下运行</li>\n<li><strong>WebKit（Safari, Chrome(1~27)）</strong>：该内核开源，由早期的KHTML演化而来</li>\n<li><strong>Blink（Chrome(28 ), Opera(15 )）</strong>：该内核由Google和Opera Software一起开发，基于WebKit中的WebCore引擎，开源</li>\n<li><strong>Edge（Edge）</strong>：微软代替IE的一个新兴浏览器，捆绑在Windows10上，不开放接口也不开源</li>\n</ul>\n<p>参考文章：</p>\n<p><a href=\"https://www.jianshu.com/p/b1a033083b0e\">浏览器发展史</a></p>\n<p><a href=\"https://blog.csdn.net/a3192048/article/details/80834027\">全面了解浏览器（内核）发展史</a></p>\n"},{"title":"浏览器：WebStorage","date":"2021-12-02T07:27:10.000Z","description":"学习总结","cover":"https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg","_content":"# 浏览器：WebStorage\n\nWebStorage网页存储，用于在前端存储数据，常见的有`Cookie`、`LocalStorage`、`SessionStorage`、`IndexDB`\n\n## Cookie\n\n**HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存**\n\n当一个用户登录之后，HTTP是无状态的并不知道用户已经登录，需要一个东西来保存这个状态，这个就是Cookie。\n\nCookie就是维护客户端与服务器之间的一个状态，通常服务器将某个表示状态的数据进行加密，通过响应头`set-cookie`返回给客户端，然后客户端保存。\n\nCookie并不会一直保存在客户端，可以设置一个过期时间，如果不设置过期时间，那么就是会话级别的，网页已关闭就删除\n\nCookie可以用来共享数据，但是受`同源策略`影响，只能在同源的网页才能获取到一样的cookie\n\n缺点：\n\n* 只能是字符串，并且只能保存4kb的内容\n\n* 没有自己的api，需要用户自己封装\n\n* 在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积\n\n* 不安全，如果不设置`http-only`攻击者可以使用JavaScript就可以获取到Cookie实施`XSS攻击`\n\n  > 相关属性\n  >\n  > **http-only**：不能使用Javascript访问cookie，减少`XSS攻击`\n  >\n  > **secure**：只能在协议为HTTPS的请求中携带\n  >\n  > **same-site**：规定浏览其不能再跨域请求中携带cookie，减少`crsf攻击`\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\n```\n\n```js\nvar cookie = document.cookie;//获取cookie\ndocument.cookie = 'color:blue;' + cookie;//设置cookie\n```\n\n> cookie和session的区别？\n>\n> 答：\n>\n> * 单个cookie保存的数据不能超过4kb；session大小没有限制。\n>\n> * cookie保存在浏览器，session保存在服务器\n>\n> * session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。\n>\n>   在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积\n\n## LocalStorage/SessionStorage\n\n两者的特点：\n\n- 大小为5M左右\n- 仅在客户端使用，不和服务端进行通信\n- 接口封装较好，有自己的api\n- 受同源策略影响\n\n不同点：\n\n* SessionStorage是会话级别网页关闭就会清除，而LocalStorage需要手动清除，不然一直存在\n\n```js\n localStorage.setItem（'name','world'）\n sessionStorage.setItem（'gender','female'）\n var name=localStorage.getItem('name')\n var gender=sessionStorage.getItem('gender')\n```\n\n## IndexDB\n\nIndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。\n\n[浏览器数据库 IndexedDB 入门教程](http://www.ruanyifeng.com/blog/2018/07/indexeddb.html)\n\n* **window.indexedDB.open**打开一个数据库,onsuccess、onerror、onupgradeneeded监听一个数据库的成功、失败、新建（升级），接受两个参数（数据库名，版本（默认1，新建1））\n* **db.createObjectStore**创建一个表\n* **objectStore.createIndex**创建索引\n* **db.transaction**创建一个事务\n* **objectStore.add**添加数据\n* **objectStore.put**修改数据\n* **objectStore.delete**删除数据\n* **objectStore.get**获取数据\n* **objectStore.openCursor**打开列表指针\n\n```js\n//打开一个数据库\n\t\tlet res = window.indexedDB.open(\"db\");\n\t\tlet db;\n\t\t//监听打开成功\n\t\t//如果数据库存在会执行这个事件，而不会执行onupgradeneeded\n\t\tres.onsuccess=(e)=>{\n\t\t\tdb=res.result;\n\n\t\t\tadd(1)\n\t\t\tadd(2)\n\t\t\tadd(3)\n\t\t\t// put()\n\t\t\t// read()\n\t\t\t// del()\n\t\t\tlist();\n\t\t\tconsole.log(\"indexDB打开成功\")\n\t\t}\n\t\t//监听打开失败\n\t\tres.onerror=()=>{\n\t\t\tconsole.log(\"indexDB打开失败\")\n\t\t}\n\t\t//监听创建（数据库升级事件）\n        //初次创建数据库会执行这个事件\n\t\tres.onupgradeneeded=(res)=>{\n\t\t\tdb = event.target.result;\n\t\t\t//创建一个表\n\t\t\t//自动生成组件  自增\n\t\t\t// var objectStore = db.createObjectStore('person',{ autoIncrement: true });\n\t\t\t//person表   主键id\n\t\t\tlet objectStore=db.createObjectStore(\"person\",{keyPath:\"id\"});\n\t\t\t//创建索引\n\t\t\tobjectStore.createIndex('name', 'name', { unique: false });\n\t\t\t// console.log(objectStore)\n\t\t}\n\n\t\t\n\t\t//添加\n\t\tfunction add(id) {\n\t\t\t//新建一个事务。新建时必须指定表格名称和操作模式（\"只读\"或\"读写\"）\n\t\t\tlet res=db.transaction([\"person\"],\"readwrite\");\n\t\t\t//打开表\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\t//添加\n\t\t\tlet create=tab.add({id:id,name:\"张三\",sex:\"男\",age:15});\n\t\t\t//监听添加成功/失败\n\t\t\tcreate.onsuccess=()=>{\n\t\t\t\tconsole.log(\"添加成功\")\n\t\t\t}\n\t\t\tcreate.onerror=()=>{\n\t\t\t\tconsole.log(\"添加失败\")\n\t\t\t}\n\t\t\tconsole.log(tab)\n\t\t}\n\t\t//获取记录\n\t\tfunction read(){\n\t\t\tlet res=db.transaction([\"person\"]);\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet get=tab.get(1)\n\t\t\tget.onsuccess=()=>{\n\t\t\t\tlet data=get.result;\n\t\t\t\tconsole.log(data)\n\t\t\t}\n\t\t\tget.onerror=()=>{\n\t\t\t\tconsole.log(\"获取数据失败\")\n\t\t\t}\n\t\t}\n\t\t//修改\n\t\tfunction put(){\n\t\t\tlet res=db.transaction([\"person\"],\"readwrite\");\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet update=tab.put({id:1,name:\"王五\",sex:\"女\",age:22})\n\t\t\tupdate.onsuccess=()=>{\n\t\t\t\tconsole.log(\"数据更新成功\");\n\t\t\t}\n\t\t\tupdate.onerror=()=>{\n\t\t\t\tconsole.log(\"数据更新失败\");\n\t\t\t}\n\t\t}\n\t\t//删除\n\t\tfunction del(){\n\t\t\tlet res=db.transaction([\"person\"],\"readwrite\");\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet d=tab.delete(1);\n\t\t\td.onsuccess=()=>{\n\t\t\t\tconsole.log(\"数据删除成功\");\n\t\t\t}\n\t\t}\n\t\t//列表获取\n\t\tfunction list(){\n\t\t\tlet res=db.transaction([\"person\"]);\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet cursor=tab.openCursor()\n\t\t\tcursor.onsuccess=(e)=>{\n\t\t\t\tlet data=e.target.result;\n\t\t\t\tif(data){\n\t\t\t\t\tconsole.log(data.value)\n\t\t\t\t\tdata.continue();\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log(\"没有更多数据了\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n","source":"_posts/Browser-WebStorage.md","raw":"---\ntitle: 浏览器：WebStorage\ndate: 2021-12-02 15:27:10\ncategories: 浏览器\ntags: [浏览器]\ndescription: 学习总结\ncover: https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg\n---\n# 浏览器：WebStorage\n\nWebStorage网页存储，用于在前端存储数据，常见的有`Cookie`、`LocalStorage`、`SessionStorage`、`IndexDB`\n\n## Cookie\n\n**HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存**\n\n当一个用户登录之后，HTTP是无状态的并不知道用户已经登录，需要一个东西来保存这个状态，这个就是Cookie。\n\nCookie就是维护客户端与服务器之间的一个状态，通常服务器将某个表示状态的数据进行加密，通过响应头`set-cookie`返回给客户端，然后客户端保存。\n\nCookie并不会一直保存在客户端，可以设置一个过期时间，如果不设置过期时间，那么就是会话级别的，网页已关闭就删除\n\nCookie可以用来共享数据，但是受`同源策略`影响，只能在同源的网页才能获取到一样的cookie\n\n缺点：\n\n* 只能是字符串，并且只能保存4kb的内容\n\n* 没有自己的api，需要用户自己封装\n\n* 在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积\n\n* 不安全，如果不设置`http-only`攻击者可以使用JavaScript就可以获取到Cookie实施`XSS攻击`\n\n  > 相关属性\n  >\n  > **http-only**：不能使用Javascript访问cookie，减少`XSS攻击`\n  >\n  > **secure**：只能在协议为HTTPS的请求中携带\n  >\n  > **same-site**：规定浏览其不能再跨域请求中携带cookie，减少`crsf攻击`\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\n```\n\n```js\nvar cookie = document.cookie;//获取cookie\ndocument.cookie = 'color:blue;' + cookie;//设置cookie\n```\n\n> cookie和session的区别？\n>\n> 答：\n>\n> * 单个cookie保存的数据不能超过4kb；session大小没有限制。\n>\n> * cookie保存在浏览器，session保存在服务器\n>\n> * session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。\n>\n>   在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积\n\n## LocalStorage/SessionStorage\n\n两者的特点：\n\n- 大小为5M左右\n- 仅在客户端使用，不和服务端进行通信\n- 接口封装较好，有自己的api\n- 受同源策略影响\n\n不同点：\n\n* SessionStorage是会话级别网页关闭就会清除，而LocalStorage需要手动清除，不然一直存在\n\n```js\n localStorage.setItem（'name','world'）\n sessionStorage.setItem（'gender','female'）\n var name=localStorage.getItem('name')\n var gender=sessionStorage.getItem('gender')\n```\n\n## IndexDB\n\nIndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。\n\n[浏览器数据库 IndexedDB 入门教程](http://www.ruanyifeng.com/blog/2018/07/indexeddb.html)\n\n* **window.indexedDB.open**打开一个数据库,onsuccess、onerror、onupgradeneeded监听一个数据库的成功、失败、新建（升级），接受两个参数（数据库名，版本（默认1，新建1））\n* **db.createObjectStore**创建一个表\n* **objectStore.createIndex**创建索引\n* **db.transaction**创建一个事务\n* **objectStore.add**添加数据\n* **objectStore.put**修改数据\n* **objectStore.delete**删除数据\n* **objectStore.get**获取数据\n* **objectStore.openCursor**打开列表指针\n\n```js\n//打开一个数据库\n\t\tlet res = window.indexedDB.open(\"db\");\n\t\tlet db;\n\t\t//监听打开成功\n\t\t//如果数据库存在会执行这个事件，而不会执行onupgradeneeded\n\t\tres.onsuccess=(e)=>{\n\t\t\tdb=res.result;\n\n\t\t\tadd(1)\n\t\t\tadd(2)\n\t\t\tadd(3)\n\t\t\t// put()\n\t\t\t// read()\n\t\t\t// del()\n\t\t\tlist();\n\t\t\tconsole.log(\"indexDB打开成功\")\n\t\t}\n\t\t//监听打开失败\n\t\tres.onerror=()=>{\n\t\t\tconsole.log(\"indexDB打开失败\")\n\t\t}\n\t\t//监听创建（数据库升级事件）\n        //初次创建数据库会执行这个事件\n\t\tres.onupgradeneeded=(res)=>{\n\t\t\tdb = event.target.result;\n\t\t\t//创建一个表\n\t\t\t//自动生成组件  自增\n\t\t\t// var objectStore = db.createObjectStore('person',{ autoIncrement: true });\n\t\t\t//person表   主键id\n\t\t\tlet objectStore=db.createObjectStore(\"person\",{keyPath:\"id\"});\n\t\t\t//创建索引\n\t\t\tobjectStore.createIndex('name', 'name', { unique: false });\n\t\t\t// console.log(objectStore)\n\t\t}\n\n\t\t\n\t\t//添加\n\t\tfunction add(id) {\n\t\t\t//新建一个事务。新建时必须指定表格名称和操作模式（\"只读\"或\"读写\"）\n\t\t\tlet res=db.transaction([\"person\"],\"readwrite\");\n\t\t\t//打开表\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\t//添加\n\t\t\tlet create=tab.add({id:id,name:\"张三\",sex:\"男\",age:15});\n\t\t\t//监听添加成功/失败\n\t\t\tcreate.onsuccess=()=>{\n\t\t\t\tconsole.log(\"添加成功\")\n\t\t\t}\n\t\t\tcreate.onerror=()=>{\n\t\t\t\tconsole.log(\"添加失败\")\n\t\t\t}\n\t\t\tconsole.log(tab)\n\t\t}\n\t\t//获取记录\n\t\tfunction read(){\n\t\t\tlet res=db.transaction([\"person\"]);\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet get=tab.get(1)\n\t\t\tget.onsuccess=()=>{\n\t\t\t\tlet data=get.result;\n\t\t\t\tconsole.log(data)\n\t\t\t}\n\t\t\tget.onerror=()=>{\n\t\t\t\tconsole.log(\"获取数据失败\")\n\t\t\t}\n\t\t}\n\t\t//修改\n\t\tfunction put(){\n\t\t\tlet res=db.transaction([\"person\"],\"readwrite\");\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet update=tab.put({id:1,name:\"王五\",sex:\"女\",age:22})\n\t\t\tupdate.onsuccess=()=>{\n\t\t\t\tconsole.log(\"数据更新成功\");\n\t\t\t}\n\t\t\tupdate.onerror=()=>{\n\t\t\t\tconsole.log(\"数据更新失败\");\n\t\t\t}\n\t\t}\n\t\t//删除\n\t\tfunction del(){\n\t\t\tlet res=db.transaction([\"person\"],\"readwrite\");\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet d=tab.delete(1);\n\t\t\td.onsuccess=()=>{\n\t\t\t\tconsole.log(\"数据删除成功\");\n\t\t\t}\n\t\t}\n\t\t//列表获取\n\t\tfunction list(){\n\t\t\tlet res=db.transaction([\"person\"]);\n\t\t\tlet tab=res.objectStore(\"person\");\n\t\t\tlet cursor=tab.openCursor()\n\t\t\tcursor.onsuccess=(e)=>{\n\t\t\t\tlet data=e.target.result;\n\t\t\t\tif(data){\n\t\t\t\t\tconsole.log(data.value)\n\t\t\t\t\tdata.continue();\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log(\"没有更多数据了\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n","slug":"Browser-WebStorage","published":1,"updated":"2021-12-02T07:27:47.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lo0013dswkbqc17pzt","content":"<h1 id=\"浏览器：WebStorage\"><a href=\"#浏览器：WebStorage\" class=\"headerlink\" title=\"浏览器：WebStorage\"></a>浏览器：WebStorage</h1><p>WebStorage网页存储，用于在前端存储数据，常见的有<code>Cookie</code>、<code>LocalStorage</code>、<code>SessionStorage</code>、<code>IndexDB</code></p>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p><strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong></p>\n<p>当一个用户登录之后，HTTP是无状态的并不知道用户已经登录，需要一个东西来保存这个状态，这个就是Cookie。</p>\n<p>Cookie就是维护客户端与服务器之间的一个状态，通常服务器将某个表示状态的数据进行加密，通过响应头<code>set-cookie</code>返回给客户端，然后客户端保存。</p>\n<p>Cookie并不会一直保存在客户端，可以设置一个过期时间，如果不设置过期时间，那么就是会话级别的，网页已关闭就删除</p>\n<p>Cookie可以用来共享数据，但是受<code>同源策略</code>影响，只能在同源的网页才能获取到一样的cookie</p>\n<p>缺点：</p>\n<ul>\n<li><p>只能是字符串，并且只能保存4kb的内容</p>\n</li>\n<li><p>没有自己的api，需要用户自己封装</p>\n</li>\n<li><p>在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积</p>\n</li>\n<li><p>不安全，如果不设置<code>http-only</code>攻击者可以使用JavaScript就可以获取到Cookie实施<code>XSS攻击</code></p>\n<blockquote>\n<p>相关属性</p>\n<p><strong>http-only</strong>：不能使用Javascript访问cookie，减少<code>XSS攻击</code></p>\n<p><strong>secure</strong>：只能在协议为HTTPS的请求中携带</p>\n<p><strong>same-site</strong>：规定浏览其不能再跨域请求中携带cookie，减少<code>crsf攻击</code></p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cookie = <span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span>;<span class=\"comment\">//获取cookie</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span> = <span class=\"string\">&#x27;color:blue;&#x27;</span> + cookie;<span class=\"comment\">//设置cookie</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>cookie和session的区别？</p>\n<p>答：</p>\n<ul>\n<li><p>单个cookie保存的数据不能超过4kb；session大小没有限制。</p>\n</li>\n<li><p>cookie保存在浏览器，session保存在服务器</p>\n</li>\n<li><p>session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p>\n<p>在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"LocalStorage-SessionStorage\"><a href=\"#LocalStorage-SessionStorage\" class=\"headerlink\" title=\"LocalStorage/SessionStorage\"></a>LocalStorage/SessionStorage</h2><p>两者的特点：</p>\n<ul>\n<li>大小为5M左右</li>\n<li>仅在客户端使用，不和服务端进行通信</li>\n<li>接口封装较好，有自己的api</li>\n<li>受同源策略影响</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>SessionStorage是会话级别网页关闭就会清除，而LocalStorage需要手动清除，不然一直存在</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"property\">setItem</span>（<span class=\"string\">&#x27;name&#x27;</span>,<span class=\"string\">&#x27;world&#x27;</span>）</span><br><span class=\"line\">sessionStorage.<span class=\"property\">setItem</span>（<span class=\"string\">&#x27;gender&#x27;</span>,<span class=\"string\">&#x27;female&#x27;</span>）</span><br><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> gender=sessionStorage.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;gender&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IndexDB\"><a href=\"#IndexDB\" class=\"headerlink\" title=\"IndexDB\"></a>IndexDB</h2><p>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>\n<ul>\n<li><strong>window.indexedDB.open</strong>打开一个数据库,onsuccess、onerror、onupgradeneeded监听一个数据库的成功、失败、新建（升级），接受两个参数（数据库名，版本（默认1，新建1））</li>\n<li><strong>db.createObjectStore</strong>创建一个表</li>\n<li><strong>objectStore.createIndex</strong>创建索引</li>\n<li><strong>db.transaction</strong>创建一个事务</li>\n<li><strong>objectStore.add</strong>添加数据</li>\n<li><strong>objectStore.put</strong>修改数据</li>\n<li><strong>objectStore.delete</strong>删除数据</li>\n<li><strong>objectStore.get</strong>获取数据</li>\n<li><strong>objectStore.openCursor</strong>打开列表指针</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//打开一个数据库</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> res = <span class=\"variable language_\">window</span>.<span class=\"property\">indexedDB</span>.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;db&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> db;</span><br><span class=\"line\">\t\t<span class=\"comment\">//监听打开成功</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果数据库存在会执行这个事件，而不会执行onupgradeneeded</span></span><br><span class=\"line\">\t\tres.<span class=\"property\">onsuccess</span>=<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\tdb=res.<span class=\"property\">result</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"title function_\">add</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">add</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">add</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// put()</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// read()</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// del()</span></span><br><span class=\"line\">\t\t\t<span class=\"title function_\">list</span>();</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;indexDB打开成功&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//监听打开失败</span></span><br><span class=\"line\">\t\tres.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;indexDB打开失败&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//监听创建（数据库升级事件）</span></span><br><span class=\"line\">        <span class=\"comment\">//初次创建数据库会执行这个事件</span></span><br><span class=\"line\">\t\tres.<span class=\"property\">onupgradeneeded</span>=<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\tdb = event.<span class=\"property\">target</span>.<span class=\"property\">result</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//创建一个表</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//自动生成组件  自增</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// var objectStore = db.createObjectStore(&#x27;person&#x27;,&#123; autoIncrement: true &#125;);</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//person表   主键id</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> objectStore=db.<span class=\"title function_\">createObjectStore</span>(<span class=\"string\">&quot;person&quot;</span>,&#123;<span class=\"attr\">keyPath</span>:<span class=\"string\">&quot;id&quot;</span>&#125;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//创建索引</span></span><br><span class=\"line\">\t\t\tobjectStore.<span class=\"title function_\">createIndex</span>(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>, &#123; <span class=\"attr\">unique</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// console.log(objectStore)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//添加</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">id</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//新建一个事务。新建时必须指定表格名称和操作模式（&quot;只读&quot;或&quot;读写&quot;）</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>],<span class=\"string\">&quot;readwrite&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//打开表</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//添加</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> create=tab.<span class=\"title function_\">add</span>(&#123;<span class=\"attr\">id</span>:id,<span class=\"attr\">name</span>:<span class=\"string\">&quot;张三&quot;</span>,<span class=\"attr\">sex</span>:<span class=\"string\">&quot;男&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//监听添加成功/失败</span></span><br><span class=\"line\">\t\t\tcreate.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;添加成功&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcreate.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;添加失败&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tab)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取记录</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">read</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> get=tab.<span class=\"title function_\">get</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tget.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> data=get.<span class=\"property\">result</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tget.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;获取数据失败&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//修改</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">put</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>],<span class=\"string\">&quot;readwrite&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> update=tab.<span class=\"title function_\">put</span>(&#123;<span class=\"attr\">id</span>:<span class=\"number\">1</span>,<span class=\"attr\">name</span>:<span class=\"string\">&quot;王五&quot;</span>,<span class=\"attr\">sex</span>:<span class=\"string\">&quot;女&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">22</span>&#125;)</span><br><span class=\"line\">\t\t\tupdate.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;数据更新成功&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tupdate.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;数据更新失败&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//删除</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">del</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>],<span class=\"string\">&quot;readwrite&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> d=tab.<span class=\"title function_\">delete</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\td.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;数据删除成功&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//列表获取</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">list</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> cursor=tab.<span class=\"title function_\">openCursor</span>()</span><br><span class=\"line\">\t\t\tcursor.<span class=\"property\">onsuccess</span>=<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> data=e.<span class=\"property\">target</span>.<span class=\"property\">result</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(data)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">value</span>)</span><br><span class=\"line\">\t\t\t\t\tdata.<span class=\"title function_\">continue</span>();</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;没有更多数据了&quot;</span>)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器：WebStorage\"><a href=\"#浏览器：WebStorage\" class=\"headerlink\" title=\"浏览器：WebStorage\"></a>浏览器：WebStorage</h1><p>WebStorage网页存储，用于在前端存储数据，常见的有<code>Cookie</code>、<code>LocalStorage</code>、<code>SessionStorage</code>、<code>IndexDB</code></p>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p><strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong></p>\n<p>当一个用户登录之后，HTTP是无状态的并不知道用户已经登录，需要一个东西来保存这个状态，这个就是Cookie。</p>\n<p>Cookie就是维护客户端与服务器之间的一个状态，通常服务器将某个表示状态的数据进行加密，通过响应头<code>set-cookie</code>返回给客户端，然后客户端保存。</p>\n<p>Cookie并不会一直保存在客户端，可以设置一个过期时间，如果不设置过期时间，那么就是会话级别的，网页已关闭就删除</p>\n<p>Cookie可以用来共享数据，但是受<code>同源策略</code>影响，只能在同源的网页才能获取到一样的cookie</p>\n<p>缺点：</p>\n<ul>\n<li><p>只能是字符串，并且只能保存4kb的内容</p>\n</li>\n<li><p>没有自己的api，需要用户自己封装</p>\n</li>\n<li><p>在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积</p>\n</li>\n<li><p>不安全，如果不设置<code>http-only</code>攻击者可以使用JavaScript就可以获取到Cookie实施<code>XSS攻击</code></p>\n<blockquote>\n<p>相关属性</p>\n<p><strong>http-only</strong>：不能使用Javascript访问cookie，减少<code>XSS攻击</code></p>\n<p><strong>secure</strong>：只能在协议为HTTPS的请求中携带</p>\n<p><strong>same-site</strong>：规定浏览其不能再跨域请求中携带cookie，减少<code>crsf攻击</code></p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cookie = <span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span>;<span class=\"comment\">//获取cookie</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span> = <span class=\"string\">&#x27;color:blue;&#x27;</span> + cookie;<span class=\"comment\">//设置cookie</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>cookie和session的区别？</p>\n<p>答：</p>\n<ul>\n<li><p>单个cookie保存的数据不能超过4kb；session大小没有限制。</p>\n</li>\n<li><p>cookie保存在浏览器，session保存在服务器</p>\n</li>\n<li><p>session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p>\n<p>在客户端发送的每一个请求时，cookie必须同时发送给服务器，增加请求的体积</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"LocalStorage-SessionStorage\"><a href=\"#LocalStorage-SessionStorage\" class=\"headerlink\" title=\"LocalStorage/SessionStorage\"></a>LocalStorage/SessionStorage</h2><p>两者的特点：</p>\n<ul>\n<li>大小为5M左右</li>\n<li>仅在客户端使用，不和服务端进行通信</li>\n<li>接口封装较好，有自己的api</li>\n<li>受同源策略影响</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>SessionStorage是会话级别网页关闭就会清除，而LocalStorage需要手动清除，不然一直存在</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"property\">setItem</span>（<span class=\"string\">&#x27;name&#x27;</span>,<span class=\"string\">&#x27;world&#x27;</span>）</span><br><span class=\"line\">sessionStorage.<span class=\"property\">setItem</span>（<span class=\"string\">&#x27;gender&#x27;</span>,<span class=\"string\">&#x27;female&#x27;</span>）</span><br><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> gender=sessionStorage.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;gender&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IndexDB\"><a href=\"#IndexDB\" class=\"headerlink\" title=\"IndexDB\"></a>IndexDB</h2><p>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">浏览器数据库 IndexedDB 入门教程</a></p>\n<ul>\n<li><strong>window.indexedDB.open</strong>打开一个数据库,onsuccess、onerror、onupgradeneeded监听一个数据库的成功、失败、新建（升级），接受两个参数（数据库名，版本（默认1，新建1））</li>\n<li><strong>db.createObjectStore</strong>创建一个表</li>\n<li><strong>objectStore.createIndex</strong>创建索引</li>\n<li><strong>db.transaction</strong>创建一个事务</li>\n<li><strong>objectStore.add</strong>添加数据</li>\n<li><strong>objectStore.put</strong>修改数据</li>\n<li><strong>objectStore.delete</strong>删除数据</li>\n<li><strong>objectStore.get</strong>获取数据</li>\n<li><strong>objectStore.openCursor</strong>打开列表指针</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//打开一个数据库</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> res = <span class=\"variable language_\">window</span>.<span class=\"property\">indexedDB</span>.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;db&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> db;</span><br><span class=\"line\">\t\t<span class=\"comment\">//监听打开成功</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果数据库存在会执行这个事件，而不会执行onupgradeneeded</span></span><br><span class=\"line\">\t\tres.<span class=\"property\">onsuccess</span>=<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\tdb=res.<span class=\"property\">result</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"title function_\">add</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">add</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\t<span class=\"title function_\">add</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// put()</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// read()</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// del()</span></span><br><span class=\"line\">\t\t\t<span class=\"title function_\">list</span>();</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;indexDB打开成功&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//监听打开失败</span></span><br><span class=\"line\">\t\tres.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;indexDB打开失败&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//监听创建（数据库升级事件）</span></span><br><span class=\"line\">        <span class=\"comment\">//初次创建数据库会执行这个事件</span></span><br><span class=\"line\">\t\tres.<span class=\"property\">onupgradeneeded</span>=<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\tdb = event.<span class=\"property\">target</span>.<span class=\"property\">result</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//创建一个表</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//自动生成组件  自增</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// var objectStore = db.createObjectStore(&#x27;person&#x27;,&#123; autoIncrement: true &#125;);</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//person表   主键id</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> objectStore=db.<span class=\"title function_\">createObjectStore</span>(<span class=\"string\">&quot;person&quot;</span>,&#123;<span class=\"attr\">keyPath</span>:<span class=\"string\">&quot;id&quot;</span>&#125;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//创建索引</span></span><br><span class=\"line\">\t\t\tobjectStore.<span class=\"title function_\">createIndex</span>(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>, &#123; <span class=\"attr\">unique</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// console.log(objectStore)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//添加</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">id</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//新建一个事务。新建时必须指定表格名称和操作模式（&quot;只读&quot;或&quot;读写&quot;）</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>],<span class=\"string\">&quot;readwrite&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//打开表</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//添加</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> create=tab.<span class=\"title function_\">add</span>(&#123;<span class=\"attr\">id</span>:id,<span class=\"attr\">name</span>:<span class=\"string\">&quot;张三&quot;</span>,<span class=\"attr\">sex</span>:<span class=\"string\">&quot;男&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//监听添加成功/失败</span></span><br><span class=\"line\">\t\t\tcreate.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;添加成功&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcreate.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;添加失败&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tab)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取记录</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">read</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> get=tab.<span class=\"title function_\">get</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tget.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> data=get.<span class=\"property\">result</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tget.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;获取数据失败&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//修改</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">put</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>],<span class=\"string\">&quot;readwrite&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> update=tab.<span class=\"title function_\">put</span>(&#123;<span class=\"attr\">id</span>:<span class=\"number\">1</span>,<span class=\"attr\">name</span>:<span class=\"string\">&quot;王五&quot;</span>,<span class=\"attr\">sex</span>:<span class=\"string\">&quot;女&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">22</span>&#125;)</span><br><span class=\"line\">\t\t\tupdate.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;数据更新成功&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tupdate.<span class=\"property\">onerror</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;数据更新失败&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//删除</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">del</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>],<span class=\"string\">&quot;readwrite&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> d=tab.<span class=\"title function_\">delete</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\td.<span class=\"property\">onsuccess</span>=<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;数据删除成功&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//列表获取</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">function</span> <span class=\"title function_\">list</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> res=db.<span class=\"title function_\">transaction</span>([<span class=\"string\">&quot;person&quot;</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> tab=res.<span class=\"title function_\">objectStore</span>(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> cursor=tab.<span class=\"title function_\">openCursor</span>()</span><br><span class=\"line\">\t\t\tcursor.<span class=\"property\">onsuccess</span>=<span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> data=e.<span class=\"property\">target</span>.<span class=\"property\">result</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(data)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">value</span>)</span><br><span class=\"line\">\t\t\t\t\tdata.<span class=\"title function_\">continue</span>();</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;没有更多数据了&quot;</span>)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"浏览器：渲染流程","date":"2021-11-28T02:26:10.000Z","description":"学习总结","cover":"https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg","_content":"# 浏览器：渲染流程\n\n当请求结果的`content-type=text/html`时，浏览器就会将资源交给渲染引擎进行渲染，大概流程如下：\n\n![XI.png](https://i.loli.net/2021/11/29/He5XDZG9rFTqMva.png)\n\n\n\n## 一、解析HTML\n\n浏览器接收到的HTML是字节流的形式，首先会对其进行词法分析，将其转换为一个个的`token`,分为`Tag Token `和`文本 Token`,而，`Tag token`又分为`StartTag`和`EndTag`\n\n**HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。**\n\n举个例子：\n\n```html\n<html>\n    <boby>\n    \t<div>1</div>\n        <div>test</div>\n    </boby>\n</html>\n```\n\n解析为：\n\n![img](http://blog.poetries.top/img-repo/2019/11/58.png)\n\n## 二、构建DOM树\n\n在解析的时候，就开始构建DOM树，步骤如下：\n\n* 如果压入到栈中的是`StartTag Token`，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。\n* 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。\n\n- 如果分词器解析出来的是`EndTag `标签，比如是 `EndTag` div，HTML 解析器会查看 Token 栈顶的元素是否是 `StarTag` div，如果是，就将 `StartTag` div 从栈中弹出，表示该 div 元素解析完成。\n\n通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。\n\n![img](https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png)\n\n## 三、构建CSS规则树\n\n1. **把CSS转换为浏览器能够理解的结构**\n\n   浏览器同样不能识别CSS格式的文档，需要将其转换为如下一样的格式：\n\n   ![](https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png)\n\n   可以控制台中输入`document.styleSheets`就可以看到当前网页的所有样式了\n\n2. **转换样式表中的属性值，使其标准化**\n\n   CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。\n\n   其中像em、rem、%等大小单位，都会通过计算转换为px，而颜色会转换为对应的rgb\n\n3. **计算出DOM树中每个节点的具体样式**\n\n   在计算每个节点的具体样式的时候，需要注意样式的`继承`和`层叠`规则\n\n   * **继承**\n\n     CSS中有很多样式时可以继承的比如`font-size`，举个例子：\n\n     我们给`boby`设置一个`font-size:20px`的样式，那么它的所有子元素都会具有这么一个样式\n\n   * **层叠**\n\n     **层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法**。\n\n## 四、生成布局树\n\n布局树只包括可见的节点，会忽略不可见的节点，比如设置了`display:none;`样式的节点\n\n并且计算出每个节点具体的坐标位置，以便后面绘制时使用\n\n## 五、分层\n\n一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）\n\n**拥有层叠上下文属性提升为单独的一个图层**：明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性。\n\n**需要剪裁（clip）的地方也会被创建为图层**：把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。\n\n## 六、图层绘制\n\n在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制\n\n渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表\n\n比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。\n\n你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表\n\n![img](https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png)\n\n##  七、栅格化（raster）操作\n\n当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程\n\n所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的\n\n通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。\n\n## 八、合成和显示\n\n一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。\n\n浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。\n\n![](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)\n\n总结流程：\n\n- 渲染进程将HTML内容转换为能够读懂的DOM树结构。\n- 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。\n- 创建布局树，并计算元素的布局信息。\n- 对布局树进行分层，并生成分层树。\n- 为每个图层生成绘制列表，并将其提交到合成线程。\n- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。\n- 合成线程发送绘制图块命令DrawQuad给浏览器进程。\n- 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上\n\n> 重绘和重排的区别？\n>\n> 答：重排需要走完整个渲染流程，重绘不需要走布局流程（生成布局树、分层）\n\n","source":"_posts/Browser-Render _Process.md","raw":"---\ntitle: 浏览器：渲染流程\ndate: 2021-11-28 10:26:10\ncategories: 浏览器\ntags: [浏览器]\ndescription: 学习总结\ncover: https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg\n---\n# 浏览器：渲染流程\n\n当请求结果的`content-type=text/html`时，浏览器就会将资源交给渲染引擎进行渲染，大概流程如下：\n\n![XI.png](https://i.loli.net/2021/11/29/He5XDZG9rFTqMva.png)\n\n\n\n## 一、解析HTML\n\n浏览器接收到的HTML是字节流的形式，首先会对其进行词法分析，将其转换为一个个的`token`,分为`Tag Token `和`文本 Token`,而，`Tag token`又分为`StartTag`和`EndTag`\n\n**HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。**\n\n举个例子：\n\n```html\n<html>\n    <boby>\n    \t<div>1</div>\n        <div>test</div>\n    </boby>\n</html>\n```\n\n解析为：\n\n![img](http://blog.poetries.top/img-repo/2019/11/58.png)\n\n## 二、构建DOM树\n\n在解析的时候，就开始构建DOM树，步骤如下：\n\n* 如果压入到栈中的是`StartTag Token`，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。\n* 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。\n\n- 如果分词器解析出来的是`EndTag `标签，比如是 `EndTag` div，HTML 解析器会查看 Token 栈顶的元素是否是 `StarTag` div，如果是，就将 `StartTag` div 从栈中弹出，表示该 div 元素解析完成。\n\n通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。\n\n![img](https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png)\n\n## 三、构建CSS规则树\n\n1. **把CSS转换为浏览器能够理解的结构**\n\n   浏览器同样不能识别CSS格式的文档，需要将其转换为如下一样的格式：\n\n   ![](https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png)\n\n   可以控制台中输入`document.styleSheets`就可以看到当前网页的所有样式了\n\n2. **转换样式表中的属性值，使其标准化**\n\n   CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。\n\n   其中像em、rem、%等大小单位，都会通过计算转换为px，而颜色会转换为对应的rgb\n\n3. **计算出DOM树中每个节点的具体样式**\n\n   在计算每个节点的具体样式的时候，需要注意样式的`继承`和`层叠`规则\n\n   * **继承**\n\n     CSS中有很多样式时可以继承的比如`font-size`，举个例子：\n\n     我们给`boby`设置一个`font-size:20px`的样式，那么它的所有子元素都会具有这么一个样式\n\n   * **层叠**\n\n     **层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法**。\n\n## 四、生成布局树\n\n布局树只包括可见的节点，会忽略不可见的节点，比如设置了`display:none;`样式的节点\n\n并且计算出每个节点具体的坐标位置，以便后面绘制时使用\n\n## 五、分层\n\n一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）\n\n**拥有层叠上下文属性提升为单独的一个图层**：明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性。\n\n**需要剪裁（clip）的地方也会被创建为图层**：把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。\n\n## 六、图层绘制\n\n在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制\n\n渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表\n\n比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。\n\n你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表\n\n![img](https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png)\n\n##  七、栅格化（raster）操作\n\n当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程\n\n所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的\n\n通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。\n\n## 八、合成和显示\n\n一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。\n\n浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。\n\n![](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)\n\n总结流程：\n\n- 渲染进程将HTML内容转换为能够读懂的DOM树结构。\n- 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。\n- 创建布局树，并计算元素的布局信息。\n- 对布局树进行分层，并生成分层树。\n- 为每个图层生成绘制列表，并将其提交到合成线程。\n- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。\n- 合成线程发送绘制图块命令DrawQuad给浏览器进程。\n- 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上\n\n> 重绘和重排的区别？\n>\n> 答：重排需要走完整个渲染流程，重绘不需要走布局流程（生成布局树、分层）\n\n","slug":"Browser-Render _Process","published":1,"updated":"2021-12-02T07:26:53.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lp0018dswkckxd01t4","content":"<h1 id=\"浏览器：渲染流程\"><a href=\"#浏览器：渲染流程\" class=\"headerlink\" title=\"浏览器：渲染流程\"></a>浏览器：渲染流程</h1><p>当请求结果的<code>content-type=text/html</code>时，浏览器就会将资源交给渲染引擎进行渲染，大概流程如下：</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2021/11/29/He5XDZG9rFTqMva.png\" alt=\"XI.png\"></p>\n<h2 id=\"一、解析HTML\"><a href=\"#一、解析HTML\" class=\"headerlink\" title=\"一、解析HTML\"></a>一、解析HTML</h2><p>浏览器接收到的HTML是字节流的形式，首先会对其进行词法分析，将其转换为一个个的<code>token</code>,分为<code>Tag Token</code>和<code>文本 Token</code>,而，<code>Tag token</code>又分为<code>StartTag</code>和<code>EndTag</code></p>\n<p><strong>HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。</strong></p>\n<p>举个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">boby</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">boby</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解析为：</p>\n<p><img src= \"/img/loading.gif\" data-src=\"http://blog.poetries.top/img-repo/2019/11/58.png\" alt=\"img\"></p>\n<h2 id=\"二、构建DOM树\"><a href=\"#二、构建DOM树\" class=\"headerlink\" title=\"二、构建DOM树\"></a>二、构建DOM树</h2><p>在解析的时候，就开始构建DOM树，步骤如下：</p>\n<ul>\n<li>如果压入到栈中的是<code>StartTag Token</code>，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>\n<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>\n</ul>\n<ul>\n<li>如果分词器解析出来的是<code>EndTag</code>标签，比如是 <code>EndTag</code> div，HTML 解析器会查看 Token 栈顶的元素是否是 <code>StarTag</code> div，如果是，就将 <code>StartTag</code> div 从栈中弹出，表示该 div 元素解析完成。</li>\n</ul>\n<p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png\" alt=\"img\"></p>\n<h2 id=\"三、构建CSS规则树\"><a href=\"#三、构建CSS规则树\" class=\"headerlink\" title=\"三、构建CSS规则树\"></a>三、构建CSS规则树</h2><ol>\n<li><p><strong>把CSS转换为浏览器能够理解的结构</strong></p>\n<p>浏览器同样不能识别CSS格式的文档，需要将其转换为如下一样的格式：</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png\" alt=\"\"></p>\n<p>可以控制台中输入<code>document.styleSheets</code>就可以看到当前网页的所有样式了</p>\n</li>\n<li><p><strong>转换样式表中的属性值，使其标准化</strong></p>\n<p>CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>\n<p>其中像em、rem、%等大小单位，都会通过计算转换为px，而颜色会转换为对应的rgb</p>\n</li>\n<li><p><strong>计算出DOM树中每个节点的具体样式</strong></p>\n<p>在计算每个节点的具体样式的时候，需要注意样式的<code>继承</code>和<code>层叠</code>规则</p>\n<ul>\n<li><p><strong>继承</strong></p>\n<p>CSS中有很多样式时可以继承的比如<code>font-size</code>，举个例子：</p>\n<p>我们给<code>boby</code>设置一个<code>font-size:20px</code>的样式，那么它的所有子元素都会具有这么一个样式</p>\n</li>\n<li><p><strong>层叠</strong></p>\n<p><strong>层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、生成布局树\"><a href=\"#四、生成布局树\" class=\"headerlink\" title=\"四、生成布局树\"></a>四、生成布局树</h2><p>布局树只包括可见的节点，会忽略不可见的节点，比如设置了<code>display:none;</code>样式的节点</p>\n<p>并且计算出每个节点具体的坐标位置，以便后面绘制时使用</p>\n<h2 id=\"五、分层\"><a href=\"#五、分层\" class=\"headerlink\" title=\"五、分层\"></a>五、分层</h2><p>一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</p>\n<p><strong>拥有层叠上下文属性提升为单独的一个图层</strong>：明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性。</p>\n<p><strong>需要剪裁（clip）的地方也会被创建为图层</strong>：把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。</p>\n<h2 id=\"六、图层绘制\"><a href=\"#六、图层绘制\" class=\"headerlink\" title=\"六、图层绘制\"></a>六、图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</p>\n<p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表</p>\n<p>比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>\n<p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png\" alt=\"img\"></p>\n<h2 id=\"七、栅格化（raster）操作\"><a href=\"#七、栅格化（raster）操作\" class=\"headerlink\" title=\"七、栅格化（raster）操作\"></a>七、栅格化（raster）操作</h2><p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</p>\n<p>所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</p>\n<p>通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。</p>\n<h2 id=\"八、合成和显示\"><a href=\"#八、合成和显示\" class=\"headerlink\" title=\"八、合成和显示\"></a>八、合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>\n<p>浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png\" alt=\"\"></p>\n<p>总结流程：</p>\n<ul>\n<li>渲染进程将HTML内容转换为能够读懂的DOM树结构。</li>\n<li>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li>\n<li>创建布局树，并计算元素的布局信息。</li>\n<li>对布局树进行分层，并生成分层树。</li>\n<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>\n<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>\n<li>合成线程发送绘制图块命令DrawQuad给浏览器进程。</li>\n<li>浏览器进程根据DrawQuad消息生成页面，并显示到显示器上</li>\n</ul>\n<blockquote>\n<p>重绘和重排的区别？</p>\n<p>答：重排需要走完整个渲染流程，重绘不需要走布局流程（生成布局树、分层）</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器：渲染流程\"><a href=\"#浏览器：渲染流程\" class=\"headerlink\" title=\"浏览器：渲染流程\"></a>浏览器：渲染流程</h1><p>当请求结果的<code>content-type=text/html</code>时，浏览器就会将资源交给渲染引擎进行渲染，大概流程如下：</p>\n<p><img src=\"https://i.loli.net/2021/11/29/He5XDZG9rFTqMva.png\" alt=\"XI.png\"></p>\n<h2 id=\"一、解析HTML\"><a href=\"#一、解析HTML\" class=\"headerlink\" title=\"一、解析HTML\"></a>一、解析HTML</h2><p>浏览器接收到的HTML是字节流的形式，首先会对其进行词法分析，将其转换为一个个的<code>token</code>,分为<code>Tag Token</code>和<code>文本 Token</code>,而，<code>Tag token</code>又分为<code>StartTag</code>和<code>EndTag</code></p>\n<p><strong>HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。</strong></p>\n<p>举个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">boby</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">boby</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解析为：</p>\n<p><img src=\"http://blog.poetries.top/img-repo/2019/11/58.png\" alt=\"img\"></p>\n<h2 id=\"二、构建DOM树\"><a href=\"#二、构建DOM树\" class=\"headerlink\" title=\"二、构建DOM树\"></a>二、构建DOM树</h2><p>在解析的时候，就开始构建DOM树，步骤如下：</p>\n<ul>\n<li>如果压入到栈中的是<code>StartTag Token</code>，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>\n<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>\n</ul>\n<ul>\n<li>如果分词器解析出来的是<code>EndTag</code>标签，比如是 <code>EndTag</code> div，HTML 解析器会查看 Token 栈顶的元素是否是 <code>StarTag</code> div，如果是，就将 <code>StartTag</code> div 从栈中弹出，表示该 div 元素解析完成。</li>\n</ul>\n<p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png\" alt=\"img\"></p>\n<h2 id=\"三、构建CSS规则树\"><a href=\"#三、构建CSS规则树\" class=\"headerlink\" title=\"三、构建CSS规则树\"></a>三、构建CSS规则树</h2><ol>\n<li><p><strong>把CSS转换为浏览器能够理解的结构</strong></p>\n<p>浏览器同样不能识别CSS格式的文档，需要将其转换为如下一样的格式：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png\" alt=\"\"></p>\n<p>可以控制台中输入<code>document.styleSheets</code>就可以看到当前网页的所有样式了</p>\n</li>\n<li><p><strong>转换样式表中的属性值，使其标准化</strong></p>\n<p>CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>\n<p>其中像em、rem、%等大小单位，都会通过计算转换为px，而颜色会转换为对应的rgb</p>\n</li>\n<li><p><strong>计算出DOM树中每个节点的具体样式</strong></p>\n<p>在计算每个节点的具体样式的时候，需要注意样式的<code>继承</code>和<code>层叠</code>规则</p>\n<ul>\n<li><p><strong>继承</strong></p>\n<p>CSS中有很多样式时可以继承的比如<code>font-size</code>，举个例子：</p>\n<p>我们给<code>boby</code>设置一个<code>font-size:20px</code>的样式，那么它的所有子元素都会具有这么一个样式</p>\n</li>\n<li><p><strong>层叠</strong></p>\n<p><strong>层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、生成布局树\"><a href=\"#四、生成布局树\" class=\"headerlink\" title=\"四、生成布局树\"></a>四、生成布局树</h2><p>布局树只包括可见的节点，会忽略不可见的节点，比如设置了<code>display:none;</code>样式的节点</p>\n<p>并且计算出每个节点具体的坐标位置，以便后面绘制时使用</p>\n<h2 id=\"五、分层\"><a href=\"#五、分层\" class=\"headerlink\" title=\"五、分层\"></a>五、分层</h2><p>一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</p>\n<p><strong>拥有层叠上下文属性提升为单独的一个图层</strong>：明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性。</p>\n<p><strong>需要剪裁（clip）的地方也会被创建为图层</strong>：把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。</p>\n<h2 id=\"六、图层绘制\"><a href=\"#六、图层绘制\" class=\"headerlink\" title=\"六、图层绘制\"></a>六、图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</p>\n<p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表</p>\n<p>比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>\n<p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png\" alt=\"img\"></p>\n<h2 id=\"七、栅格化（raster）操作\"><a href=\"#七、栅格化（raster）操作\" class=\"headerlink\" title=\"七、栅格化（raster）操作\"></a>七、栅格化（raster）操作</h2><p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</p>\n<p>所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</p>\n<p>通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。</p>\n<h2 id=\"八、合成和显示\"><a href=\"#八、合成和显示\" class=\"headerlink\" title=\"八、合成和显示\"></a>八、合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>\n<p>浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png\" alt=\"\"></p>\n<p>总结流程：</p>\n<ul>\n<li>渲染进程将HTML内容转换为能够读懂的DOM树结构。</li>\n<li>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li>\n<li>创建布局树，并计算元素的布局信息。</li>\n<li>对布局树进行分层，并生成分层树。</li>\n<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>\n<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>\n<li>合成线程发送绘制图块命令DrawQuad给浏览器进程。</li>\n<li>浏览器进程根据DrawQuad消息生成页面，并显示到显示器上</li>\n</ul>\n<blockquote>\n<p>重绘和重排的区别？</p>\n<p>答：重排需要走完整个渲染流程，重绘不需要走布局流程（生成布局树、分层）</p>\n</blockquote>\n"},{"title":"浏览器：Web安全","date":"2021-11-30T05:56:10.000Z","description":"学习总结","cover":"https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg","_content":"\n# 浏览器：Web安全\n\n前端需要注意的常见的攻击类型及防御\n\n## 一、XSS\n\n跨站脚本攻击（Cross Site Script）,本来缩写是 CSS, 但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区分，所以安全领域叫做 “XSS”；\n\nXSS攻击，通常是指攻击者通过 “HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，对用户的浏览器进行控制或者获取用户的敏感信息（Cookie, SessionID等）的一种攻击方式。\n\n危害：\n\n* **可以窃取 cookie信息**。恶意 JavaScript可以通过 ”doccument.cookie“获取cookie信息，然后通过 XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到用户的cookie信息之后，就可以在其他电脑上模拟用户的登陆，然后进行转账操作。\n\n* **可以监听用户行为**。恶意JavaScript可以使用 \"addEventListener\"接口来监听键盘事件，比如可以获取用户输入的银行卡等信息，又可以做很多违法的事情。\n\n* 可以**修改DOM** 伪造假的登陆窗口，用来欺骗用户输入用户名和密码等信息。\n\n* 还可以在页面内生成浮窗广告，这些广告会严重影响用户体验。\n\nXSS攻击可以分为三类：反射型，存储型，基于DOM型(DOM based XSS)\n\n* **反射型**\n\n  恶意脚本作为网络请求的一部分。\n\n  比如，一个`get`请求，客户端向服务器传递一个`username`，而服务器没有做任何处理，直接将`username`拼接以HTML的方式返回\n\n  ```js\n  http://127.0.0.1:3000?userName=\n  ```\n\n  ```js\n  app.use(async ctx => {\n      // ctx.body 即服务端响应的数据\n      ctx.body = '<h1>' + ctx.query.userName + '</h1>';\n  })\n  ```\n\n  当我们正常传递`username`并没有任何问题，但是如果攻击者这样传递\n\n  ```js\n  http://127.0.0.1:3000?userName=<script>alert('你完了')</script>\n  ```\n\n  那么`script`就会被执行，攻击者就可以拿到你的信息，比如`token`，`cookie`\n\n* **存储型**\n\n  存储型会把用户输入的数据“存储”在服务器。\n\n  比较常见的一个场景就是，攻击者在社区或论坛写下一篇包含恶意 JavaScript代码的博客文章或评论，文章或评论发表后，所有访问该博客文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。\n\n  比如，在某个评论里面，攻击者🧛‍♀️输入\n\n  ```js\n  <script>alert('你完了')</script>\n  ```\n\n  然后保存，而服务器没有做任何处理，在浏览评论的时候，将所有评论查询回来，前端进行展示，那么这个`script`就会被执行，你就被攻击了🤦‍♂️\n\n### 防御方法\n\n* **HttpOnly**\n\n  由于很多XSS攻击都是来盗用`Cookie`的，因此可以通过 使用HttpOnly属性来防止直接通过 `document.cookie` 来获取 `cookie`。\n\n  需要注意的一点是：HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。\n\n* **输入和输出检查**\n\n  永远不要相信用户的输入\n\n  输入检查一般是检查用户输入的数据是都包含一些特殊字符，如 `<`、`>`, `'`及`\"`等。如果发现特殊字符，则将这些字符过滤或编码。这种可以称为 “XSS Filter”。\n\n  针对HTML代码的编码方式是 HtmlEncode（是一种函数实现，将字符串转成 HTMLEntrities）\n\n* **利用CSP**\n\n  [CSP](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP) (Content Security Policy) 即内容安全策略，是一种可信白名单机制，可以在服务端配置浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。\n\n  通常可以通过两种方式来开启 CSP：\n\n  - 设置 HTTP Header 的 `Content-Security-Policy`\n\n  ```\n  Content-Security-Policy: default-src 'self'; // 只允许加载本站资源\n  Content-Security-Policy: img-src https://*  // 只允许加载 HTTPS 协议图片\n  Content-Security-Policy: child-src 'none'    // 允许加载任何来源框架\n  ```\n\n  - 设置 meta 标签的方式\n\n  ```\n  <meta \n  \thttp-equiv=\"Content-Security-Policy\" \n  \tcontent=\"default-src 'self'; img-src https://*; child-src 'none';\">\n  ```\n\n\n\n## 二、CSRF\n\n跨站请求伪造（Cross Site Request Forgery），是指黑客诱导用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。`CSRF`攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事。\n\n要完成一次`CSRF`攻击,受害者依次完成两个步骤:\n\n1. 登录受信任网站A，并在本地生成Cookie\n2. 在不登出A的情况，访问危险网站B\n\n举个例子啊🎈\n\n现在有一个银行的转账链接\n\n```js\nhttp://127.0.0.1:3000/getMoney\n```\n\n你首先登录了这个银行的网站向看看余额，但是页面突然出现一个图片，点击就给188，结果你点击了\n\n而这个图片并不只是图片，而是攻击者构建的一个转账的一个请求，你点击之后自动的发送了请求，并且携带了你在这个银行登录的信息cookie，服务器验证cookie发现是我的客户，结果就执行了转账的操作，你的钱就到了攻击者的钱包里\n\n### 防御方法\n\n* **利用cookie的SameSite**\n\n  SameSite有3个值： Strict, Lax和None\n\n  1. Strict。浏览器会完全禁止第三方cookie。比如a.com的页面中访问 b.com 的资源，那么a.com中的cookie不会被发送到 b.com服务器，只有从b.com的站点去请求b.com的资源，才会带上这些Cookie\n  2. Lax。相对宽松一些，在跨站点的情况下，从第三方站点链接打开和从第三方站点提交 Get方式的表单这两种方式都会携带Cookie。但如果在第三方站点中使用POST方法或者通过 img、Iframe等标签加载的URL，这些场景都不会携带Cookie。\n  3. None。任何情况下都会发送 Cookie数据\n\n  我们可以根据实际情况将一些关键的Cookie设置 Stirct或者 Lax模式，这样在跨站点请求的时候，这些关键的Cookie就不会被发送到服务器，从而使得CSRF攻击失败\n\n* **验证请求的来源点**\n\n  由于CSRF攻击大多来自第三方站点，可以在服务器端验证请求来源的站点，禁止第三方站点的请求。 可以通过HTTP请求头中的 Referer和Origin属性。\n\n* **验证码**\n\n  应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。**但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码**。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。\n\n* **Anti CSRF Token**\n\n  发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。\n\n\n\n","source":"_posts/Browser-Web_safety .md","raw":"---\ntitle: 浏览器：Web安全\ndate: 2021-11-30 13:56:10\ncategories: 浏览器\ntags: [浏览器]\ndescription: 学习总结\ncover: https://i.loli.net/2021/12/02/mBz6KwcxZdS7q5G.jpg\n---\n\n# 浏览器：Web安全\n\n前端需要注意的常见的攻击类型及防御\n\n## 一、XSS\n\n跨站脚本攻击（Cross Site Script）,本来缩写是 CSS, 但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区分，所以安全领域叫做 “XSS”；\n\nXSS攻击，通常是指攻击者通过 “HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，对用户的浏览器进行控制或者获取用户的敏感信息（Cookie, SessionID等）的一种攻击方式。\n\n危害：\n\n* **可以窃取 cookie信息**。恶意 JavaScript可以通过 ”doccument.cookie“获取cookie信息，然后通过 XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到用户的cookie信息之后，就可以在其他电脑上模拟用户的登陆，然后进行转账操作。\n\n* **可以监听用户行为**。恶意JavaScript可以使用 \"addEventListener\"接口来监听键盘事件，比如可以获取用户输入的银行卡等信息，又可以做很多违法的事情。\n\n* 可以**修改DOM** 伪造假的登陆窗口，用来欺骗用户输入用户名和密码等信息。\n\n* 还可以在页面内生成浮窗广告，这些广告会严重影响用户体验。\n\nXSS攻击可以分为三类：反射型，存储型，基于DOM型(DOM based XSS)\n\n* **反射型**\n\n  恶意脚本作为网络请求的一部分。\n\n  比如，一个`get`请求，客户端向服务器传递一个`username`，而服务器没有做任何处理，直接将`username`拼接以HTML的方式返回\n\n  ```js\n  http://127.0.0.1:3000?userName=\n  ```\n\n  ```js\n  app.use(async ctx => {\n      // ctx.body 即服务端响应的数据\n      ctx.body = '<h1>' + ctx.query.userName + '</h1>';\n  })\n  ```\n\n  当我们正常传递`username`并没有任何问题，但是如果攻击者这样传递\n\n  ```js\n  http://127.0.0.1:3000?userName=<script>alert('你完了')</script>\n  ```\n\n  那么`script`就会被执行，攻击者就可以拿到你的信息，比如`token`，`cookie`\n\n* **存储型**\n\n  存储型会把用户输入的数据“存储”在服务器。\n\n  比较常见的一个场景就是，攻击者在社区或论坛写下一篇包含恶意 JavaScript代码的博客文章或评论，文章或评论发表后，所有访问该博客文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。\n\n  比如，在某个评论里面，攻击者🧛‍♀️输入\n\n  ```js\n  <script>alert('你完了')</script>\n  ```\n\n  然后保存，而服务器没有做任何处理，在浏览评论的时候，将所有评论查询回来，前端进行展示，那么这个`script`就会被执行，你就被攻击了🤦‍♂️\n\n### 防御方法\n\n* **HttpOnly**\n\n  由于很多XSS攻击都是来盗用`Cookie`的，因此可以通过 使用HttpOnly属性来防止直接通过 `document.cookie` 来获取 `cookie`。\n\n  需要注意的一点是：HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。\n\n* **输入和输出检查**\n\n  永远不要相信用户的输入\n\n  输入检查一般是检查用户输入的数据是都包含一些特殊字符，如 `<`、`>`, `'`及`\"`等。如果发现特殊字符，则将这些字符过滤或编码。这种可以称为 “XSS Filter”。\n\n  针对HTML代码的编码方式是 HtmlEncode（是一种函数实现，将字符串转成 HTMLEntrities）\n\n* **利用CSP**\n\n  [CSP](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP) (Content Security Policy) 即内容安全策略，是一种可信白名单机制，可以在服务端配置浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。\n\n  通常可以通过两种方式来开启 CSP：\n\n  - 设置 HTTP Header 的 `Content-Security-Policy`\n\n  ```\n  Content-Security-Policy: default-src 'self'; // 只允许加载本站资源\n  Content-Security-Policy: img-src https://*  // 只允许加载 HTTPS 协议图片\n  Content-Security-Policy: child-src 'none'    // 允许加载任何来源框架\n  ```\n\n  - 设置 meta 标签的方式\n\n  ```\n  <meta \n  \thttp-equiv=\"Content-Security-Policy\" \n  \tcontent=\"default-src 'self'; img-src https://*; child-src 'none';\">\n  ```\n\n\n\n## 二、CSRF\n\n跨站请求伪造（Cross Site Request Forgery），是指黑客诱导用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。`CSRF`攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事。\n\n要完成一次`CSRF`攻击,受害者依次完成两个步骤:\n\n1. 登录受信任网站A，并在本地生成Cookie\n2. 在不登出A的情况，访问危险网站B\n\n举个例子啊🎈\n\n现在有一个银行的转账链接\n\n```js\nhttp://127.0.0.1:3000/getMoney\n```\n\n你首先登录了这个银行的网站向看看余额，但是页面突然出现一个图片，点击就给188，结果你点击了\n\n而这个图片并不只是图片，而是攻击者构建的一个转账的一个请求，你点击之后自动的发送了请求，并且携带了你在这个银行登录的信息cookie，服务器验证cookie发现是我的客户，结果就执行了转账的操作，你的钱就到了攻击者的钱包里\n\n### 防御方法\n\n* **利用cookie的SameSite**\n\n  SameSite有3个值： Strict, Lax和None\n\n  1. Strict。浏览器会完全禁止第三方cookie。比如a.com的页面中访问 b.com 的资源，那么a.com中的cookie不会被发送到 b.com服务器，只有从b.com的站点去请求b.com的资源，才会带上这些Cookie\n  2. Lax。相对宽松一些，在跨站点的情况下，从第三方站点链接打开和从第三方站点提交 Get方式的表单这两种方式都会携带Cookie。但如果在第三方站点中使用POST方法或者通过 img、Iframe等标签加载的URL，这些场景都不会携带Cookie。\n  3. None。任何情况下都会发送 Cookie数据\n\n  我们可以根据实际情况将一些关键的Cookie设置 Stirct或者 Lax模式，这样在跨站点请求的时候，这些关键的Cookie就不会被发送到服务器，从而使得CSRF攻击失败\n\n* **验证请求的来源点**\n\n  由于CSRF攻击大多来自第三方站点，可以在服务器端验证请求来源的站点，禁止第三方站点的请求。 可以通过HTTP请求头中的 Referer和Origin属性。\n\n* **验证码**\n\n  应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。**但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码**。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。\n\n* **Anti CSRF Token**\n\n  发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。\n\n\n\n","slug":"Browser-Web_safety ","published":1,"updated":"2021-12-02T07:26:59.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lq001bdswkfmzah7x2","content":"<h1 id=\"浏览器：Web安全\"><a href=\"#浏览器：Web安全\" class=\"headerlink\" title=\"浏览器：Web安全\"></a>浏览器：Web安全</h1><p>前端需要注意的常见的攻击类型及防御</p>\n<h2 id=\"一、XSS\"><a href=\"#一、XSS\" class=\"headerlink\" title=\"一、XSS\"></a>一、XSS</h2><p>跨站脚本攻击（Cross Site Script）,本来缩写是 CSS, 但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区分，所以安全领域叫做 “XSS”；</p>\n<p>XSS攻击，通常是指攻击者通过 “HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，对用户的浏览器进行控制或者获取用户的敏感信息（Cookie, SessionID等）的一种攻击方式。</p>\n<p>危害：</p>\n<ul>\n<li><p><strong>可以窃取 cookie信息</strong>。恶意 JavaScript可以通过 ”doccument.cookie“获取cookie信息，然后通过 XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到用户的cookie信息之后，就可以在其他电脑上模拟用户的登陆，然后进行转账操作。</p>\n</li>\n<li><p><strong>可以监听用户行为</strong>。恶意JavaScript可以使用 “addEventListener”接口来监听键盘事件，比如可以获取用户输入的银行卡等信息，又可以做很多违法的事情。</p>\n</li>\n<li><p>可以<strong>修改DOM</strong> 伪造假的登陆窗口，用来欺骗用户输入用户名和密码等信息。</p>\n</li>\n<li><p>还可以在页面内生成浮窗广告，这些广告会严重影响用户体验。</p>\n</li>\n</ul>\n<p>XSS攻击可以分为三类：反射型，存储型，基于DOM型(DOM based XSS)</p>\n<ul>\n<li><p><strong>反射型</strong></p>\n<p>恶意脚本作为网络请求的一部分。</p>\n<p>比如，一个<code>get</code>请求，客户端向服务器传递一个<code>username</code>，而服务器没有做任何处理，直接将<code>username</code>拼接以HTML的方式返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000?userName=</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"keyword\">async</span> ctx =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ctx.body 即服务端响应的数据</span></span><br><span class=\"line\">    ctx.<span class=\"property\">body</span> = <span class=\"string\">&#x27;&lt;h1&gt;&#x27;</span> + ctx.<span class=\"property\">query</span>.<span class=\"property\">userName</span> + <span class=\"string\">&#x27;&lt;/h1&gt;&#x27;</span>;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当我们正常传递<code>username</code>并没有任何问题，但是如果攻击者这样传递</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000?userName=&lt;script&gt;alert(&#x27;你完了&#x27;)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么<code>script</code>就会被执行，攻击者就可以拿到你的信息，比如<code>token</code>，<code>cookie</code></p>\n</li>\n<li><p><strong>存储型</strong></p>\n<p>存储型会把用户输入的数据“存储”在服务器。</p>\n<p>比较常见的一个场景就是，攻击者在社区或论坛写下一篇包含恶意 JavaScript代码的博客文章或评论，文章或评论发表后，所有访问该博客文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</p>\n<p>比如，在某个评论里面，攻击者🧛‍♀️输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你完了&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后保存，而服务器没有做任何处理，在浏览评论的时候，将所有评论查询回来，前端进行展示，那么这个<code>script</code>就会被执行，你就被攻击了🤦‍♂️</p>\n</li>\n</ul>\n<h3 id=\"防御方法\"><a href=\"#防御方法\" class=\"headerlink\" title=\"防御方法\"></a>防御方法</h3><ul>\n<li><p><strong>HttpOnly</strong></p>\n<p>由于很多XSS攻击都是来盗用<code>Cookie</code>的，因此可以通过 使用HttpOnly属性来防止直接通过 <code>document.cookie</code> 来获取 <code>cookie</code>。</p>\n<p>需要注意的一点是：HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>\n</li>\n<li><p><strong>输入和输出检查</strong></p>\n<p>永远不要相信用户的输入</p>\n<p>输入检查一般是检查用户输入的数据是都包含一些特殊字符，如 <code>&lt;</code>、<code>&gt;</code>, <code>&#39;</code>及<code>&quot;</code>等。如果发现特殊字符，则将这些字符过滤或编码。这种可以称为 “XSS Filter”。</p>\n<p>针对HTML代码的编码方式是 HtmlEncode（是一种函数实现，将字符串转成 HTMLEntrities）</p>\n</li>\n<li><p><strong>利用CSP</strong></p>\n<p><a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP\">CSP</a> (Content Security Policy) 即内容安全策略，是一种可信白名单机制，可以在服务端配置浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。</p>\n<p>通常可以通过两种方式来开启 CSP：</p>\n<ul>\n<li>设置 HTTP Header 的 <code>Content-Security-Policy</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Security-Policy: default-src &#x27;self&#x27;; // 只允许加载本站资源</span><br><span class=\"line\">Content-Security-Policy: img-src https://*  // 只允许加载 HTTPS 协议图片</span><br><span class=\"line\">Content-Security-Policy: child-src &#x27;none&#x27;    // 允许加载任何来源框架</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置 meta 标签的方式</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta </span><br><span class=\"line\">\thttp-equiv=&quot;Content-Security-Policy&quot; </span><br><span class=\"line\">\tcontent=&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<h2 id=\"二、CSRF\"><a href=\"#二、CSRF\" class=\"headerlink\" title=\"二、CSRF\"></a>二、CSRF</h2><p>跨站请求伪造（Cross Site Request Forgery），是指黑客诱导用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。<code>CSRF</code>攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事。</p>\n<p>要完成一次<code>CSRF</code>攻击,受害者依次完成两个步骤:</p>\n<ol>\n<li>登录受信任网站A，并在本地生成Cookie</li>\n<li>在不登出A的情况，访问危险网站B</li>\n</ol>\n<p>举个例子啊🎈</p>\n<p>现在有一个银行的转账链接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000/getMoney</span></span><br></pre></td></tr></table></figure>\n\n<p>你首先登录了这个银行的网站向看看余额，但是页面突然出现一个图片，点击就给188，结果你点击了</p>\n<p>而这个图片并不只是图片，而是攻击者构建的一个转账的一个请求，你点击之后自动的发送了请求，并且携带了你在这个银行登录的信息cookie，服务器验证cookie发现是我的客户，结果就执行了转账的操作，你的钱就到了攻击者的钱包里</p>\n<h3 id=\"防御方法-1\"><a href=\"#防御方法-1\" class=\"headerlink\" title=\"防御方法\"></a>防御方法</h3><ul>\n<li><p><strong>利用cookie的SameSite</strong></p>\n<p>SameSite有3个值： Strict, Lax和None</p>\n<ol>\n<li>Strict。浏览器会完全禁止第三方cookie。比如a.com的页面中访问 b.com 的资源，那么a.com中的cookie不会被发送到 b.com服务器，只有从b.com的站点去请求b.com的资源，才会带上这些Cookie</li>\n<li>Lax。相对宽松一些，在跨站点的情况下，从第三方站点链接打开和从第三方站点提交 Get方式的表单这两种方式都会携带Cookie。但如果在第三方站点中使用POST方法或者通过 img、Iframe等标签加载的URL，这些场景都不会携带Cookie。</li>\n<li>None。任何情况下都会发送 Cookie数据</li>\n</ol>\n<p>我们可以根据实际情况将一些关键的Cookie设置 Stirct或者 Lax模式，这样在跨站点请求的时候，这些关键的Cookie就不会被发送到服务器，从而使得CSRF攻击失败</p>\n</li>\n<li><p><strong>验证请求的来源点</strong></p>\n<p>由于CSRF攻击大多来自第三方站点，可以在服务器端验证请求来源的站点，禁止第三方站点的请求。 可以通过HTTP请求头中的 Referer和Origin属性。</p>\n</li>\n<li><p><strong>验证码</strong></p>\n<p>应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。<strong>但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码</strong>。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p>\n</li>\n<li><p><strong>Anti CSRF Token</strong></p>\n<p>发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器：Web安全\"><a href=\"#浏览器：Web安全\" class=\"headerlink\" title=\"浏览器：Web安全\"></a>浏览器：Web安全</h1><p>前端需要注意的常见的攻击类型及防御</p>\n<h2 id=\"一、XSS\"><a href=\"#一、XSS\" class=\"headerlink\" title=\"一、XSS\"></a>一、XSS</h2><p>跨站脚本攻击（Cross Site Script）,本来缩写是 CSS, 但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区分，所以安全领域叫做 “XSS”；</p>\n<p>XSS攻击，通常是指攻击者通过 “HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，对用户的浏览器进行控制或者获取用户的敏感信息（Cookie, SessionID等）的一种攻击方式。</p>\n<p>危害：</p>\n<ul>\n<li><p><strong>可以窃取 cookie信息</strong>。恶意 JavaScript可以通过 ”doccument.cookie“获取cookie信息，然后通过 XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到用户的cookie信息之后，就可以在其他电脑上模拟用户的登陆，然后进行转账操作。</p>\n</li>\n<li><p><strong>可以监听用户行为</strong>。恶意JavaScript可以使用 “addEventListener”接口来监听键盘事件，比如可以获取用户输入的银行卡等信息，又可以做很多违法的事情。</p>\n</li>\n<li><p>可以<strong>修改DOM</strong> 伪造假的登陆窗口，用来欺骗用户输入用户名和密码等信息。</p>\n</li>\n<li><p>还可以在页面内生成浮窗广告，这些广告会严重影响用户体验。</p>\n</li>\n</ul>\n<p>XSS攻击可以分为三类：反射型，存储型，基于DOM型(DOM based XSS)</p>\n<ul>\n<li><p><strong>反射型</strong></p>\n<p>恶意脚本作为网络请求的一部分。</p>\n<p>比如，一个<code>get</code>请求，客户端向服务器传递一个<code>username</code>，而服务器没有做任何处理，直接将<code>username</code>拼接以HTML的方式返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000?userName=</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"keyword\">async</span> ctx =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ctx.body 即服务端响应的数据</span></span><br><span class=\"line\">    ctx.<span class=\"property\">body</span> = <span class=\"string\">&#x27;&lt;h1&gt;&#x27;</span> + ctx.<span class=\"property\">query</span>.<span class=\"property\">userName</span> + <span class=\"string\">&#x27;&lt;/h1&gt;&#x27;</span>;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当我们正常传递<code>username</code>并没有任何问题，但是如果攻击者这样传递</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000?userName=&lt;script&gt;alert(&#x27;你完了&#x27;)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么<code>script</code>就会被执行，攻击者就可以拿到你的信息，比如<code>token</code>，<code>cookie</code></p>\n</li>\n<li><p><strong>存储型</strong></p>\n<p>存储型会把用户输入的数据“存储”在服务器。</p>\n<p>比较常见的一个场景就是，攻击者在社区或论坛写下一篇包含恶意 JavaScript代码的博客文章或评论，文章或评论发表后，所有访问该博客文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</p>\n<p>比如，在某个评论里面，攻击者🧛‍♀️输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你完了&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后保存，而服务器没有做任何处理，在浏览评论的时候，将所有评论查询回来，前端进行展示，那么这个<code>script</code>就会被执行，你就被攻击了🤦‍♂️</p>\n</li>\n</ul>\n<h3 id=\"防御方法\"><a href=\"#防御方法\" class=\"headerlink\" title=\"防御方法\"></a>防御方法</h3><ul>\n<li><p><strong>HttpOnly</strong></p>\n<p>由于很多XSS攻击都是来盗用<code>Cookie</code>的，因此可以通过 使用HttpOnly属性来防止直接通过 <code>document.cookie</code> 来获取 <code>cookie</code>。</p>\n<p>需要注意的一点是：HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>\n</li>\n<li><p><strong>输入和输出检查</strong></p>\n<p>永远不要相信用户的输入</p>\n<p>输入检查一般是检查用户输入的数据是都包含一些特殊字符，如 <code>&lt;</code>、<code>&gt;</code>, <code>&#39;</code>及<code>&quot;</code>等。如果发现特殊字符，则将这些字符过滤或编码。这种可以称为 “XSS Filter”。</p>\n<p>针对HTML代码的编码方式是 HtmlEncode（是一种函数实现，将字符串转成 HTMLEntrities）</p>\n</li>\n<li><p><strong>利用CSP</strong></p>\n<p><a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP\">CSP</a> (Content Security Policy) 即内容安全策略，是一种可信白名单机制，可以在服务端配置浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。</p>\n<p>通常可以通过两种方式来开启 CSP：</p>\n<ul>\n<li>设置 HTTP Header 的 <code>Content-Security-Policy</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Security-Policy: default-src &#x27;self&#x27;; // 只允许加载本站资源</span><br><span class=\"line\">Content-Security-Policy: img-src https://*  // 只允许加载 HTTPS 协议图片</span><br><span class=\"line\">Content-Security-Policy: child-src &#x27;none&#x27;    // 允许加载任何来源框架</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置 meta 标签的方式</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta </span><br><span class=\"line\">\thttp-equiv=&quot;Content-Security-Policy&quot; </span><br><span class=\"line\">\tcontent=&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<h2 id=\"二、CSRF\"><a href=\"#二、CSRF\" class=\"headerlink\" title=\"二、CSRF\"></a>二、CSRF</h2><p>跨站请求伪造（Cross Site Request Forgery），是指黑客诱导用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。<code>CSRF</code>攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事。</p>\n<p>要完成一次<code>CSRF</code>攻击,受害者依次完成两个步骤:</p>\n<ol>\n<li>登录受信任网站A，并在本地生成Cookie</li>\n<li>在不登出A的情况，访问危险网站B</li>\n</ol>\n<p>举个例子啊🎈</p>\n<p>现在有一个银行的转账链接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000/getMoney</span></span><br></pre></td></tr></table></figure>\n\n<p>你首先登录了这个银行的网站向看看余额，但是页面突然出现一个图片，点击就给188，结果你点击了</p>\n<p>而这个图片并不只是图片，而是攻击者构建的一个转账的一个请求，你点击之后自动的发送了请求，并且携带了你在这个银行登录的信息cookie，服务器验证cookie发现是我的客户，结果就执行了转账的操作，你的钱就到了攻击者的钱包里</p>\n<h3 id=\"防御方法-1\"><a href=\"#防御方法-1\" class=\"headerlink\" title=\"防御方法\"></a>防御方法</h3><ul>\n<li><p><strong>利用cookie的SameSite</strong></p>\n<p>SameSite有3个值： Strict, Lax和None</p>\n<ol>\n<li>Strict。浏览器会完全禁止第三方cookie。比如a.com的页面中访问 b.com 的资源，那么a.com中的cookie不会被发送到 b.com服务器，只有从b.com的站点去请求b.com的资源，才会带上这些Cookie</li>\n<li>Lax。相对宽松一些，在跨站点的情况下，从第三方站点链接打开和从第三方站点提交 Get方式的表单这两种方式都会携带Cookie。但如果在第三方站点中使用POST方法或者通过 img、Iframe等标签加载的URL，这些场景都不会携带Cookie。</li>\n<li>None。任何情况下都会发送 Cookie数据</li>\n</ol>\n<p>我们可以根据实际情况将一些关键的Cookie设置 Stirct或者 Lax模式，这样在跨站点请求的时候，这些关键的Cookie就不会被发送到服务器，从而使得CSRF攻击失败</p>\n</li>\n<li><p><strong>验证请求的来源点</strong></p>\n<p>由于CSRF攻击大多来自第三方站点，可以在服务器端验证请求来源的站点，禁止第三方站点的请求。 可以通过HTTP请求头中的 Referer和Origin属性。</p>\n</li>\n<li><p><strong>验证码</strong></p>\n<p>应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。<strong>但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码</strong>。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p>\n</li>\n<li><p><strong>Anti CSRF Token</strong></p>\n<p>发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>\n</li>\n</ul>\n"},{"title":"CSS-总结","date":"2022-04-15T03:32:20.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/04/15/EPRcslrZ5LCYQyB.jpg","_content":"\n# CSS-总结\n\n## 1、盒子模型\n\n**盒模型**分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分\n\n**盒模型**分为IE盒模型（border-box）、W3C标准盒模型（content-box）：\n\n* `IE盒模型`：属性width，height包含content、border和padding，指的是content\n  +padding+border。\n  \n* `W3C标准盒模型`：属性width，height只包含内容content，不包含border和padding\n\n可以通过修改元素的`box-sizing`属性来改变元素的盒模型。\n\n## 2、选择器\n\n常见的选择器有：\n\n* id选择器（#myid）\n* 类选择器（.myclassname）\n* 标签选择器（div,h1,p）\n* 后代选择器（h1 p）\n* 相邻后代选择器（子）选择器（ul>li）\n* 兄弟选择器（li~a）\n* 相邻兄弟选择器（li+a）\n* 属性选择器（a[rel=\"external\"]）\n* 伪类选择器（a:hover,li:nth-child）\n* 伪元素选择器（::before、::after）\n* 通配符选择器（*）\n\n## 3、优先级\n\nCSS的优先级是根据样式声明的特殊性值来判断的。\n\n优先级依次为：\n\n1. `!important`：优先级最高\n2. `行内样式`：记作`1000`\n3. `id选择器`：记作`100`\n4. `类、属性、伪类选择器`：记作`10`\n5. `伪元素、元素选择器`：记作`1`\n\n计算规则：\n\n**规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等\n级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。\n比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引\n入的顺序，后出现的规则的优先级最高。**\n\n## 4、伪类与伪元素\n\n**伪类和伪元素是用来修饰不在文档树中的部分**，比如，一句 话中的第一个字母，或者是列表中的第一个元素。\n\n* **伪类** 用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的\n元素时，我们可以通过:hover来描述这个元素的状态。\n  \n* **伪元素** 用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be\n  fore来在一个元素前增加一些文本，并为这些文本添加样式。\n\n单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）\n\n不过浏览器需要同时支持旧的已经存在的伪元素写法， 比如:first-line、:first-letter、:before、:after等\n\n## 5、BFC\n\n**块格式化上下文**（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒\n子的区域，也是浮动元素与其他元素的交互限定区域。\n\n特点：\n* BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。\n* 如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。\n\n创建条件:\n* 根元素或包含根元素的元素\n* 浮动元素`float!=none`的元素\n* 绝对定位元素`position = absolute|fixed`\n* `display=inline-block|flex|inine-flex|table-cell或table-caption`\n* `overflow!=visible`\n\n## 6、继承性\n\n在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。\n\n可继承的属性有：\n\n* 字体相关：font-family、font-style、font-size、font-weight 等；\n* 文本相关：text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、white-space、line-height、color 等；\n* 列表相关：list-style、list-style-image、list-style-type、list-style-position 等；\n* 其他属性：visibility、cursor 等；\n\n\n## 7、层叠上下文\n\n在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。\n\n产生层叠上下文：\n* html 文档根元素\n* 声明 position: absolute/relative 且 z-index 值不为 auto 的元素；\n* 声明 position: fixed/sticky 的元素；\n* flex 容器的子元素，且 z-index 值不为 auto；\n* grid 容器的子元素，且 z-index 值不为 auto；\n* opacity 属性值小于 1 的元素；\n* mix-blend-mode 属性值不为 normal 的元素；\n* 以下任意属性值不为 none 的元素：\n    * transform\n    * filter\n    * perspective\n    * clip-path\n    * mask / mask-image / mask-border\n* isolation 属性值为 isolate 的元素；\n* -webkit-overflow-scrolling 属性值为 touch 的元素；\n* will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；\n* contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。\n  \n#### 层叠顺序\n\n![](https://s2.loli.net/2022/04/15/1VK8anWoUEJCbPR.png)\n\n## 8、CSS3新特性\n\n* 新增各种CSS选择器  （:not(.input)：所有class不是“input”的节点）\n* 圆角    （border-radius:8px）\n* 多列布局  （multi-column layout）\n* 阴影和反射  （ShadowReflect）\n* 文字特效    （text-shadow）\n* 文字渲染    （Text-decoration）\n* 线性渐变    （gradient）\n* 旋转      （transform）\n* 缩放，定位，倾斜，动画，多背景\n\n## 9、Flex box（弹性盒布局模型）\n\nFlex是FlexibleBox的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex\n项目（flex item），简称\"项目\"。\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。\n\n常用属性：\n\n以下6个属性设置在容器上\n\n* flex-direction属性决定主轴的方向（即项目的排列方向）。\n* flex-wrap属性定义，如果一条轴线排不下，如何换行。\n* flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n* justify-content属性定义了项目在主轴上的对齐方式。\n* align-items属性定义项目在交叉轴上如何对齐。\n* align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n以下6个属性设置在项目上\n\n* order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n* flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n* flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n* flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认\n值为auto，即项目的本来大小。\n* flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。\n* align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父\n元素的align-items属性，如果没有父元素，则等同于stretch。\n  \n## 10、值和单位\n\nCSS 的声明是由属性和值组成的，而值的类型有许多种：\n\n* 数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；\n* 百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；\n* 颜色：用于指定 background-color、color 等；\n* 坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；\n* 函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；\n\n**单位**\n\n前置知识：\n\n1. 设备像素（Device pixels）\n\n设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思\n\n2. 设备像素比（DPR）\n\n设备像素比表示 1 个 CSS 像素等于几个物理像素。\n\n计算公式：DPR = 物理像素数 / 逻辑像素数；\n\n在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。\n\n* px\n\npx 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。\n\n但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。\n\n* em\n\nem 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：\n\n> 在 font-size 中使用是相对于父元素的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；\n>\n> 在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；\n\n* rem\n\nrem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。\n\n* vw/vh\n\nvw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：\n\n1vw = 视口宽度均分成 100 份中 1 份的长度；\n1vh = 视口高度均分成 100 份中 1 份的长度；\n\n在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。\n","source":"_posts/CSS-all.md","raw":"---\ntitle: CSS-总结\ndate: 2022-04-15 11:32:20\ncategories: CSS\ntags: [CSS]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/04/15/EPRcslrZ5LCYQyB.jpg\n---\n\n# CSS-总结\n\n## 1、盒子模型\n\n**盒模型**分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分\n\n**盒模型**分为IE盒模型（border-box）、W3C标准盒模型（content-box）：\n\n* `IE盒模型`：属性width，height包含content、border和padding，指的是content\n  +padding+border。\n  \n* `W3C标准盒模型`：属性width，height只包含内容content，不包含border和padding\n\n可以通过修改元素的`box-sizing`属性来改变元素的盒模型。\n\n## 2、选择器\n\n常见的选择器有：\n\n* id选择器（#myid）\n* 类选择器（.myclassname）\n* 标签选择器（div,h1,p）\n* 后代选择器（h1 p）\n* 相邻后代选择器（子）选择器（ul>li）\n* 兄弟选择器（li~a）\n* 相邻兄弟选择器（li+a）\n* 属性选择器（a[rel=\"external\"]）\n* 伪类选择器（a:hover,li:nth-child）\n* 伪元素选择器（::before、::after）\n* 通配符选择器（*）\n\n## 3、优先级\n\nCSS的优先级是根据样式声明的特殊性值来判断的。\n\n优先级依次为：\n\n1. `!important`：优先级最高\n2. `行内样式`：记作`1000`\n3. `id选择器`：记作`100`\n4. `类、属性、伪类选择器`：记作`10`\n5. `伪元素、元素选择器`：记作`1`\n\n计算规则：\n\n**规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等\n级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。\n比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引\n入的顺序，后出现的规则的优先级最高。**\n\n## 4、伪类与伪元素\n\n**伪类和伪元素是用来修饰不在文档树中的部分**，比如，一句 话中的第一个字母，或者是列表中的第一个元素。\n\n* **伪类** 用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的\n元素时，我们可以通过:hover来描述这个元素的状态。\n  \n* **伪元素** 用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be\n  fore来在一个元素前增加一些文本，并为这些文本添加样式。\n\n单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）\n\n不过浏览器需要同时支持旧的已经存在的伪元素写法， 比如:first-line、:first-letter、:before、:after等\n\n## 5、BFC\n\n**块格式化上下文**（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒\n子的区域，也是浮动元素与其他元素的交互限定区域。\n\n特点：\n* BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。\n* 如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。\n\n创建条件:\n* 根元素或包含根元素的元素\n* 浮动元素`float!=none`的元素\n* 绝对定位元素`position = absolute|fixed`\n* `display=inline-block|flex|inine-flex|table-cell或table-caption`\n* `overflow!=visible`\n\n## 6、继承性\n\n在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。\n\n可继承的属性有：\n\n* 字体相关：font-family、font-style、font-size、font-weight 等；\n* 文本相关：text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、white-space、line-height、color 等；\n* 列表相关：list-style、list-style-image、list-style-type、list-style-position 等；\n* 其他属性：visibility、cursor 等；\n\n\n## 7、层叠上下文\n\n在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。\n\n产生层叠上下文：\n* html 文档根元素\n* 声明 position: absolute/relative 且 z-index 值不为 auto 的元素；\n* 声明 position: fixed/sticky 的元素；\n* flex 容器的子元素，且 z-index 值不为 auto；\n* grid 容器的子元素，且 z-index 值不为 auto；\n* opacity 属性值小于 1 的元素；\n* mix-blend-mode 属性值不为 normal 的元素；\n* 以下任意属性值不为 none 的元素：\n    * transform\n    * filter\n    * perspective\n    * clip-path\n    * mask / mask-image / mask-border\n* isolation 属性值为 isolate 的元素；\n* -webkit-overflow-scrolling 属性值为 touch 的元素；\n* will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；\n* contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。\n  \n#### 层叠顺序\n\n![](https://s2.loli.net/2022/04/15/1VK8anWoUEJCbPR.png)\n\n## 8、CSS3新特性\n\n* 新增各种CSS选择器  （:not(.input)：所有class不是“input”的节点）\n* 圆角    （border-radius:8px）\n* 多列布局  （multi-column layout）\n* 阴影和反射  （ShadowReflect）\n* 文字特效    （text-shadow）\n* 文字渲染    （Text-decoration）\n* 线性渐变    （gradient）\n* 旋转      （transform）\n* 缩放，定位，倾斜，动画，多背景\n\n## 9、Flex box（弹性盒布局模型）\n\nFlex是FlexibleBox的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex\n项目（flex item），简称\"项目\"。\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。\n\n常用属性：\n\n以下6个属性设置在容器上\n\n* flex-direction属性决定主轴的方向（即项目的排列方向）。\n* flex-wrap属性定义，如果一条轴线排不下，如何换行。\n* flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n* justify-content属性定义了项目在主轴上的对齐方式。\n* align-items属性定义项目在交叉轴上如何对齐。\n* align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n以下6个属性设置在项目上\n\n* order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n* flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n* flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n* flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认\n值为auto，即项目的本来大小。\n* flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。\n* align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父\n元素的align-items属性，如果没有父元素，则等同于stretch。\n  \n## 10、值和单位\n\nCSS 的声明是由属性和值组成的，而值的类型有许多种：\n\n* 数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；\n* 百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；\n* 颜色：用于指定 background-color、color 等；\n* 坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；\n* 函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；\n\n**单位**\n\n前置知识：\n\n1. 设备像素（Device pixels）\n\n设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思\n\n2. 设备像素比（DPR）\n\n设备像素比表示 1 个 CSS 像素等于几个物理像素。\n\n计算公式：DPR = 物理像素数 / 逻辑像素数；\n\n在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。\n\n* px\n\npx 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。\n\n但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。\n\n* em\n\nem 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：\n\n> 在 font-size 中使用是相对于父元素的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；\n>\n> 在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；\n\n* rem\n\nrem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。\n\n* vw/vh\n\nvw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：\n\n1vw = 视口宽度均分成 100 份中 1 份的长度；\n1vh = 视口高度均分成 100 份中 1 份的长度；\n\n在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。\n","slug":"CSS-all","published":1,"updated":"2022-04-15T03:33:21.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lr001edswk33u37moy","content":"<h1 id=\"CSS-总结\"><a href=\"#CSS-总结\" class=\"headerlink\" title=\"CSS-总结\"></a>CSS-总结</h1><h2 id=\"1、盒子模型\"><a href=\"#1、盒子模型\" class=\"headerlink\" title=\"1、盒子模型\"></a>1、盒子模型</h2><p><strong>盒模型</strong>分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</p>\n<p><strong>盒模型</strong>分为IE盒模型（border-box）、W3C标准盒模型（content-box）：</p>\n<ul>\n<li><p><code>IE盒模型</code>：属性width，height包含content、border和padding，指的是content<br>+padding+border。</p>\n</li>\n<li><p><code>W3C标准盒模型</code>：属性width，height只包含内容content，不包含border和padding</p>\n</li>\n</ul>\n<p>可以通过修改元素的<code>box-sizing</code>属性来改变元素的盒模型。</p>\n<h2 id=\"2、选择器\"><a href=\"#2、选择器\" class=\"headerlink\" title=\"2、选择器\"></a>2、选择器</h2><p>常见的选择器有：</p>\n<ul>\n<li>id选择器（#myid）</li>\n<li>类选择器（.myclassname）</li>\n<li>标签选择器（div,h1,p）</li>\n<li>后代选择器（h1 p）</li>\n<li>相邻后代选择器（子）选择器（ul&gt;li）</li>\n<li>兄弟选择器（li~a）</li>\n<li>相邻兄弟选择器（li+a）</li>\n<li>属性选择器（a[rel=”external”]）</li>\n<li>伪类选择器（a:hover,li:nth-child）</li>\n<li>伪元素选择器（::before、::after）</li>\n<li>通配符选择器（*）</li>\n</ul>\n<h2 id=\"3、优先级\"><a href=\"#3、优先级\" class=\"headerlink\" title=\"3、优先级\"></a>3、优先级</h2><p>CSS的优先级是根据样式声明的特殊性值来判断的。</p>\n<p>优先级依次为：</p>\n<ol>\n<li><code>!important</code>：优先级最高</li>\n<li><code>行内样式</code>：记作<code>1000</code></li>\n<li><code>id选择器</code>：记作<code>100</code></li>\n<li><code>类、属性、伪类选择器</code>：记作<code>10</code></li>\n<li><code>伪元素、元素选择器</code>：记作<code>1</code></li>\n</ol>\n<p>计算规则：</p>\n<p><strong>规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等<br>级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。<br>比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引<br>入的顺序，后出现的规则的优先级最高。</strong></p>\n<h2 id=\"4、伪类与伪元素\"><a href=\"#4、伪类与伪元素\" class=\"headerlink\" title=\"4、伪类与伪元素\"></a>4、伪类与伪元素</h2><p><strong>伪类和伪元素是用来修饰不在文档树中的部分</strong>，比如，一句 话中的第一个字母，或者是列表中的第一个元素。</p>\n<ul>\n<li><p><strong>伪类</strong> 用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的<br>元素时，我们可以通过:hover来描述这个元素的状态。</p>\n</li>\n<li><p><strong>伪元素</strong> 用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be<br>fore来在一个元素前增加一些文本，并为这些文本添加样式。</p>\n</li>\n</ul>\n<p>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</p>\n<p>不过浏览器需要同时支持旧的已经存在的伪元素写法， 比如:first-line、:first-letter、:before、:after等</p>\n<h2 id=\"5、BFC\"><a href=\"#5、BFC\" class=\"headerlink\" title=\"5、BFC\"></a>5、BFC</h2><p><strong>块格式化上下文</strong>（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒<br>子的区域，也是浮动元素与其他元素的交互限定区域。</p>\n<p>特点：</p>\n<ul>\n<li>BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</li>\n<li>如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</li>\n</ul>\n<p>创建条件:</p>\n<ul>\n<li>根元素或包含根元素的元素</li>\n<li>浮动元素<code>float!=none</code>的元素</li>\n<li>绝对定位元素<code>position = absolute|fixed</code></li>\n<li><code>display=inline-block|flex|inine-flex|table-cell或table-caption</code></li>\n<li><code>overflow!=visible</code></li>\n</ul>\n<h2 id=\"6、继承性\"><a href=\"#6、继承性\" class=\"headerlink\" title=\"6、继承性\"></a>6、继承性</h2><p>在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。</p>\n<p>可继承的属性有：</p>\n<ul>\n<li>字体相关：font-family、font-style、font-size、font-weight 等；</li>\n<li>文本相关：text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、white-space、line-height、color 等；</li>\n<li>列表相关：list-style、list-style-image、list-style-type、list-style-position 等；</li>\n<li>其他属性：visibility、cursor 等；</li>\n</ul>\n<h2 id=\"7、层叠上下文\"><a href=\"#7、层叠上下文\" class=\"headerlink\" title=\"7、层叠上下文\"></a>7、层叠上下文</h2><p>在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。</p>\n<p>产生层叠上下文：</p>\n<ul>\n<li>html 文档根元素</li>\n<li>声明 position: absolute/relative 且 z-index 值不为 auto 的元素；</li>\n<li>声明 position: fixed/sticky 的元素；</li>\n<li>flex 容器的子元素，且 z-index 值不为 auto；</li>\n<li>grid 容器的子元素，且 z-index 值不为 auto；</li>\n<li>opacity 属性值小于 1 的元素；</li>\n<li>mix-blend-mode 属性值不为 normal 的元素；</li>\n<li>以下任意属性值不为 none 的元素：<ul>\n<li>transform</li>\n<li>filter</li>\n<li>perspective</li>\n<li>clip-path</li>\n<li>mask / mask-image / mask-border</li>\n</ul>\n</li>\n<li>isolation 属性值为 isolate 的元素；</li>\n<li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li>\n<li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</li>\n<li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li>\n</ul>\n<h4 id=\"层叠顺序\"><a href=\"#层叠顺序\" class=\"headerlink\" title=\"层叠顺序\"></a>层叠顺序</h4><p><img src= \"/img/loading.gif\" data-src=\"https://s2.loli.net/2022/04/15/1VK8anWoUEJCbPR.png\" alt=\"\"></p>\n<h2 id=\"8、CSS3新特性\"><a href=\"#8、CSS3新特性\" class=\"headerlink\" title=\"8、CSS3新特性\"></a>8、CSS3新特性</h2><ul>\n<li>新增各种CSS选择器  （:not(.input)：所有class不是“input”的节点）</li>\n<li>圆角    （border-radius:8px）</li>\n<li>多列布局  （multi-column layout）</li>\n<li>阴影和反射  （ShadowReflect）</li>\n<li>文字特效    （text-shadow）</li>\n<li>文字渲染    （Text-decoration）</li>\n<li>线性渐变    （gradient）</li>\n<li>旋转      （transform）</li>\n<li>缩放，定位，倾斜，动画，多背景</li>\n</ul>\n<h2 id=\"9、Flex-box（弹性盒布局模型）\"><a href=\"#9、Flex-box（弹性盒布局模型）\" class=\"headerlink\" title=\"9、Flex box（弹性盒布局模型）\"></a>9、Flex box（弹性盒布局模型）</h2><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex<br>项目（flex item），简称”项目”。</p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。</p>\n<p>常用属性：</p>\n<p>以下6个属性设置在容器上</p>\n<ul>\n<li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li>\n<li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li>\n<li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li>\n<li>justify-content属性定义了项目在主轴上的对齐方式。</li>\n<li>align-items属性定义项目在交叉轴上如何对齐。</li>\n<li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>\n</ul>\n<p>以下6个属性设置在项目上</p>\n<ul>\n<li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>\n<li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>\n<li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>\n<li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认<br>值为auto，即项目的本来大小。</li>\n<li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li>\n<li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父<br>元素的align-items属性，如果没有父元素，则等同于stretch。</li>\n</ul>\n<h2 id=\"10、值和单位\"><a href=\"#10、值和单位\" class=\"headerlink\" title=\"10、值和单位\"></a>10、值和单位</h2><p>CSS 的声明是由属性和值组成的，而值的类型有许多种：</p>\n<ul>\n<li>数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；</li>\n<li>百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；</li>\n<li>颜色：用于指定 background-color、color 等；</li>\n<li>坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；</li>\n<li>函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；</li>\n</ul>\n<p><strong>单位</strong></p>\n<p>前置知识：</p>\n<ol>\n<li>设备像素（Device pixels）</li>\n</ol>\n<p>设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思</p>\n<ol start=\"2\">\n<li>设备像素比（DPR）</li>\n</ol>\n<p>设备像素比表示 1 个 CSS 像素等于几个物理像素。</p>\n<p>计算公式：DPR = 物理像素数 / 逻辑像素数；</p>\n<p>在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。</p>\n<ul>\n<li>px</li>\n</ul>\n<p>px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。</p>\n<p>但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。</p>\n<ul>\n<li>em</li>\n</ul>\n<p>em 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：</p>\n<blockquote>\n<p>在 font-size 中使用是相对于父元素的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；</p>\n<p>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；</p>\n</blockquote>\n<ul>\n<li>rem</li>\n</ul>\n<p>rem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。</p>\n<ul>\n<li>vw/vh</li>\n</ul>\n<p>vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：</p>\n<p>1vw = 视口宽度均分成 100 份中 1 份的长度；<br>1vh = 视口高度均分成 100 份中 1 份的长度；</p>\n<p>在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS-总结\"><a href=\"#CSS-总结\" class=\"headerlink\" title=\"CSS-总结\"></a>CSS-总结</h1><h2 id=\"1、盒子模型\"><a href=\"#1、盒子模型\" class=\"headerlink\" title=\"1、盒子模型\"></a>1、盒子模型</h2><p><strong>盒模型</strong>分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</p>\n<p><strong>盒模型</strong>分为IE盒模型（border-box）、W3C标准盒模型（content-box）：</p>\n<ul>\n<li><p><code>IE盒模型</code>：属性width，height包含content、border和padding，指的是content<br>+padding+border。</p>\n</li>\n<li><p><code>W3C标准盒模型</code>：属性width，height只包含内容content，不包含border和padding</p>\n</li>\n</ul>\n<p>可以通过修改元素的<code>box-sizing</code>属性来改变元素的盒模型。</p>\n<h2 id=\"2、选择器\"><a href=\"#2、选择器\" class=\"headerlink\" title=\"2、选择器\"></a>2、选择器</h2><p>常见的选择器有：</p>\n<ul>\n<li>id选择器（#myid）</li>\n<li>类选择器（.myclassname）</li>\n<li>标签选择器（div,h1,p）</li>\n<li>后代选择器（h1 p）</li>\n<li>相邻后代选择器（子）选择器（ul&gt;li）</li>\n<li>兄弟选择器（li~a）</li>\n<li>相邻兄弟选择器（li+a）</li>\n<li>属性选择器（a[rel=”external”]）</li>\n<li>伪类选择器（a:hover,li:nth-child）</li>\n<li>伪元素选择器（::before、::after）</li>\n<li>通配符选择器（*）</li>\n</ul>\n<h2 id=\"3、优先级\"><a href=\"#3、优先级\" class=\"headerlink\" title=\"3、优先级\"></a>3、优先级</h2><p>CSS的优先级是根据样式声明的特殊性值来判断的。</p>\n<p>优先级依次为：</p>\n<ol>\n<li><code>!important</code>：优先级最高</li>\n<li><code>行内样式</code>：记作<code>1000</code></li>\n<li><code>id选择器</code>：记作<code>100</code></li>\n<li><code>类、属性、伪类选择器</code>：记作<code>10</code></li>\n<li><code>伪元素、元素选择器</code>：记作<code>1</code></li>\n</ol>\n<p>计算规则：</p>\n<p><strong>规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等<br>级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。<br>比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引<br>入的顺序，后出现的规则的优先级最高。</strong></p>\n<h2 id=\"4、伪类与伪元素\"><a href=\"#4、伪类与伪元素\" class=\"headerlink\" title=\"4、伪类与伪元素\"></a>4、伪类与伪元素</h2><p><strong>伪类和伪元素是用来修饰不在文档树中的部分</strong>，比如，一句 话中的第一个字母，或者是列表中的第一个元素。</p>\n<ul>\n<li><p><strong>伪类</strong> 用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的<br>元素时，我们可以通过:hover来描述这个元素的状态。</p>\n</li>\n<li><p><strong>伪元素</strong> 用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be<br>fore来在一个元素前增加一些文本，并为这些文本添加样式。</p>\n</li>\n</ul>\n<p>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</p>\n<p>不过浏览器需要同时支持旧的已经存在的伪元素写法， 比如:first-line、:first-letter、:before、:after等</p>\n<h2 id=\"5、BFC\"><a href=\"#5、BFC\" class=\"headerlink\" title=\"5、BFC\"></a>5、BFC</h2><p><strong>块格式化上下文</strong>（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒<br>子的区域，也是浮动元素与其他元素的交互限定区域。</p>\n<p>特点：</p>\n<ul>\n<li>BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</li>\n<li>如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</li>\n</ul>\n<p>创建条件:</p>\n<ul>\n<li>根元素或包含根元素的元素</li>\n<li>浮动元素<code>float!=none</code>的元素</li>\n<li>绝对定位元素<code>position = absolute|fixed</code></li>\n<li><code>display=inline-block|flex|inine-flex|table-cell或table-caption</code></li>\n<li><code>overflow!=visible</code></li>\n</ul>\n<h2 id=\"6、继承性\"><a href=\"#6、继承性\" class=\"headerlink\" title=\"6、继承性\"></a>6、继承性</h2><p>在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。</p>\n<p>可继承的属性有：</p>\n<ul>\n<li>字体相关：font-family、font-style、font-size、font-weight 等；</li>\n<li>文本相关：text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、white-space、line-height、color 等；</li>\n<li>列表相关：list-style、list-style-image、list-style-type、list-style-position 等；</li>\n<li>其他属性：visibility、cursor 等；</li>\n</ul>\n<h2 id=\"7、层叠上下文\"><a href=\"#7、层叠上下文\" class=\"headerlink\" title=\"7、层叠上下文\"></a>7、层叠上下文</h2><p>在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。</p>\n<p>产生层叠上下文：</p>\n<ul>\n<li>html 文档根元素</li>\n<li>声明 position: absolute/relative 且 z-index 值不为 auto 的元素；</li>\n<li>声明 position: fixed/sticky 的元素；</li>\n<li>flex 容器的子元素，且 z-index 值不为 auto；</li>\n<li>grid 容器的子元素，且 z-index 值不为 auto；</li>\n<li>opacity 属性值小于 1 的元素；</li>\n<li>mix-blend-mode 属性值不为 normal 的元素；</li>\n<li>以下任意属性值不为 none 的元素：<ul>\n<li>transform</li>\n<li>filter</li>\n<li>perspective</li>\n<li>clip-path</li>\n<li>mask / mask-image / mask-border</li>\n</ul>\n</li>\n<li>isolation 属性值为 isolate 的元素；</li>\n<li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li>\n<li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</li>\n<li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li>\n</ul>\n<h4 id=\"层叠顺序\"><a href=\"#层叠顺序\" class=\"headerlink\" title=\"层叠顺序\"></a>层叠顺序</h4><p><img src=\"https://s2.loli.net/2022/04/15/1VK8anWoUEJCbPR.png\" alt=\"\"></p>\n<h2 id=\"8、CSS3新特性\"><a href=\"#8、CSS3新特性\" class=\"headerlink\" title=\"8、CSS3新特性\"></a>8、CSS3新特性</h2><ul>\n<li>新增各种CSS选择器  （:not(.input)：所有class不是“input”的节点）</li>\n<li>圆角    （border-radius:8px）</li>\n<li>多列布局  （multi-column layout）</li>\n<li>阴影和反射  （ShadowReflect）</li>\n<li>文字特效    （text-shadow）</li>\n<li>文字渲染    （Text-decoration）</li>\n<li>线性渐变    （gradient）</li>\n<li>旋转      （transform）</li>\n<li>缩放，定位，倾斜，动画，多背景</li>\n</ul>\n<h2 id=\"9、Flex-box（弹性盒布局模型）\"><a href=\"#9、Flex-box（弹性盒布局模型）\" class=\"headerlink\" title=\"9、Flex box（弹性盒布局模型）\"></a>9、Flex box（弹性盒布局模型）</h2><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex<br>项目（flex item），简称”项目”。</p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。</p>\n<p>常用属性：</p>\n<p>以下6个属性设置在容器上</p>\n<ul>\n<li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li>\n<li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li>\n<li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li>\n<li>justify-content属性定义了项目在主轴上的对齐方式。</li>\n<li>align-items属性定义项目在交叉轴上如何对齐。</li>\n<li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>\n</ul>\n<p>以下6个属性设置在项目上</p>\n<ul>\n<li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>\n<li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>\n<li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>\n<li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认<br>值为auto，即项目的本来大小。</li>\n<li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li>\n<li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父<br>元素的align-items属性，如果没有父元素，则等同于stretch。</li>\n</ul>\n<h2 id=\"10、值和单位\"><a href=\"#10、值和单位\" class=\"headerlink\" title=\"10、值和单位\"></a>10、值和单位</h2><p>CSS 的声明是由属性和值组成的，而值的类型有许多种：</p>\n<ul>\n<li>数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；</li>\n<li>百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；</li>\n<li>颜色：用于指定 background-color、color 等；</li>\n<li>坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；</li>\n<li>函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；</li>\n</ul>\n<p><strong>单位</strong></p>\n<p>前置知识：</p>\n<ol>\n<li>设备像素（Device pixels）</li>\n</ol>\n<p>设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思</p>\n<ol start=\"2\">\n<li>设备像素比（DPR）</li>\n</ol>\n<p>设备像素比表示 1 个 CSS 像素等于几个物理像素。</p>\n<p>计算公式：DPR = 物理像素数 / 逻辑像素数；</p>\n<p>在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。</p>\n<ul>\n<li>px</li>\n</ul>\n<p>px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。</p>\n<p>但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。</p>\n<ul>\n<li>em</li>\n</ul>\n<p>em 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：</p>\n<blockquote>\n<p>在 font-size 中使用是相对于父元素的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；</p>\n<p>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；</p>\n</blockquote>\n<ul>\n<li>rem</li>\n</ul>\n<p>rem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。</p>\n<ul>\n<li>vw/vh</li>\n</ul>\n<p>vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：</p>\n<p>1vw = 视口宽度均分成 100 份中 1 份的长度；<br>1vh = 视口高度均分成 100 份中 1 份的长度；</p>\n<p>在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。</p>\n"},{"title":"HTML-总结","date":"2022-03-30T02:32:20.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/03/30/6Nw1IhFGdrvc2ti.jpg","_content":"\n# HTML总结\n\n### 一、语义化\n\n**语义化是指根据内容的结构化，选择合适的标签。** 也就是用正确的标签做正确的事。\n\n优点：\n* 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效的信息，有利于SEO\n* 对开发者友好，增强了代码的可读性，结构更加清晰，便于维护\n\n常见的与语义化标签\n* **header** ：头部\n* **nav** ：导航栏\n* **main** ：主要区域\n* **section** ：区块\n* **article** ：主要内容\n* **aside** ：侧边栏\n* **footer** ：底部\n\n### 二、DOCTYPE（文档类型）\n\nDOCTYPE是HTML5中的一种**标准通用标记语言**的文档类型声明，它的目的是为了告诉浏览器应该以什么样的文档类型定义来解析文档，\n不同的渲染模式会影响浏览器对CSS代码甚至JavaScript脚本的解析。它必须声明在HTMl文档的第一行。\n\n浏览器渲染⻚⾯的两种模式（可通过document.compatMode获取，⽐如，语雀官⽹的⽂档类型是 CSS1Compat）：\n* CSS1Compat：标准模式（Strick mode），默认模式，浏览器使⽤W3C的标准解析渲染⻚⾯。在 标准模式中，浏览器以其⽀持的最⾼标准呈现⻚⾯。 \n  \n* BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使⽤⾃⼰的怪异模式解析渲染⻚⾯。在 怪异模式中，⻚⾯以⼀种⽐较宽松的向后兼容的⽅式显示。\n\n### 三、meta标签\n\n`meta` 标签由 `name` 和 `content` 属性定义，⽤来**描述⽹⻚⽂档的属性**，⽐如⽹⻚的作者，⽹⻚描 述，关键词等，除了HTTP标准固定了⼀些 name 作为⼤家使⽤的共识，开发者还可以⾃定义name。\n\n常用的meta标签:\n* `charset`：用来描述HTMl文档的编码类型\n```html\n<meta charset=\"utf-8\">\n```\n* `keywords`：⻚⾯关键词\n```html\n<meta name=\"keywords\" content=\"关键词\" /> \n```\n* ` description`：⻚⾯描述\n```html\n<meta name=\"description\" content=\"⻚⾯描述内容\" /> \n```\n* ` refresh`⻚⾯重定向和刷新\n```html\n<meta http-equiv=\"refresh\" content=\"0;url=\" /> \n```\n* `viewport`：适配移动端，可以控制视⼝的⼤⼩和⽐例\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum- scale=1\"> \n```\n其中， content 参数有以下⼏种： \n> width viewport ：宽度(数值/device-width)\n  \n> height viewport ：⾼度(数值/device-height) \n  \n> initial-scale ：初始缩放⽐例 \n\n> maximum-scale ：最⼤缩放⽐例 \n\n> minimum-scale ：最⼩缩放⽐例 \n\n> user-scalable ：是否允许⽤户缩放(yes/no）\n\n### 四、HTML5更新\n\n* （1）新增语义化标签：nav、header、footer、aside、section、article \n* （2）⾳频、视频标签：audio、video \n* （3）数据存储：localStorage、sessionStorage \n* （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） \n* （5）input标签新增属性：placeholder、autocomplete、autofocus、required \n* （6）history API：go、forward、back、pushstate\n\n### 五、行内/块级标签\n* ⾏内标签有： `a` `b` `span` `img` `input` `select` `strong` ； \n* 块级标签有： `div` `ul` `ol` `li` `dl` `dt` `dd` `h1` `h2` `h3` `h4` `h5` `h6` `p` ；\n* 空标签有：`br` `hr`  `img`  `input`  `link`  `meta` ；\n\n行内标签与块级标签的区别：\n* 块级标签独占一行，并且会自动换行，而行内标签会在一条水平线上排列\n* 行内标签不能设置宽高，margin、padding上下无效\n* 块级标签可以包含任何标签，而行内标签只能包含文本或行内标签\n\n### 六、渐进增强和优雅降级\n\n1. 渐进增强（progressive enhancement）：主要是针对低版本的浏览器进⾏⻚⾯重构，保证基本 的功能情况下，再针对⾼级浏览器进⾏效果、交互等⽅⾯的改进和追加功能，以达到更好的⽤户体验。 \n2. 优雅降级 graceful degradation： ⼀开始就构建完整的功能，然后再针对低版本的浏览器进⾏兼 容。\n\n两者区别： \n\n* 优雅降级是从复杂的现状开始的，并试图减少⽤户体验的供给；⽽渐进增强是从⼀个⾮常基础的， 能够起作⽤的版本开始的，并在此基础上不断扩充，以适应未来环境的需要； \n* 降级（功能衰竭）意味着往回看，⽽渐进增强则意味着往前看，同时保证其根基处于安全地带。","source":"_posts/HTML-all.md","raw":"---\ntitle: HTML-总结\ndate: 2022-03-30 10:32:20\ncategories: HTML\ntags: [HTML]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/03/30/6Nw1IhFGdrvc2ti.jpg\n---\n\n# HTML总结\n\n### 一、语义化\n\n**语义化是指根据内容的结构化，选择合适的标签。** 也就是用正确的标签做正确的事。\n\n优点：\n* 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效的信息，有利于SEO\n* 对开发者友好，增强了代码的可读性，结构更加清晰，便于维护\n\n常见的与语义化标签\n* **header** ：头部\n* **nav** ：导航栏\n* **main** ：主要区域\n* **section** ：区块\n* **article** ：主要内容\n* **aside** ：侧边栏\n* **footer** ：底部\n\n### 二、DOCTYPE（文档类型）\n\nDOCTYPE是HTML5中的一种**标准通用标记语言**的文档类型声明，它的目的是为了告诉浏览器应该以什么样的文档类型定义来解析文档，\n不同的渲染模式会影响浏览器对CSS代码甚至JavaScript脚本的解析。它必须声明在HTMl文档的第一行。\n\n浏览器渲染⻚⾯的两种模式（可通过document.compatMode获取，⽐如，语雀官⽹的⽂档类型是 CSS1Compat）：\n* CSS1Compat：标准模式（Strick mode），默认模式，浏览器使⽤W3C的标准解析渲染⻚⾯。在 标准模式中，浏览器以其⽀持的最⾼标准呈现⻚⾯。 \n  \n* BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使⽤⾃⼰的怪异模式解析渲染⻚⾯。在 怪异模式中，⻚⾯以⼀种⽐较宽松的向后兼容的⽅式显示。\n\n### 三、meta标签\n\n`meta` 标签由 `name` 和 `content` 属性定义，⽤来**描述⽹⻚⽂档的属性**，⽐如⽹⻚的作者，⽹⻚描 述，关键词等，除了HTTP标准固定了⼀些 name 作为⼤家使⽤的共识，开发者还可以⾃定义name。\n\n常用的meta标签:\n* `charset`：用来描述HTMl文档的编码类型\n```html\n<meta charset=\"utf-8\">\n```\n* `keywords`：⻚⾯关键词\n```html\n<meta name=\"keywords\" content=\"关键词\" /> \n```\n* ` description`：⻚⾯描述\n```html\n<meta name=\"description\" content=\"⻚⾯描述内容\" /> \n```\n* ` refresh`⻚⾯重定向和刷新\n```html\n<meta http-equiv=\"refresh\" content=\"0;url=\" /> \n```\n* `viewport`：适配移动端，可以控制视⼝的⼤⼩和⽐例\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum- scale=1\"> \n```\n其中， content 参数有以下⼏种： \n> width viewport ：宽度(数值/device-width)\n  \n> height viewport ：⾼度(数值/device-height) \n  \n> initial-scale ：初始缩放⽐例 \n\n> maximum-scale ：最⼤缩放⽐例 \n\n> minimum-scale ：最⼩缩放⽐例 \n\n> user-scalable ：是否允许⽤户缩放(yes/no）\n\n### 四、HTML5更新\n\n* （1）新增语义化标签：nav、header、footer、aside、section、article \n* （2）⾳频、视频标签：audio、video \n* （3）数据存储：localStorage、sessionStorage \n* （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） \n* （5）input标签新增属性：placeholder、autocomplete、autofocus、required \n* （6）history API：go、forward、back、pushstate\n\n### 五、行内/块级标签\n* ⾏内标签有： `a` `b` `span` `img` `input` `select` `strong` ； \n* 块级标签有： `div` `ul` `ol` `li` `dl` `dt` `dd` `h1` `h2` `h3` `h4` `h5` `h6` `p` ；\n* 空标签有：`br` `hr`  `img`  `input`  `link`  `meta` ；\n\n行内标签与块级标签的区别：\n* 块级标签独占一行，并且会自动换行，而行内标签会在一条水平线上排列\n* 行内标签不能设置宽高，margin、padding上下无效\n* 块级标签可以包含任何标签，而行内标签只能包含文本或行内标签\n\n### 六、渐进增强和优雅降级\n\n1. 渐进增强（progressive enhancement）：主要是针对低版本的浏览器进⾏⻚⾯重构，保证基本 的功能情况下，再针对⾼级浏览器进⾏效果、交互等⽅⾯的改进和追加功能，以达到更好的⽤户体验。 \n2. 优雅降级 graceful degradation： ⼀开始就构建完整的功能，然后再针对低版本的浏览器进⾏兼 容。\n\n两者区别： \n\n* 优雅降级是从复杂的现状开始的，并试图减少⽤户体验的供给；⽽渐进增强是从⼀个⾮常基础的， 能够起作⽤的版本开始的，并在此基础上不断扩充，以适应未来环境的需要； \n* 降级（功能衰竭）意味着往回看，⽽渐进增强则意味着往前看，同时保证其根基处于安全地带。","slug":"HTML-all","published":1,"updated":"2022-03-30T03:33:10.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1ls001jdswk8vcl72e4","content":"<h1 id=\"HTML总结\"><a href=\"#HTML总结\" class=\"headerlink\" title=\"HTML总结\"></a>HTML总结</h1><h3 id=\"一、语义化\"><a href=\"#一、语义化\" class=\"headerlink\" title=\"一、语义化\"></a>一、语义化</h3><p><strong>语义化是指根据内容的结构化，选择合适的标签。</strong> 也就是用正确的标签做正确的事。</p>\n<p>优点：</p>\n<ul>\n<li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效的信息，有利于SEO</li>\n<li>对开发者友好，增强了代码的可读性，结构更加清晰，便于维护</li>\n</ul>\n<p>常见的与语义化标签</p>\n<ul>\n<li><strong>header</strong> ：头部</li>\n<li><strong>nav</strong> ：导航栏</li>\n<li><strong>main</strong> ：主要区域</li>\n<li><strong>section</strong> ：区块</li>\n<li><strong>article</strong> ：主要内容</li>\n<li><strong>aside</strong> ：侧边栏</li>\n<li><strong>footer</strong> ：底部</li>\n</ul>\n<h3 id=\"二、DOCTYPE（文档类型）\"><a href=\"#二、DOCTYPE（文档类型）\" class=\"headerlink\" title=\"二、DOCTYPE（文档类型）\"></a>二、DOCTYPE（文档类型）</h3><p>DOCTYPE是HTML5中的一种<strong>标准通用标记语言</strong>的文档类型声明，它的目的是为了告诉浏览器应该以什么样的文档类型定义来解析文档，<br>不同的渲染模式会影响浏览器对CSS代码甚至JavaScript脚本的解析。它必须声明在HTMl文档的第一行。</p>\n<p>浏览器渲染⻚⾯的两种模式（可通过document.compatMode获取，⽐如，语雀官⽹的⽂档类型是 CSS1Compat）：</p>\n<ul>\n<li><p>CSS1Compat：标准模式（Strick mode），默认模式，浏览器使⽤W3C的标准解析渲染⻚⾯。在 标准模式中，浏览器以其⽀持的最⾼标准呈现⻚⾯。 </p>\n</li>\n<li><p>BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使⽤⾃⼰的怪异模式解析渲染⻚⾯。在 怪异模式中，⻚⾯以⼀种⽐较宽松的向后兼容的⽅式显示。</p>\n</li>\n</ul>\n<h3 id=\"三、meta标签\"><a href=\"#三、meta标签\" class=\"headerlink\" title=\"三、meta标签\"></a>三、meta标签</h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，⽤来<strong>描述⽹⻚⽂档的属性</strong>，⽐如⽹⻚的作者，⽹⻚描 述，关键词等，除了HTTP标准固定了⼀些 name 作为⼤家使⽤的共识，开发者还可以⾃定义name。</p>\n<p>常用的meta标签:</p>\n<ul>\n<li><code>charset</code>：用来描述HTMl文档的编码类型<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><code>keywords</code>：⻚⾯关键词<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;keywords&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;关键词&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure></li>\n<li><code>description</code>：⻚⾯描述<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;⻚⾯描述内容&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure></li>\n<li><code>refresh</code>⻚⾯重定向和刷新<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;refresh&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;0;url=&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure></li>\n<li><code>viewport</code>：适配移动端，可以控制视⼝的⼤⼩和⽐例<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1, maximum- scale=1&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n其中， content 参数有以下⼏种： <blockquote>\n<p>width viewport ：宽度(数值/device-width)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>height viewport ：⾼度(数值/device-height) </p>\n</blockquote>\n<blockquote>\n<p>initial-scale ：初始缩放⽐例 </p>\n</blockquote>\n<blockquote>\n<p>maximum-scale ：最⼤缩放⽐例 </p>\n</blockquote>\n<blockquote>\n<p>minimum-scale ：最⼩缩放⽐例 </p>\n</blockquote>\n<blockquote>\n<p>user-scalable ：是否允许⽤户缩放(yes/no）</p>\n</blockquote>\n<h3 id=\"四、HTML5更新\"><a href=\"#四、HTML5更新\" class=\"headerlink\" title=\"四、HTML5更新\"></a>四、HTML5更新</h3><ul>\n<li>（1）新增语义化标签：nav、header、footer、aside、section、article </li>\n<li>（2）⾳频、视频标签：audio、video </li>\n<li>（3）数据存储：localStorage、sessionStorage </li>\n<li>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） </li>\n<li>（5）input标签新增属性：placeholder、autocomplete、autofocus、required </li>\n<li>（6）history API：go、forward、back、pushstate</li>\n</ul>\n<h3 id=\"五、行内-块级标签\"><a href=\"#五、行内-块级标签\" class=\"headerlink\" title=\"五、行内/块级标签\"></a>五、行内/块级标签</h3><ul>\n<li>⾏内标签有： <code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>input</code> <code>select</code> <code>strong</code> ； </li>\n<li>块级标签有： <code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code> ；</li>\n<li>空标签有：<code>br</code> <code>hr</code>  <code>img</code>  <code>input</code>  <code>link</code>  <code>meta</code> ；</li>\n</ul>\n<p>行内标签与块级标签的区别：</p>\n<ul>\n<li>块级标签独占一行，并且会自动换行，而行内标签会在一条水平线上排列</li>\n<li>行内标签不能设置宽高，margin、padding上下无效</li>\n<li>块级标签可以包含任何标签，而行内标签只能包含文本或行内标签</li>\n</ul>\n<h3 id=\"六、渐进增强和优雅降级\"><a href=\"#六、渐进增强和优雅降级\" class=\"headerlink\" title=\"六、渐进增强和优雅降级\"></a>六、渐进增强和优雅降级</h3><ol>\n<li>渐进增强（progressive enhancement）：主要是针对低版本的浏览器进⾏⻚⾯重构，保证基本 的功能情况下，再针对⾼级浏览器进⾏效果、交互等⽅⾯的改进和追加功能，以达到更好的⽤户体验。 </li>\n<li>优雅降级 graceful degradation： ⼀开始就构建完整的功能，然后再针对低版本的浏览器进⾏兼 容。</li>\n</ol>\n<p>两者区别： </p>\n<ul>\n<li>优雅降级是从复杂的现状开始的，并试图减少⽤户体验的供给；⽽渐进增强是从⼀个⾮常基础的， 能够起作⽤的版本开始的，并在此基础上不断扩充，以适应未来环境的需要； </li>\n<li>降级（功能衰竭）意味着往回看，⽽渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTML总结\"><a href=\"#HTML总结\" class=\"headerlink\" title=\"HTML总结\"></a>HTML总结</h1><h3 id=\"一、语义化\"><a href=\"#一、语义化\" class=\"headerlink\" title=\"一、语义化\"></a>一、语义化</h3><p><strong>语义化是指根据内容的结构化，选择合适的标签。</strong> 也就是用正确的标签做正确的事。</p>\n<p>优点：</p>\n<ul>\n<li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效的信息，有利于SEO</li>\n<li>对开发者友好，增强了代码的可读性，结构更加清晰，便于维护</li>\n</ul>\n<p>常见的与语义化标签</p>\n<ul>\n<li><strong>header</strong> ：头部</li>\n<li><strong>nav</strong> ：导航栏</li>\n<li><strong>main</strong> ：主要区域</li>\n<li><strong>section</strong> ：区块</li>\n<li><strong>article</strong> ：主要内容</li>\n<li><strong>aside</strong> ：侧边栏</li>\n<li><strong>footer</strong> ：底部</li>\n</ul>\n<h3 id=\"二、DOCTYPE（文档类型）\"><a href=\"#二、DOCTYPE（文档类型）\" class=\"headerlink\" title=\"二、DOCTYPE（文档类型）\"></a>二、DOCTYPE（文档类型）</h3><p>DOCTYPE是HTML5中的一种<strong>标准通用标记语言</strong>的文档类型声明，它的目的是为了告诉浏览器应该以什么样的文档类型定义来解析文档，<br>不同的渲染模式会影响浏览器对CSS代码甚至JavaScript脚本的解析。它必须声明在HTMl文档的第一行。</p>\n<p>浏览器渲染⻚⾯的两种模式（可通过document.compatMode获取，⽐如，语雀官⽹的⽂档类型是 CSS1Compat）：</p>\n<ul>\n<li><p>CSS1Compat：标准模式（Strick mode），默认模式，浏览器使⽤W3C的标准解析渲染⻚⾯。在 标准模式中，浏览器以其⽀持的最⾼标准呈现⻚⾯。 </p>\n</li>\n<li><p>BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使⽤⾃⼰的怪异模式解析渲染⻚⾯。在 怪异模式中，⻚⾯以⼀种⽐较宽松的向后兼容的⽅式显示。</p>\n</li>\n</ul>\n<h3 id=\"三、meta标签\"><a href=\"#三、meta标签\" class=\"headerlink\" title=\"三、meta标签\"></a>三、meta标签</h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，⽤来<strong>描述⽹⻚⽂档的属性</strong>，⽐如⽹⻚的作者，⽹⻚描 述，关键词等，除了HTTP标准固定了⼀些 name 作为⼤家使⽤的共识，开发者还可以⾃定义name。</p>\n<p>常用的meta标签:</p>\n<ul>\n<li><code>charset</code>：用来描述HTMl文档的编码类型<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><code>keywords</code>：⻚⾯关键词<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;keywords&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;关键词&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure></li>\n<li><code>description</code>：⻚⾯描述<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;⻚⾯描述内容&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure></li>\n<li><code>refresh</code>⻚⾯重定向和刷新<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;refresh&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;0;url=&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure></li>\n<li><code>viewport</code>：适配移动端，可以控制视⼝的⼤⼩和⽐例<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1, maximum- scale=1&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n其中， content 参数有以下⼏种： <blockquote>\n<p>width viewport ：宽度(数值/device-width)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>height viewport ：⾼度(数值/device-height) </p>\n</blockquote>\n<blockquote>\n<p>initial-scale ：初始缩放⽐例 </p>\n</blockquote>\n<blockquote>\n<p>maximum-scale ：最⼤缩放⽐例 </p>\n</blockquote>\n<blockquote>\n<p>minimum-scale ：最⼩缩放⽐例 </p>\n</blockquote>\n<blockquote>\n<p>user-scalable ：是否允许⽤户缩放(yes/no）</p>\n</blockquote>\n<h3 id=\"四、HTML5更新\"><a href=\"#四、HTML5更新\" class=\"headerlink\" title=\"四、HTML5更新\"></a>四、HTML5更新</h3><ul>\n<li>（1）新增语义化标签：nav、header、footer、aside、section、article </li>\n<li>（2）⾳频、视频标签：audio、video </li>\n<li>（3）数据存储：localStorage、sessionStorage </li>\n<li>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） </li>\n<li>（5）input标签新增属性：placeholder、autocomplete、autofocus、required </li>\n<li>（6）history API：go、forward、back、pushstate</li>\n</ul>\n<h3 id=\"五、行内-块级标签\"><a href=\"#五、行内-块级标签\" class=\"headerlink\" title=\"五、行内/块级标签\"></a>五、行内/块级标签</h3><ul>\n<li>⾏内标签有： <code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>input</code> <code>select</code> <code>strong</code> ； </li>\n<li>块级标签有： <code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code> ；</li>\n<li>空标签有：<code>br</code> <code>hr</code>  <code>img</code>  <code>input</code>  <code>link</code>  <code>meta</code> ；</li>\n</ul>\n<p>行内标签与块级标签的区别：</p>\n<ul>\n<li>块级标签独占一行，并且会自动换行，而行内标签会在一条水平线上排列</li>\n<li>行内标签不能设置宽高，margin、padding上下无效</li>\n<li>块级标签可以包含任何标签，而行内标签只能包含文本或行内标签</li>\n</ul>\n<h3 id=\"六、渐进增强和优雅降级\"><a href=\"#六、渐进增强和优雅降级\" class=\"headerlink\" title=\"六、渐进增强和优雅降级\"></a>六、渐进增强和优雅降级</h3><ol>\n<li>渐进增强（progressive enhancement）：主要是针对低版本的浏览器进⾏⻚⾯重构，保证基本 的功能情况下，再针对⾼级浏览器进⾏效果、交互等⽅⾯的改进和追加功能，以达到更好的⽤户体验。 </li>\n<li>优雅降级 graceful degradation： ⼀开始就构建完整的功能，然后再针对低版本的浏览器进⾏兼 容。</li>\n</ol>\n<p>两者区别： </p>\n<ul>\n<li>优雅降级是从复杂的现状开始的，并试图减少⽤户体验的供给；⽽渐进增强是从⼀个⾮常基础的， 能够起作⽤的版本开始的，并在此基础上不断扩充，以适应未来环境的需要； </li>\n<li>降级（功能衰竭）意味着往回看，⽽渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>\n</ul>\n"},{"_content":" ## hexo+github 搭建静态博客\n\n### 1、准备工作\n\n在开始一切之前，你必须已经：\n\n* 有一个github账号，没有的话去注册一个；\n* 安装了node.js、npm，并了解相关基础知识；\n* 安装了git for windows（或者其它git客户端）\n\n### 2、创建仓库\n\n新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了.\n\n### 3、配置SSH key\n\n为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。\n\n\n`$ cd ~/. ssh `#检查本机已存在的ssh密钥\n\n如果提示：No such file or directory 说明你是第一次使用git。\n\n`ssh-keygen -t rsa -C \"邮件地址\"`\n\n然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -> SSH and GPG keys -> New SSH key：\n\n将刚复制的内容粘贴到key那里，title随便填，保存。\n\n### 4、使用hexo写博客\n\n安装\n\n`$ npm install -g hexo`\n\n初始化\n\n`$ cd /f/Workspaces/hexo/\n$ hexo init`\n\n`hexo s`是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容\n\n### 5、上传\n\n如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。\n\n首先，ssh key肯定要配置好。\n\n其次，配置_config.yml中有关deploy的部分：\n\n正确写法：\n\n`deploy:\n  type: git\n  repository: git@github.com:liuxianan/liuxianan.github.io.git\n  branch: master`\n\n  ### 6、hexo常用命令\n\n  `hexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本`\n\n`hexo s -g #生成并本地预览\nhexo d -g #生成并上传`\n\n### 7、创建博客\n\n在项目文件中找到source => _posts,在该文件夹下创建.md的文档,格式如下:\n\n```\ntitle: postName #文章页面上的显示名称，一般是中文\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 默认分类 #分类\ntags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n```\n\n以下是正文\n\n\n\n相关语法参考:https://www.runoob.com/markdown/md-tutorial.html","source":"_posts/Hexo.md","raw":" ## hexo+github 搭建静态博客\n\n### 1、准备工作\n\n在开始一切之前，你必须已经：\n\n* 有一个github账号，没有的话去注册一个；\n* 安装了node.js、npm，并了解相关基础知识；\n* 安装了git for windows（或者其它git客户端）\n\n### 2、创建仓库\n\n新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了.\n\n### 3、配置SSH key\n\n为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。\n\n\n`$ cd ~/. ssh `#检查本机已存在的ssh密钥\n\n如果提示：No such file or directory 说明你是第一次使用git。\n\n`ssh-keygen -t rsa -C \"邮件地址\"`\n\n然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -> SSH and GPG keys -> New SSH key：\n\n将刚复制的内容粘贴到key那里，title随便填，保存。\n\n### 4、使用hexo写博客\n\n安装\n\n`$ npm install -g hexo`\n\n初始化\n\n`$ cd /f/Workspaces/hexo/\n$ hexo init`\n\n`hexo s`是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容\n\n### 5、上传\n\n如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。\n\n首先，ssh key肯定要配置好。\n\n其次，配置_config.yml中有关deploy的部分：\n\n正确写法：\n\n`deploy:\n  type: git\n  repository: git@github.com:liuxianan/liuxianan.github.io.git\n  branch: master`\n\n  ### 6、hexo常用命令\n\n  `hexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本`\n\n`hexo s -g #生成并本地预览\nhexo d -g #生成并上传`\n\n### 7、创建博客\n\n在项目文件中找到source => _posts,在该文件夹下创建.md的文档,格式如下:\n\n```\ntitle: postName #文章页面上的显示名称，一般是中文\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 默认分类 #分类\ntags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n```\n\n以下是正文\n\n\n\n相关语法参考:https://www.runoob.com/markdown/md-tutorial.html","slug":"Hexo","published":1,"date":"2021-09-09T06:49:10.598Z","updated":"2021-09-15T08:41:56.164Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1lw001mdswk7ke26726","content":"<h2 id=\"hexo-github-搭建静态博客\"><a href=\"#hexo-github-搭建静态博客\" class=\"headerlink\" title=\"hexo+github 搭建静态博客\"></a>hexo+github 搭建静态博客</h2><h3 id=\"1、准备工作\"><a href=\"#1、准备工作\" class=\"headerlink\" title=\"1、准备工作\"></a>1、准备工作</h3><p>在开始一切之前，你必须已经：</p>\n<ul>\n<li>有一个github账号，没有的话去注册一个；</li>\n<li>安装了node.js、npm，并了解相关基础知识；</li>\n<li>安装了git for windows（或者其它git客户端）</li>\n</ul>\n<h3 id=\"2、创建仓库\"><a href=\"#2、创建仓库\" class=\"headerlink\" title=\"2、创建仓库\"></a>2、创建仓库</h3><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href=\"http://test.github.io\">http://test.github.io</a> 了.</p>\n<h3 id=\"3、配置SSH-key\"><a href=\"#3、配置SSH-key\" class=\"headerlink\" title=\"3、配置SSH key\"></a>3、配置SSH key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>\n<p><code>$ cd ~/. ssh</code>#检查本机已存在的ssh密钥</p>\n<p>如果提示：No such file or directory 说明你是第一次使用git。</p>\n<p><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p>\n<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>\n<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>\n<h3 id=\"4、使用hexo写博客\"><a href=\"#4、使用hexo写博客\" class=\"headerlink\" title=\"4、使用hexo写博客\"></a>4、使用hexo写博客</h3><p>安装</p>\n<p><code>$ npm install -g hexo</code></p>\n<p>初始化</p>\n<p><code>$ cd /f/Workspaces/hexo/\n$ hexo init</code></p>\n<p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href=\"http://localhost:4000\">http://localhost:4000</a> 即可看到内容</p>\n<h3 id=\"5、上传\"><a href=\"#5、上传\" class=\"headerlink\" title=\"5、上传\"></a>5、上传</h3><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p>\n<p>首先，ssh key肯定要配置好。</p>\n<p>其次，配置_config.yml中有关deploy的部分：</p>\n<p>正确写法：</p>\n<p><code>deploy:\n  type: git\n  repository: git@github.com:liuxianan/liuxianan.github.io.git\n  branch: master</code></p>\n<h3 id=\"6、hexo常用命令\"><a href=\"#6、hexo常用命令\" class=\"headerlink\" title=\"6、hexo常用命令\"></a>6、hexo常用命令</h3><p>  <code>hexo new &quot;postName&quot; #新建文章\nhexo new page &quot;pageName&quot; #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本</code></p>\n<p><code>hexo s -g #生成并本地预览\nhexo d -g #生成并上传</code></p>\n<h3 id=\"7、创建博客\"><a href=\"#7、创建博客\" class=\"headerlink\" title=\"7、创建博客\"></a>7、创建博客</h3><p>在项目文件中找到source =&gt; _posts,在该文件夹下创建.md的文档,格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: postName #文章页面上的显示名称，一般是中文</span><br><span class=\"line\">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class=\"line\">categories: 默认分类 #分类</span><br><span class=\"line\">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class=\"line\">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br></pre></td></tr></table></figure>\n\n<p>以下是正文</p>\n<p>相关语法参考:<a href=\"https://www.runoob.com/markdown/md-tutorial.html\">https://www.runoob.com/markdown/md-tutorial.html</a></p>\n","site":{"data":{}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","excerpt":"","more":"<h2 id=\"hexo-github-搭建静态博客\"><a href=\"#hexo-github-搭建静态博客\" class=\"headerlink\" title=\"hexo+github 搭建静态博客\"></a>hexo+github 搭建静态博客</h2><h3 id=\"1、准备工作\"><a href=\"#1、准备工作\" class=\"headerlink\" title=\"1、准备工作\"></a>1、准备工作</h3><p>在开始一切之前，你必须已经：</p>\n<ul>\n<li>有一个github账号，没有的话去注册一个；</li>\n<li>安装了node.js、npm，并了解相关基础知识；</li>\n<li>安装了git for windows（或者其它git客户端）</li>\n</ul>\n<h3 id=\"2、创建仓库\"><a href=\"#2、创建仓库\" class=\"headerlink\" title=\"2、创建仓库\"></a>2、创建仓库</h3><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href=\"http://test.github.io\">http://test.github.io</a> 了.</p>\n<h3 id=\"3、配置SSH-key\"><a href=\"#3、配置SSH-key\" class=\"headerlink\" title=\"3、配置SSH key\"></a>3、配置SSH key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>\n<p><code>$ cd ~/. ssh</code>#检查本机已存在的ssh密钥</p>\n<p>如果提示：No such file or directory 说明你是第一次使用git。</p>\n<p><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p>\n<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>\n<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>\n<h3 id=\"4、使用hexo写博客\"><a href=\"#4、使用hexo写博客\" class=\"headerlink\" title=\"4、使用hexo写博客\"></a>4、使用hexo写博客</h3><p>安装</p>\n<p><code>$ npm install -g hexo</code></p>\n<p>初始化</p>\n<p><code>$ cd /f/Workspaces/hexo/\n$ hexo init</code></p>\n<p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href=\"http://localhost:4000\">http://localhost:4000</a> 即可看到内容</p>\n<h3 id=\"5、上传\"><a href=\"#5、上传\" class=\"headerlink\" title=\"5、上传\"></a>5、上传</h3><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p>\n<p>首先，ssh key肯定要配置好。</p>\n<p>其次，配置_config.yml中有关deploy的部分：</p>\n<p>正确写法：</p>\n<p><code>deploy:\n  type: git\n  repository: git@github.com:liuxianan/liuxianan.github.io.git\n  branch: master</code></p>\n<h3 id=\"6、hexo常用命令\"><a href=\"#6、hexo常用命令\" class=\"headerlink\" title=\"6、hexo常用命令\"></a>6、hexo常用命令</h3><p>  <code>hexo new &quot;postName&quot; #新建文章\nhexo new page &quot;pageName&quot; #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本</code></p>\n<p><code>hexo s -g #生成并本地预览\nhexo d -g #生成并上传</code></p>\n<h3 id=\"7、创建博客\"><a href=\"#7、创建博客\" class=\"headerlink\" title=\"7、创建博客\"></a>7、创建博客</h3><p>在项目文件中找到source =&gt; _posts,在该文件夹下创建.md的文档,格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: postName #文章页面上的显示名称，一般是中文</span><br><span class=\"line\">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class=\"line\">categories: 默认分类 #分类</span><br><span class=\"line\">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class=\"line\">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br></pre></td></tr></table></figure>\n\n<p>以下是正文</p>\n<p>相关语法参考:<a href=\"https://www.runoob.com/markdown/md-tutorial.html\">https://www.runoob.com/markdown/md-tutorial.html</a></p>\n"},{"title":"网络：DNS与CDN总结","date":"2021-11-22T02:32:20.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/22/DtFamwJ5R7PNvoC.jpg","_content":"\n## 网络：DNS与CDN总结\n\n### 一、DNS\n\nDNS域名解析器，用于将我们访问的网址转换为对应的IP地址。\n\n我们在访问网址时，并不是直接就可以访问到对应的服务器，而是需要通过IP地址来建立连接，但是由于IP是一段段的数字不方便记忆，所以才有了网址的形式。\n\n`域名与IP之间的对应关系，称为\"记录\"（record）。根据使用场景，\"记录\"可以分成不同的类型（type）`\n\n>  `A`：地址记录（Address），返回域名指向的IP地址  IPv4。\n>\n> `AAAA`：地址记录（Address），返回域名指向的IP地址  IPv6\n>\n>  `NS`：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。\n>\n> `MX`：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。\n>\n> `CNAME`：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。\n>\n> `PTR`：逆向查询记录（Pointer Record），只用于从IP地址查询域名。\n\n* **DNS解析过程**\n\n当在浏览器输入网址（`www.baidu.com`）时，会经过一下的步骤：\n\n> 一个网址有不同的分级，比如上面的百度网址\n>\n> 根域名：`.` 上面的网址其实并不是完整的，完整的是`www.baidu.com.root`，每个网址都有一个`.root`的根域名，所以省略了\n>\n> 顶级域名：`.com`\n>\n> 次级域名：`.baidu`\n>\n> 主机域名：`www`\n\n1. 检查浏览器缓存\n2. 检查操作系统缓存\n3. 检查路由器缓存\n\n如果以上都没有找到对应的IP地址，就会通过DNS来查询\n\n4. 首先查询根域名服务器，如果查询成功会返回根域名`.`的所有NS记录，也就是根域名服务器\n5. 然后DNS会向每一个根域名服务器请求，查询`com.`对应的顶级域名服务器NS记录\n6. DNS再回向每一个顶级域名服务器请求，查询`baidu.com`对应的次级域名服务器NS记录\n7. DNS最后向每一个次级域名服务器请求，查询`www.baidu.com`对应的IP地址，然后返回给浏览器\n\n* **DNS解析过程分类**\n\nDNS解析过程分为递归和迭代\n\n**递归**\n\n类型于`递归函数`，查询由对应的域名服务器查询，而不是本地域名服务器\n\n> 比如：\n>\n> 查询到了`.`对应的根域名服务器，那么再查找顶级域名时，由对应的根域名服务器去请求查询顶级域名\n\n**迭代**\n\n每次查询都返回对应的IP地址，由本地域名服务器来请求\n\n> 比如：\n>\n> 查询到了`.`对应的根域名服务器，将对应的IP地址返回给本地域名服务器，再由本地域名服务器来通过IP地址来请求查询顶级域名\n\n* **DNS优化**\n\n因为DNS会向不同的域名服务器发送请求，所以会带来比较大的时间损耗，所以我们可以采用一些方式来优化一下\n\n1. **DNS预解析**\n\n   用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行DNS解析。\n   可以在服务器中响应设置`X-DNS-Prefetch-Control`的值为on启动预解析\n\n   ```html\n   <meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n   ```\n\n   对特定域名预解析\n\n   ```html\n   <link rel=”dns-prefetch” href=”//www.baidu.com”\n   ```\n\n2. **域名收敛**\n\n   建议将静态资源只放在一个域名下面，可以有效减少dns的请求\n\n* **DDOS 攻击**\n\n在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。\n\n防御方法有：\n\n1. 备份网站\n2. HTTP拦截请求\n3. 带宽扩容\n4. CDN\n\n****\n\n### 二、CDN\n\nCDN内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。\n\n典型的CDN系统由下面三个部分组成\n\n- 分发服务系统\n\n  最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标\n\n- 负载均衡系统\n\n  主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负 责节点内部的设备负载均衡\n\n- 运营管理系统\n\n  分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。\n\n##### CDN的过程\n\n`使用CDN的方法很简单，只需要修改自己的DNS解析，设置一个CNAME指向CDN服务商即可。`\n\n用户访问未使用CDN缓存资源的过程为:\n\n1. 浏览器通过前面提到的过程对域名进行解析，以得到此域名对应的IP地址；\n2. 浏览器使用所得到的IP地址，向域名的服务主机发出数据访问请求；\n3. 服务器向浏览器返回响应数据\n\n使用CDN后\n\n1. 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。\n2. CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。\n3. 用户向CDN的全局负载均衡设备发起内容URL访问请求。\n4. CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。\n5. 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。\n6. 全局负载均衡设备把服务器的IP地址返回给用户\n7. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。\n\n##### CDN的优点\n\n1. 本地Cache加速，加快访问速度\n2. 镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量\n3. 远程加速，自动选择cache服务器\n4. 带宽优化，分担网络流量，减轻压力，\n5. 集群抗攻击\n6. 节约成本\n****\n参考文章：\n\n[DNS 原理入门](https://www.ruanyifeng.com/blog/2016/06/dns.html)\n\n[CDN与DNS知识汇总](https://juejin.cn/post/6844903590662766599)\n","source":"_posts/Internet-DNS_CDN.md","raw":"---\ntitle: 网络：DNS与CDN总结\ndate: 2021-11-22 10:32:20\ncategories: 网络\ntags: [网络]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/22/DtFamwJ5R7PNvoC.jpg\n---\n\n## 网络：DNS与CDN总结\n\n### 一、DNS\n\nDNS域名解析器，用于将我们访问的网址转换为对应的IP地址。\n\n我们在访问网址时，并不是直接就可以访问到对应的服务器，而是需要通过IP地址来建立连接，但是由于IP是一段段的数字不方便记忆，所以才有了网址的形式。\n\n`域名与IP之间的对应关系，称为\"记录\"（record）。根据使用场景，\"记录\"可以分成不同的类型（type）`\n\n>  `A`：地址记录（Address），返回域名指向的IP地址  IPv4。\n>\n> `AAAA`：地址记录（Address），返回域名指向的IP地址  IPv6\n>\n>  `NS`：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。\n>\n> `MX`：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。\n>\n> `CNAME`：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。\n>\n> `PTR`：逆向查询记录（Pointer Record），只用于从IP地址查询域名。\n\n* **DNS解析过程**\n\n当在浏览器输入网址（`www.baidu.com`）时，会经过一下的步骤：\n\n> 一个网址有不同的分级，比如上面的百度网址\n>\n> 根域名：`.` 上面的网址其实并不是完整的，完整的是`www.baidu.com.root`，每个网址都有一个`.root`的根域名，所以省略了\n>\n> 顶级域名：`.com`\n>\n> 次级域名：`.baidu`\n>\n> 主机域名：`www`\n\n1. 检查浏览器缓存\n2. 检查操作系统缓存\n3. 检查路由器缓存\n\n如果以上都没有找到对应的IP地址，就会通过DNS来查询\n\n4. 首先查询根域名服务器，如果查询成功会返回根域名`.`的所有NS记录，也就是根域名服务器\n5. 然后DNS会向每一个根域名服务器请求，查询`com.`对应的顶级域名服务器NS记录\n6. DNS再回向每一个顶级域名服务器请求，查询`baidu.com`对应的次级域名服务器NS记录\n7. DNS最后向每一个次级域名服务器请求，查询`www.baidu.com`对应的IP地址，然后返回给浏览器\n\n* **DNS解析过程分类**\n\nDNS解析过程分为递归和迭代\n\n**递归**\n\n类型于`递归函数`，查询由对应的域名服务器查询，而不是本地域名服务器\n\n> 比如：\n>\n> 查询到了`.`对应的根域名服务器，那么再查找顶级域名时，由对应的根域名服务器去请求查询顶级域名\n\n**迭代**\n\n每次查询都返回对应的IP地址，由本地域名服务器来请求\n\n> 比如：\n>\n> 查询到了`.`对应的根域名服务器，将对应的IP地址返回给本地域名服务器，再由本地域名服务器来通过IP地址来请求查询顶级域名\n\n* **DNS优化**\n\n因为DNS会向不同的域名服务器发送请求，所以会带来比较大的时间损耗，所以我们可以采用一些方式来优化一下\n\n1. **DNS预解析**\n\n   用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行DNS解析。\n   可以在服务器中响应设置`X-DNS-Prefetch-Control`的值为on启动预解析\n\n   ```html\n   <meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n   ```\n\n   对特定域名预解析\n\n   ```html\n   <link rel=”dns-prefetch” href=”//www.baidu.com”\n   ```\n\n2. **域名收敛**\n\n   建议将静态资源只放在一个域名下面，可以有效减少dns的请求\n\n* **DDOS 攻击**\n\n在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。\n\n防御方法有：\n\n1. 备份网站\n2. HTTP拦截请求\n3. 带宽扩容\n4. CDN\n\n****\n\n### 二、CDN\n\nCDN内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。\n\n典型的CDN系统由下面三个部分组成\n\n- 分发服务系统\n\n  最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标\n\n- 负载均衡系统\n\n  主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负 责节点内部的设备负载均衡\n\n- 运营管理系统\n\n  分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。\n\n##### CDN的过程\n\n`使用CDN的方法很简单，只需要修改自己的DNS解析，设置一个CNAME指向CDN服务商即可。`\n\n用户访问未使用CDN缓存资源的过程为:\n\n1. 浏览器通过前面提到的过程对域名进行解析，以得到此域名对应的IP地址；\n2. 浏览器使用所得到的IP地址，向域名的服务主机发出数据访问请求；\n3. 服务器向浏览器返回响应数据\n\n使用CDN后\n\n1. 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。\n2. CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。\n3. 用户向CDN的全局负载均衡设备发起内容URL访问请求。\n4. CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。\n5. 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。\n6. 全局负载均衡设备把服务器的IP地址返回给用户\n7. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。\n\n##### CDN的优点\n\n1. 本地Cache加速，加快访问速度\n2. 镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量\n3. 远程加速，自动选择cache服务器\n4. 带宽优化，分担网络流量，减轻压力，\n5. 集群抗攻击\n6. 节约成本\n****\n参考文章：\n\n[DNS 原理入门](https://www.ruanyifeng.com/blog/2016/06/dns.html)\n\n[CDN与DNS知识汇总](https://juejin.cn/post/6844903590662766599)\n","slug":"Internet-DNS_CDN","published":1,"updated":"2021-11-22T02:41:28.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m3002adswk59pkc0mc","content":"<h2 id=\"网络：DNS与CDN总结\"><a href=\"#网络：DNS与CDN总结\" class=\"headerlink\" title=\"网络：DNS与CDN总结\"></a>网络：DNS与CDN总结</h2><h3 id=\"一、DNS\"><a href=\"#一、DNS\" class=\"headerlink\" title=\"一、DNS\"></a>一、DNS</h3><p>DNS域名解析器，用于将我们访问的网址转换为对应的IP地址。</p>\n<p>我们在访问网址时，并不是直接就可以访问到对应的服务器，而是需要通过IP地址来建立连接，但是由于IP是一段段的数字不方便记忆，所以才有了网址的形式。</p>\n<p><code>域名与IP之间的对应关系，称为&quot;记录&quot;（record）。根据使用场景，&quot;记录&quot;可以分成不同的类型（type）</code></p>\n<blockquote>\n<p> <code>A</code>：地址记录（Address），返回域名指向的IP地址  IPv4。</p>\n<p><code>AAAA</code>：地址记录（Address），返回域名指向的IP地址  IPv6</p>\n<p> <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>\n<p><code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p>\n<p><code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。</p>\n<p><code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名。</p>\n</blockquote>\n<ul>\n<li><strong>DNS解析过程</strong></li>\n</ul>\n<p>当在浏览器输入网址（<code>www.baidu.com</code>）时，会经过一下的步骤：</p>\n<blockquote>\n<p>一个网址有不同的分级，比如上面的百度网址</p>\n<p>根域名：<code>.</code> 上面的网址其实并不是完整的，完整的是<code>www.baidu.com.root</code>，每个网址都有一个<code>.root</code>的根域名，所以省略了</p>\n<p>顶级域名：<code>.com</code></p>\n<p>次级域名：<code>.baidu</code></p>\n<p>主机域名：<code>www</code></p>\n</blockquote>\n<ol>\n<li>检查浏览器缓存</li>\n<li>检查操作系统缓存</li>\n<li>检查路由器缓存</li>\n</ol>\n<p>如果以上都没有找到对应的IP地址，就会通过DNS来查询</p>\n<ol start=\"4\">\n<li>首先查询根域名服务器，如果查询成功会返回根域名<code>.</code>的所有NS记录，也就是根域名服务器</li>\n<li>然后DNS会向每一个根域名服务器请求，查询<code>com.</code>对应的顶级域名服务器NS记录</li>\n<li>DNS再回向每一个顶级域名服务器请求，查询<code>baidu.com</code>对应的次级域名服务器NS记录</li>\n<li>DNS最后向每一个次级域名服务器请求，查询<code>www.baidu.com</code>对应的IP地址，然后返回给浏览器</li>\n</ol>\n<ul>\n<li><strong>DNS解析过程分类</strong></li>\n</ul>\n<p>DNS解析过程分为递归和迭代</p>\n<p><strong>递归</strong></p>\n<p>类型于<code>递归函数</code>，查询由对应的域名服务器查询，而不是本地域名服务器</p>\n<blockquote>\n<p>比如：</p>\n<p>查询到了<code>.</code>对应的根域名服务器，那么再查找顶级域名时，由对应的根域名服务器去请求查询顶级域名</p>\n</blockquote>\n<p><strong>迭代</strong></p>\n<p>每次查询都返回对应的IP地址，由本地域名服务器来请求</p>\n<blockquote>\n<p>比如：</p>\n<p>查询到了<code>.</code>对应的根域名服务器，将对应的IP地址返回给本地域名服务器，再由本地域名服务器来通过IP地址来请求查询顶级域名</p>\n</blockquote>\n<ul>\n<li><strong>DNS优化</strong></li>\n</ul>\n<p>因为DNS会向不同的域名服务器发送请求，所以会带来比较大的时间损耗，所以我们可以采用一些方式来优化一下</p>\n<ol>\n<li><p><strong>DNS预解析</strong></p>\n<p>用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行DNS解析。<br>可以在服务器中响应设置<code>X-DNS-Prefetch-Control</code>的值为on启动预解析</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;x-dns-prefetch-control&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对特定域名预解析</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">”dns-prefetch”</span> <span class=\"attr\">href</span>=<span class=\"string\">”//www.baidu.com”</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>域名收敛</strong></p>\n<p>建议将静态资源只放在一个域名下面，可以有效减少dns的请求</p>\n</li>\n</ol>\n<ul>\n<li><strong>DDOS 攻击</strong></li>\n</ul>\n<p>在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。</p>\n<p>防御方法有：</p>\n<ol>\n<li>备份网站</li>\n<li>HTTP拦截请求</li>\n<li>带宽扩容</li>\n<li>CDN</li>\n</ol>\n<hr>\n<h3 id=\"二、CDN\"><a href=\"#二、CDN\" class=\"headerlink\" title=\"二、CDN\"></a>二、CDN</h3><p>CDN内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>\n<p>典型的CDN系统由下面三个部分组成</p>\n<ul>\n<li><p>分发服务系统</p>\n<p>最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标</p>\n</li>\n<li><p>负载均衡系统</p>\n<p>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负 责节点内部的设备负载均衡</p>\n</li>\n<li><p>运营管理系统</p>\n<p>分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>\n</li>\n</ul>\n<h5 id=\"CDN的过程\"><a href=\"#CDN的过程\" class=\"headerlink\" title=\"CDN的过程\"></a>CDN的过程</h5><p><code>使用CDN的方法很简单，只需要修改自己的DNS解析，设置一个CNAME指向CDN服务商即可。</code></p>\n<p>用户访问未使用CDN缓存资源的过程为:</p>\n<ol>\n<li>浏览器通过前面提到的过程对域名进行解析，以得到此域名对应的IP地址；</li>\n<li>浏览器使用所得到的IP地址，向域名的服务主机发出数据访问请求；</li>\n<li>服务器向浏览器返回响应数据</li>\n</ol>\n<p>使用CDN后</p>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li>\n<li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>\n</ol>\n<h5 id=\"CDN的优点\"><a href=\"#CDN的优点\" class=\"headerlink\" title=\"CDN的优点\"></a>CDN的优点</h5><ol>\n<li>本地Cache加速，加快访问速度</li>\n<li>镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量</li>\n<li>远程加速，自动选择cache服务器</li>\n<li>带宽优化，分担网络流量，减轻压力，</li>\n<li>集群抗攻击</li>\n<li>节约成本</li>\n</ol>\n<hr>\n<p>参考文章：</p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2016/06/dns.html\">DNS 原理入门</a></p>\n<p><a href=\"https://juejin.cn/post/6844903590662766599\">CDN与DNS知识汇总</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"网络：DNS与CDN总结\"><a href=\"#网络：DNS与CDN总结\" class=\"headerlink\" title=\"网络：DNS与CDN总结\"></a>网络：DNS与CDN总结</h2><h3 id=\"一、DNS\"><a href=\"#一、DNS\" class=\"headerlink\" title=\"一、DNS\"></a>一、DNS</h3><p>DNS域名解析器，用于将我们访问的网址转换为对应的IP地址。</p>\n<p>我们在访问网址时，并不是直接就可以访问到对应的服务器，而是需要通过IP地址来建立连接，但是由于IP是一段段的数字不方便记忆，所以才有了网址的形式。</p>\n<p><code>域名与IP之间的对应关系，称为&quot;记录&quot;（record）。根据使用场景，&quot;记录&quot;可以分成不同的类型（type）</code></p>\n<blockquote>\n<p> <code>A</code>：地址记录（Address），返回域名指向的IP地址  IPv4。</p>\n<p><code>AAAA</code>：地址记录（Address），返回域名指向的IP地址  IPv6</p>\n<p> <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>\n<p><code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p>\n<p><code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。</p>\n<p><code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名。</p>\n</blockquote>\n<ul>\n<li><strong>DNS解析过程</strong></li>\n</ul>\n<p>当在浏览器输入网址（<code>www.baidu.com</code>）时，会经过一下的步骤：</p>\n<blockquote>\n<p>一个网址有不同的分级，比如上面的百度网址</p>\n<p>根域名：<code>.</code> 上面的网址其实并不是完整的，完整的是<code>www.baidu.com.root</code>，每个网址都有一个<code>.root</code>的根域名，所以省略了</p>\n<p>顶级域名：<code>.com</code></p>\n<p>次级域名：<code>.baidu</code></p>\n<p>主机域名：<code>www</code></p>\n</blockquote>\n<ol>\n<li>检查浏览器缓存</li>\n<li>检查操作系统缓存</li>\n<li>检查路由器缓存</li>\n</ol>\n<p>如果以上都没有找到对应的IP地址，就会通过DNS来查询</p>\n<ol start=\"4\">\n<li>首先查询根域名服务器，如果查询成功会返回根域名<code>.</code>的所有NS记录，也就是根域名服务器</li>\n<li>然后DNS会向每一个根域名服务器请求，查询<code>com.</code>对应的顶级域名服务器NS记录</li>\n<li>DNS再回向每一个顶级域名服务器请求，查询<code>baidu.com</code>对应的次级域名服务器NS记录</li>\n<li>DNS最后向每一个次级域名服务器请求，查询<code>www.baidu.com</code>对应的IP地址，然后返回给浏览器</li>\n</ol>\n<ul>\n<li><strong>DNS解析过程分类</strong></li>\n</ul>\n<p>DNS解析过程分为递归和迭代</p>\n<p><strong>递归</strong></p>\n<p>类型于<code>递归函数</code>，查询由对应的域名服务器查询，而不是本地域名服务器</p>\n<blockquote>\n<p>比如：</p>\n<p>查询到了<code>.</code>对应的根域名服务器，那么再查找顶级域名时，由对应的根域名服务器去请求查询顶级域名</p>\n</blockquote>\n<p><strong>迭代</strong></p>\n<p>每次查询都返回对应的IP地址，由本地域名服务器来请求</p>\n<blockquote>\n<p>比如：</p>\n<p>查询到了<code>.</code>对应的根域名服务器，将对应的IP地址返回给本地域名服务器，再由本地域名服务器来通过IP地址来请求查询顶级域名</p>\n</blockquote>\n<ul>\n<li><strong>DNS优化</strong></li>\n</ul>\n<p>因为DNS会向不同的域名服务器发送请求，所以会带来比较大的时间损耗，所以我们可以采用一些方式来优化一下</p>\n<ol>\n<li><p><strong>DNS预解析</strong></p>\n<p>用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行DNS解析。<br>可以在服务器中响应设置<code>X-DNS-Prefetch-Control</code>的值为on启动预解析</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;x-dns-prefetch-control&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对特定域名预解析</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">”dns-prefetch”</span> <span class=\"attr\">href</span>=<span class=\"string\">”//www.baidu.com”</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>域名收敛</strong></p>\n<p>建议将静态资源只放在一个域名下面，可以有效减少dns的请求</p>\n</li>\n</ol>\n<ul>\n<li><strong>DDOS 攻击</strong></li>\n</ul>\n<p>在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。</p>\n<p>防御方法有：</p>\n<ol>\n<li>备份网站</li>\n<li>HTTP拦截请求</li>\n<li>带宽扩容</li>\n<li>CDN</li>\n</ol>\n<hr>\n<h3 id=\"二、CDN\"><a href=\"#二、CDN\" class=\"headerlink\" title=\"二、CDN\"></a>二、CDN</h3><p>CDN内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>\n<p>典型的CDN系统由下面三个部分组成</p>\n<ul>\n<li><p>分发服务系统</p>\n<p>最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标</p>\n</li>\n<li><p>负载均衡系统</p>\n<p>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负 责节点内部的设备负载均衡</p>\n</li>\n<li><p>运营管理系统</p>\n<p>分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>\n</li>\n</ul>\n<h5 id=\"CDN的过程\"><a href=\"#CDN的过程\" class=\"headerlink\" title=\"CDN的过程\"></a>CDN的过程</h5><p><code>使用CDN的方法很简单，只需要修改自己的DNS解析，设置一个CNAME指向CDN服务商即可。</code></p>\n<p>用户访问未使用CDN缓存资源的过程为:</p>\n<ol>\n<li>浏览器通过前面提到的过程对域名进行解析，以得到此域名对应的IP地址；</li>\n<li>浏览器使用所得到的IP地址，向域名的服务主机发出数据访问请求；</li>\n<li>服务器向浏览器返回响应数据</li>\n</ol>\n<p>使用CDN后</p>\n<ol>\n<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li>\n<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</li>\n<li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li>\n<li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li>\n<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li>\n<li>全局负载均衡设备把服务器的IP地址返回给用户</li>\n<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>\n</ol>\n<h5 id=\"CDN的优点\"><a href=\"#CDN的优点\" class=\"headerlink\" title=\"CDN的优点\"></a>CDN的优点</h5><ol>\n<li>本地Cache加速，加快访问速度</li>\n<li>镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量</li>\n<li>远程加速，自动选择cache服务器</li>\n<li>带宽优化，分担网络流量，减轻压力，</li>\n<li>集群抗攻击</li>\n<li>节约成本</li>\n</ol>\n<hr>\n<p>参考文章：</p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2016/06/dns.html\">DNS 原理入门</a></p>\n<p><a href=\"https://juejin.cn/post/6844903590662766599\">CDN与DNS知识汇总</a></p>\n"},{"title":"网络：HTTP缓存","date":"2021-11-24T03:06:32.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/23/fa31uAzw7gLdn9P.jpg","_content":"\n# 网络：HTTP缓存\n\n缓存是为了可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力\n\nHTTP缓存分为`强缓存`、`协商缓存`，由不同的头部字段来实现\n\n## 一、强缓存\n\n实现强缓存由`Expires`、`Cache-Control`两个头部字段实现，如果不可以使用缓存就直接发送请求或进行协商缓存\n\n* **Expires**\n\n  `Expires`是HTTP/1.0提出的用来实现缓存的字段，是由服务器返回的资源过期日期，是一个绝对时间\n\n  浏览器在发送请求的时候，会与系统的日期时间与其对比，如果小于它就使用缓存，否则就发起请求获取资源\n\n  **缺点：因为是一个绝对的日期时间，所以可以通过修改系统时间来决定是否使用缓存**\n\n* **Cache-Control**\n\n  `Cache-Control`是HTTP/1.1提出的，通过设置不同的属性值来实现不同缓存方式\n\n  **如果Expires和Cache-Control同时存在，后者的优先级会更高**\n\n\n\n常用的属性值：\n\n* `max-age`：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效\n* `no-cache`：不使用强缓存，需要与服务器验证缓存是否新鲜\n* `no-store`：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源\n* `private`：专用于个人的缓存，中间代理、CDN 等不能缓存此响应\n* `public`：响应可以被中间代理、CDN 等缓存\n* `must-revalidate`：在缓存过期前可以使用，过期后必须向服务器验证\n* `s-max-age`：与`max-age`类似，决定中间代理、CDN能够缓存的秒数\n\n*** 可以设置多个属性值配合使用，用`;`分隔**\n\n\n\n## 二、协商缓存\n\n如果没有命中强缓存，就会进入协商缓存\n\n协商缓存不管资源有没有过期都会发送一次请求验证资源有没有过期\n\n如果没有过期返回状态码`304`，可以使用缓存，如果过期了会返回新的资源\n\n协商缓存相关的请求头部字段有`Last-Modified`，`Etag`，`If-Modified-Since`，`If-None-Modified`\n\n* **Last-Modified / If-Modified-Since**\n\n  `Last-Modified`是由服务器返回的，代表资源最后修改的时间\n\n  `If-Modified-Since`用于向服务器请求资源时，将原来的`Last-Modifeid`与服务端保存的资源最后修改时间进行对比，如果是一样的服务器就返回`304`，代表可以继续使用缓存，如果不一样，服务器返回新的资源以及新的最后修改时间`Last-Modifeid`返回给客户端，客户端继续将新的`Last-Modified`保存\n\n  **缺点：**\n\n    * **有时候资源更新频率是秒级的，Last-Modified/If-Modified-Since 会错误地返回 304**\n\n    * **如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304 ，上面的例子就说明了这个问题**\n\n* **Etag / If-None-Modified**\n\n  `Etag`和`Last-Modified`处理类似\n\n  `Etag`由服务器通过资源生成的唯一标识符，如果资源被修改，那么这个标识符就会重新计算\n\n  `If-None-Modified`用于向服务器请求资源时，将原来的`Etag`比较，一样就返回`304`，继续使用缓存，否则就返回新的资源以及新的`Etag`\n\n\n\n![1.png](https://i.loli.net/2021/11/24/xAwuOXG1EFifl4g.png)\n\n\n\n参考文章：\n\n[前端缓存最佳实践](https://juejin.cn/post/6844903737538920462)","source":"_posts/Internet-HTTP_Cache.md","raw":"---\ntitle: 网络：HTTP缓存\ndate: 2021-11-24 11:06:32\ncategories: 网络\ntags: [网络]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/23/fa31uAzw7gLdn9P.jpg\n---\n\n# 网络：HTTP缓存\n\n缓存是为了可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力\n\nHTTP缓存分为`强缓存`、`协商缓存`，由不同的头部字段来实现\n\n## 一、强缓存\n\n实现强缓存由`Expires`、`Cache-Control`两个头部字段实现，如果不可以使用缓存就直接发送请求或进行协商缓存\n\n* **Expires**\n\n  `Expires`是HTTP/1.0提出的用来实现缓存的字段，是由服务器返回的资源过期日期，是一个绝对时间\n\n  浏览器在发送请求的时候，会与系统的日期时间与其对比，如果小于它就使用缓存，否则就发起请求获取资源\n\n  **缺点：因为是一个绝对的日期时间，所以可以通过修改系统时间来决定是否使用缓存**\n\n* **Cache-Control**\n\n  `Cache-Control`是HTTP/1.1提出的，通过设置不同的属性值来实现不同缓存方式\n\n  **如果Expires和Cache-Control同时存在，后者的优先级会更高**\n\n\n\n常用的属性值：\n\n* `max-age`：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效\n* `no-cache`：不使用强缓存，需要与服务器验证缓存是否新鲜\n* `no-store`：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源\n* `private`：专用于个人的缓存，中间代理、CDN 等不能缓存此响应\n* `public`：响应可以被中间代理、CDN 等缓存\n* `must-revalidate`：在缓存过期前可以使用，过期后必须向服务器验证\n* `s-max-age`：与`max-age`类似，决定中间代理、CDN能够缓存的秒数\n\n*** 可以设置多个属性值配合使用，用`;`分隔**\n\n\n\n## 二、协商缓存\n\n如果没有命中强缓存，就会进入协商缓存\n\n协商缓存不管资源有没有过期都会发送一次请求验证资源有没有过期\n\n如果没有过期返回状态码`304`，可以使用缓存，如果过期了会返回新的资源\n\n协商缓存相关的请求头部字段有`Last-Modified`，`Etag`，`If-Modified-Since`，`If-None-Modified`\n\n* **Last-Modified / If-Modified-Since**\n\n  `Last-Modified`是由服务器返回的，代表资源最后修改的时间\n\n  `If-Modified-Since`用于向服务器请求资源时，将原来的`Last-Modifeid`与服务端保存的资源最后修改时间进行对比，如果是一样的服务器就返回`304`，代表可以继续使用缓存，如果不一样，服务器返回新的资源以及新的最后修改时间`Last-Modifeid`返回给客户端，客户端继续将新的`Last-Modified`保存\n\n  **缺点：**\n\n    * **有时候资源更新频率是秒级的，Last-Modified/If-Modified-Since 会错误地返回 304**\n\n    * **如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304 ，上面的例子就说明了这个问题**\n\n* **Etag / If-None-Modified**\n\n  `Etag`和`Last-Modified`处理类似\n\n  `Etag`由服务器通过资源生成的唯一标识符，如果资源被修改，那么这个标识符就会重新计算\n\n  `If-None-Modified`用于向服务器请求资源时，将原来的`Etag`比较，一样就返回`304`，继续使用缓存，否则就返回新的资源以及新的`Etag`\n\n\n\n![1.png](https://i.loli.net/2021/11/24/xAwuOXG1EFifl4g.png)\n\n\n\n参考文章：\n\n[前端缓存最佳实践](https://juejin.cn/post/6844903737538920462)","slug":"Internet-HTTP_Cache","published":1,"updated":"2021-11-24T03:07:06.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m4002bdswkes2p7m5s","content":"<h1 id=\"网络：HTTP缓存\"><a href=\"#网络：HTTP缓存\" class=\"headerlink\" title=\"网络：HTTP缓存\"></a>网络：HTTP缓存</h1><p>缓存是为了可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力</p>\n<p>HTTP缓存分为<code>强缓存</code>、<code>协商缓存</code>，由不同的头部字段来实现</p>\n<h2 id=\"一、强缓存\"><a href=\"#一、强缓存\" class=\"headerlink\" title=\"一、强缓存\"></a>一、强缓存</h2><p>实现强缓存由<code>Expires</code>、<code>Cache-Control</code>两个头部字段实现，如果不可以使用缓存就直接发送请求或进行协商缓存</p>\n<ul>\n<li><p><strong>Expires</strong></p>\n<p><code>Expires</code>是HTTP/1.0提出的用来实现缓存的字段，是由服务器返回的资源过期日期，是一个绝对时间</p>\n<p>浏览器在发送请求的时候，会与系统的日期时间与其对比，如果小于它就使用缓存，否则就发起请求获取资源</p>\n<p><strong>缺点：因为是一个绝对的日期时间，所以可以通过修改系统时间来决定是否使用缓存</strong></p>\n</li>\n<li><p><strong>Cache-Control</strong></p>\n<p><code>Cache-Control</code>是HTTP/1.1提出的，通过设置不同的属性值来实现不同缓存方式</p>\n<p><strong>如果Expires和Cache-Control同时存在，后者的优先级会更高</strong></p>\n</li>\n</ul>\n<p>常用的属性值：</p>\n<ul>\n<li><code>max-age</code>：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>\n<li><code>no-cache</code>：不使用强缓存，需要与服务器验证缓存是否新鲜</li>\n<li><code>no-store</code>：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li>\n<li><code>private</code>：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li>\n<li><code>public</code>：响应可以被中间代理、CDN 等缓存</li>\n<li><code>must-revalidate</code>：在缓存过期前可以使用，过期后必须向服务器验证</li>\n<li><code>s-max-age</code>：与<code>max-age</code>类似，决定中间代理、CDN能够缓存的秒数</li>\n</ul>\n<p><strong>* 可以设置多个属性值配合使用，用<code>;</code>分隔</strong></p>\n<h2 id=\"二、协商缓存\"><a href=\"#二、协商缓存\" class=\"headerlink\" title=\"二、协商缓存\"></a>二、协商缓存</h2><p>如果没有命中强缓存，就会进入协商缓存</p>\n<p>协商缓存不管资源有没有过期都会发送一次请求验证资源有没有过期</p>\n<p>如果没有过期返回状态码<code>304</code>，可以使用缓存，如果过期了会返回新的资源</p>\n<p>协商缓存相关的请求头部字段有<code>Last-Modified</code>，<code>Etag</code>，<code>If-Modified-Since</code>，<code>If-None-Modified</code></p>\n<ul>\n<li><p><strong>Last-Modified / If-Modified-Since</strong></p>\n<p><code>Last-Modified</code>是由服务器返回的，代表资源最后修改的时间</p>\n<p><code>If-Modified-Since</code>用于向服务器请求资源时，将原来的<code>Last-Modifeid</code>与服务端保存的资源最后修改时间进行对比，如果是一样的服务器就返回<code>304</code>，代表可以继续使用缓存，如果不一样，服务器返回新的资源以及新的最后修改时间<code>Last-Modifeid</code>返回给客户端，客户端继续将新的<code>Last-Modified</code>保存</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><p><strong>有时候资源更新频率是秒级的，Last-Modified/If-Modified-Since 会错误地返回 304</strong></p>\n</li>\n<li><p><strong>如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304 ，上面的例子就说明了这个问题</strong></p>\n</li>\n</ul>\n</li>\n<li><p><strong>Etag / If-None-Modified</strong></p>\n<p><code>Etag</code>和<code>Last-Modified</code>处理类似</p>\n<p><code>Etag</code>由服务器通过资源生成的唯一标识符，如果资源被修改，那么这个标识符就会重新计算</p>\n<p><code>If-None-Modified</code>用于向服务器请求资源时，将原来的<code>Etag</code>比较，一样就返回<code>304</code>，继续使用缓存，否则就返回新的资源以及新的<code>Etag</code></p>\n</li>\n</ul>\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2021/11/24/xAwuOXG1EFifl4g.png\" alt=\"1.png\"></p>\n<p>参考文章：</p>\n<p><a href=\"https://juejin.cn/post/6844903737538920462\">前端缓存最佳实践</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网络：HTTP缓存\"><a href=\"#网络：HTTP缓存\" class=\"headerlink\" title=\"网络：HTTP缓存\"></a>网络：HTTP缓存</h1><p>缓存是为了可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力</p>\n<p>HTTP缓存分为<code>强缓存</code>、<code>协商缓存</code>，由不同的头部字段来实现</p>\n<h2 id=\"一、强缓存\"><a href=\"#一、强缓存\" class=\"headerlink\" title=\"一、强缓存\"></a>一、强缓存</h2><p>实现强缓存由<code>Expires</code>、<code>Cache-Control</code>两个头部字段实现，如果不可以使用缓存就直接发送请求或进行协商缓存</p>\n<ul>\n<li><p><strong>Expires</strong></p>\n<p><code>Expires</code>是HTTP/1.0提出的用来实现缓存的字段，是由服务器返回的资源过期日期，是一个绝对时间</p>\n<p>浏览器在发送请求的时候，会与系统的日期时间与其对比，如果小于它就使用缓存，否则就发起请求获取资源</p>\n<p><strong>缺点：因为是一个绝对的日期时间，所以可以通过修改系统时间来决定是否使用缓存</strong></p>\n</li>\n<li><p><strong>Cache-Control</strong></p>\n<p><code>Cache-Control</code>是HTTP/1.1提出的，通过设置不同的属性值来实现不同缓存方式</p>\n<p><strong>如果Expires和Cache-Control同时存在，后者的优先级会更高</strong></p>\n</li>\n</ul>\n<p>常用的属性值：</p>\n<ul>\n<li><code>max-age</code>：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>\n<li><code>no-cache</code>：不使用强缓存，需要与服务器验证缓存是否新鲜</li>\n<li><code>no-store</code>：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li>\n<li><code>private</code>：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li>\n<li><code>public</code>：响应可以被中间代理、CDN 等缓存</li>\n<li><code>must-revalidate</code>：在缓存过期前可以使用，过期后必须向服务器验证</li>\n<li><code>s-max-age</code>：与<code>max-age</code>类似，决定中间代理、CDN能够缓存的秒数</li>\n</ul>\n<p><strong>* 可以设置多个属性值配合使用，用<code>;</code>分隔</strong></p>\n<h2 id=\"二、协商缓存\"><a href=\"#二、协商缓存\" class=\"headerlink\" title=\"二、协商缓存\"></a>二、协商缓存</h2><p>如果没有命中强缓存，就会进入协商缓存</p>\n<p>协商缓存不管资源有没有过期都会发送一次请求验证资源有没有过期</p>\n<p>如果没有过期返回状态码<code>304</code>，可以使用缓存，如果过期了会返回新的资源</p>\n<p>协商缓存相关的请求头部字段有<code>Last-Modified</code>，<code>Etag</code>，<code>If-Modified-Since</code>，<code>If-None-Modified</code></p>\n<ul>\n<li><p><strong>Last-Modified / If-Modified-Since</strong></p>\n<p><code>Last-Modified</code>是由服务器返回的，代表资源最后修改的时间</p>\n<p><code>If-Modified-Since</code>用于向服务器请求资源时，将原来的<code>Last-Modifeid</code>与服务端保存的资源最后修改时间进行对比，如果是一样的服务器就返回<code>304</code>，代表可以继续使用缓存，如果不一样，服务器返回新的资源以及新的最后修改时间<code>Last-Modifeid</code>返回给客户端，客户端继续将新的<code>Last-Modified</code>保存</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><p><strong>有时候资源更新频率是秒级的，Last-Modified/If-Modified-Since 会错误地返回 304</strong></p>\n</li>\n<li><p><strong>如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304 ，上面的例子就说明了这个问题</strong></p>\n</li>\n</ul>\n</li>\n<li><p><strong>Etag / If-None-Modified</strong></p>\n<p><code>Etag</code>和<code>Last-Modified</code>处理类似</p>\n<p><code>Etag</code>由服务器通过资源生成的唯一标识符，如果资源被修改，那么这个标识符就会重新计算</p>\n<p><code>If-None-Modified</code>用于向服务器请求资源时，将原来的<code>Etag</code>比较，一样就返回<code>304</code>，继续使用缓存，否则就返回新的资源以及新的<code>Etag</code></p>\n</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/11/24/xAwuOXG1EFifl4g.png\" alt=\"1.png\"></p>\n<p>参考文章：</p>\n<p><a href=\"https://juejin.cn/post/6844903737538920462\">前端缓存最佳实践</a></p>\n"},{"title":"网络：HTTP详解","date":"2021-11-23T03:23:27.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/23/fa31uAzw7gLdn9P.jpg","_content":"\n# 网络：HTTP详解\n\nHTTP超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议\n\n通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。\n\n## 一、工作原理\n\n客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n\n具体步骤如下：\n\n1. **客户端发送请求**\n\n   客户端根据域名、请求方法、URL、请求数据构建请求报文\n\n2. **客户端和服务端建立HTTP连接**\n\n   HTTP是基于TCP传输层协议，建立连接采用三次握手\n\n3. **服务器返回结果**\n\n   服务器返回状态码、提示语、响应数据构成的响应报文\n\n4. **客户端和服务器断开连接**\n\n   四次挥手断开连接\n\n## 二、特点\n\n1. **基于 请求-响应 的模式**\n\n   HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应\n\n2. **无状态保存**\n\n   　HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。\n\n3. **无连接**\n\n   无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。\n\n   但是现在的`HTTP/1.1`版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒\n\n## 三、请求报文\n\n用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。\n\n1. **请求报文**\n\n   ![img](https://i.loli.net/2021/11/23/hC9Gsc3D2vTwVmJ.png)\n\n2. **响应报文**\n\n   ![img](https://i.loli.net/2021/11/23/q9DrdT1yEzAYvKt.png)\n\n   下面逐个介绍报文中的各个部分~\n\n   **协议版本参考：**[github](https://withstudy.github.io/)\n\n## 四、请求方法\n\n* `GET`：get方法一般用于获取服务器资源。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作\n\n* `POST`：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有\n\n* `PUT`：向指定资源位置上传其最新内容\n\n* `DELETE`：请求服务器删除Request-URI所标识的资源\n\n* `HEAD`：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）\n\n* `OPTIONS`：options方法用于询问请求URI资源支持的方法\n* `TRACE`：回显服务器收到的请求，主要用于测试或诊断\n* `CONNECT`：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）\n\n> **经典面试题：GET和POST的区别**\n>\n> 1. GET方法的请求没吃得到的结果都是幂等的，也就是每次都是一样的，而POST是不一定的\n> 2. GET请求会被浏览器主动cache，而POST不会，除非手动设置\n> 3. GET请求只能进行URL编码，而POST支持多种编码方式\n> 4. GET请求在URL中传送的参数是有长度限制（浏览器的限制）的，而POST没有\n> 5. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息\n\n## 五、状态码\n\n状态代码的第一个数字代表当前响应的类型\n\n![img](https://i.loli.net/2021/11/23/1pwBQT2qmNtUd75.png)\n\n常见的状态码：\n\n* 100：请求成功，还有后续操作\n* 101：协议切换，比如HTTP升级为WS\n* 200：请求成功\n* 204：请求成功，但是没有实体内容\n* 206：分块请求成功\n* 301：永久重定向\n* 302：临时重定向\n* 304：资源未更改，缓存有效\n* 400：请求失败，请求参数或语义有误\n* 401：认证失败\n* 404：资源不存在\n* 405：请求方法错误\n* 500：服务器遇到了不知道如何处理的情况。\n\n**详细状态码请查看：**[MDN HTTP状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)\n\n## 六、头部字段\n\n头部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。\n\n头部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。\n\n首部字段根据实际用途被分为以下4种类型：\n\n* **通用头部字段**： 请求报文和响应报文两方都会使用的首部\n* **请求头部字段**：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息\n* **响应头部字段**：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n* **实体头部字段**：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。\n\n常见头部字段：\n\n1. **通用头部字段**\n   * **Cache-Control**：操作缓存的工作机制\n   * **Connection**：管理持久连接\n   * **Date**：表明创建 HTTP 报文的日期和时间\n   * **Upgrade**：用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信\n2. **请求头部字段**\n   * **Accept**：用户代理可处理的媒体类型\n   * **Accept-Charset**：优先的字符集\n   * **Accept-Encoding**：优先的字符编码\n   * **Accept-Language**： 优先的语言\n   * **Authorization**：Web认证信息\n   * **If-Modified-Since**：比较资源的更新时间\n   * **If-None-Match**：比较实体标记\n   * **Referer**：对请求中 URI 的原始获取方\n   * **User-Agent**：HTTP 客户端程序的信息\n3. **响应头部字段**\n   * **ETag**：资源的匹配信息\n   * **Location**：令客户端重定向至指定 URI\n4. **实体头部字段**\n   * **Allow**：资源可支持的 HTTP 方法\n   * **Content-Encoding**：实体主体适用的编码方式\n   * **Content-Language**：实体主体的自然语言\n   * **Content-Length**：实体主体的大小（单位：字节）\n   * **Content-Type**：实体主体的媒体类型\n   * **Expires**：实体主体过期的日期时间\n   * **Last-Modified**：资源的最后修改日期时间\n\n**详细头部字段请查看**：[MDN HTTP头部字段](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)\n\n\n\n参考文章：\n\n[HTTP协议超级详解](https://www.cnblogs.com/an-wen/p/11180076.html)\n\n[一篇文章带你详解 HTTP 协议](https://juejin.cn/post/6844903487218647048)\n\n","source":"_posts/Internet-HTTP_detail.md","raw":"---\ntitle: 网络：HTTP详解\ndate: 2021-11-23 11:23:27\ncategories: 网络\ntags: [网络]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/23/fa31uAzw7gLdn9P.jpg\n---\n\n# 网络：HTTP详解\n\nHTTP超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议\n\n通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。\n\n## 一、工作原理\n\n客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n\n具体步骤如下：\n\n1. **客户端发送请求**\n\n   客户端根据域名、请求方法、URL、请求数据构建请求报文\n\n2. **客户端和服务端建立HTTP连接**\n\n   HTTP是基于TCP传输层协议，建立连接采用三次握手\n\n3. **服务器返回结果**\n\n   服务器返回状态码、提示语、响应数据构成的响应报文\n\n4. **客户端和服务器断开连接**\n\n   四次挥手断开连接\n\n## 二、特点\n\n1. **基于 请求-响应 的模式**\n\n   HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应\n\n2. **无状态保存**\n\n   　HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。\n\n3. **无连接**\n\n   无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。\n\n   但是现在的`HTTP/1.1`版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒\n\n## 三、请求报文\n\n用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。\n\n1. **请求报文**\n\n   ![img](https://i.loli.net/2021/11/23/hC9Gsc3D2vTwVmJ.png)\n\n2. **响应报文**\n\n   ![img](https://i.loli.net/2021/11/23/q9DrdT1yEzAYvKt.png)\n\n   下面逐个介绍报文中的各个部分~\n\n   **协议版本参考：**[github](https://withstudy.github.io/)\n\n## 四、请求方法\n\n* `GET`：get方法一般用于获取服务器资源。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作\n\n* `POST`：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有\n\n* `PUT`：向指定资源位置上传其最新内容\n\n* `DELETE`：请求服务器删除Request-URI所标识的资源\n\n* `HEAD`：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）\n\n* `OPTIONS`：options方法用于询问请求URI资源支持的方法\n* `TRACE`：回显服务器收到的请求，主要用于测试或诊断\n* `CONNECT`：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）\n\n> **经典面试题：GET和POST的区别**\n>\n> 1. GET方法的请求没吃得到的结果都是幂等的，也就是每次都是一样的，而POST是不一定的\n> 2. GET请求会被浏览器主动cache，而POST不会，除非手动设置\n> 3. GET请求只能进行URL编码，而POST支持多种编码方式\n> 4. GET请求在URL中传送的参数是有长度限制（浏览器的限制）的，而POST没有\n> 5. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息\n\n## 五、状态码\n\n状态代码的第一个数字代表当前响应的类型\n\n![img](https://i.loli.net/2021/11/23/1pwBQT2qmNtUd75.png)\n\n常见的状态码：\n\n* 100：请求成功，还有后续操作\n* 101：协议切换，比如HTTP升级为WS\n* 200：请求成功\n* 204：请求成功，但是没有实体内容\n* 206：分块请求成功\n* 301：永久重定向\n* 302：临时重定向\n* 304：资源未更改，缓存有效\n* 400：请求失败，请求参数或语义有误\n* 401：认证失败\n* 404：资源不存在\n* 405：请求方法错误\n* 500：服务器遇到了不知道如何处理的情况。\n\n**详细状态码请查看：**[MDN HTTP状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)\n\n## 六、头部字段\n\n头部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。\n\n头部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。\n\n首部字段根据实际用途被分为以下4种类型：\n\n* **通用头部字段**： 请求报文和响应报文两方都会使用的首部\n* **请求头部字段**：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息\n* **响应头部字段**：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n* **实体头部字段**：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。\n\n常见头部字段：\n\n1. **通用头部字段**\n   * **Cache-Control**：操作缓存的工作机制\n   * **Connection**：管理持久连接\n   * **Date**：表明创建 HTTP 报文的日期和时间\n   * **Upgrade**：用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信\n2. **请求头部字段**\n   * **Accept**：用户代理可处理的媒体类型\n   * **Accept-Charset**：优先的字符集\n   * **Accept-Encoding**：优先的字符编码\n   * **Accept-Language**： 优先的语言\n   * **Authorization**：Web认证信息\n   * **If-Modified-Since**：比较资源的更新时间\n   * **If-None-Match**：比较实体标记\n   * **Referer**：对请求中 URI 的原始获取方\n   * **User-Agent**：HTTP 客户端程序的信息\n3. **响应头部字段**\n   * **ETag**：资源的匹配信息\n   * **Location**：令客户端重定向至指定 URI\n4. **实体头部字段**\n   * **Allow**：资源可支持的 HTTP 方法\n   * **Content-Encoding**：实体主体适用的编码方式\n   * **Content-Language**：实体主体的自然语言\n   * **Content-Length**：实体主体的大小（单位：字节）\n   * **Content-Type**：实体主体的媒体类型\n   * **Expires**：实体主体过期的日期时间\n   * **Last-Modified**：资源的最后修改日期时间\n\n**详细头部字段请查看**：[MDN HTTP头部字段](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)\n\n\n\n参考文章：\n\n[HTTP协议超级详解](https://www.cnblogs.com/an-wen/p/11180076.html)\n\n[一篇文章带你详解 HTTP 协议](https://juejin.cn/post/6844903487218647048)\n\n","slug":"Internet-HTTP_detail","published":1,"updated":"2021-11-23T03:25:50.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m5002edswkgwrzecku","content":"<h1 id=\"网络：HTTP详解\"><a href=\"#网络：HTTP详解\" class=\"headerlink\" title=\"网络：HTTP详解\"></a>网络：HTTP详解</h1><p>HTTP超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议</p>\n<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>\n<h2 id=\"一、工作原理\"><a href=\"#一、工作原理\" class=\"headerlink\" title=\"一、工作原理\"></a>一、工作原理</h2><p>客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li><p><strong>客户端发送请求</strong></p>\n<p>客户端根据域名、请求方法、URL、请求数据构建请求报文</p>\n</li>\n<li><p><strong>客户端和服务端建立HTTP连接</strong></p>\n<p>HTTP是基于TCP传输层协议，建立连接采用三次握手</p>\n</li>\n<li><p><strong>服务器返回结果</strong></p>\n<p>服务器返回状态码、提示语、响应数据构成的响应报文</p>\n</li>\n<li><p><strong>客户端和服务器断开连接</strong></p>\n<p>四次挥手断开连接</p>\n</li>\n</ol>\n<h2 id=\"二、特点\"><a href=\"#二、特点\" class=\"headerlink\" title=\"二、特点\"></a>二、特点</h2><ol>\n<li><p><strong>基于 请求-响应 的模式</strong></p>\n<p>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应</p>\n</li>\n<li><p><strong>无状态保存</strong></p>\n<p>　HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。</p>\n</li>\n<li><p><strong>无连接</strong></p>\n<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p>\n<p>但是现在的<code>HTTP/1.1</code>版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒</p>\n</li>\n</ol>\n<h2 id=\"三、请求报文\"><a href=\"#三、请求报文\" class=\"headerlink\" title=\"三、请求报文\"></a>三、请求报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>\n<ol>\n<li><p><strong>请求报文</strong></p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2021/11/23/hC9Gsc3D2vTwVmJ.png\" alt=\"img\"></p>\n</li>\n<li><p><strong>响应报文</strong></p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2021/11/23/q9DrdT1yEzAYvKt.png\" alt=\"img\"></p>\n<p>下面逐个介绍报文中的各个部分~</p>\n<p><strong>协议版本参考：</strong><a href=\"https://withstudy.github.io/\">github</a></p>\n</li>\n</ol>\n<h2 id=\"四、请求方法\"><a href=\"#四、请求方法\" class=\"headerlink\" title=\"四、请求方法\"></a>四、请求方法</h2><ul>\n<li><p><code>GET</code>：get方法一般用于获取服务器资源。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作</p>\n</li>\n<li><p><code>POST</code>：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有</p>\n</li>\n<li><p><code>PUT</code>：向指定资源位置上传其最新内容</p>\n</li>\n<li><p><code>DELETE</code>：请求服务器删除Request-URI所标识的资源</p>\n</li>\n<li><p><code>HEAD</code>：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）</p>\n</li>\n<li><p><code>OPTIONS</code>：options方法用于询问请求URI资源支持的方法</p>\n</li>\n<li><p><code>TRACE</code>：回显服务器收到的请求，主要用于测试或诊断</p>\n</li>\n<li><p><code>CONNECT</code>：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>经典面试题：GET和POST的区别</strong></p>\n<ol>\n<li>GET方法的请求没吃得到的结果都是幂等的，也就是每次都是一样的，而POST是不一定的</li>\n<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置</li>\n<li>GET请求只能进行URL编码，而POST支持多种编码方式</li>\n<li>GET请求在URL中传送的参数是有长度限制（浏览器的限制）的，而POST没有</li>\n<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li>\n</ol>\n</blockquote>\n<h2 id=\"五、状态码\"><a href=\"#五、状态码\" class=\"headerlink\" title=\"五、状态码\"></a>五、状态码</h2><p>状态代码的第一个数字代表当前响应的类型</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2021/11/23/1pwBQT2qmNtUd75.png\" alt=\"img\"></p>\n<p>常见的状态码：</p>\n<ul>\n<li>100：请求成功，还有后续操作</li>\n<li>101：协议切换，比如HTTP升级为WS</li>\n<li>200：请求成功</li>\n<li>204：请求成功，但是没有实体内容</li>\n<li>206：分块请求成功</li>\n<li>301：永久重定向</li>\n<li>302：临时重定向</li>\n<li>304：资源未更改，缓存有效</li>\n<li>400：请求失败，请求参数或语义有误</li>\n<li>401：认证失败</li>\n<li>404：资源不存在</li>\n<li>405：请求方法错误</li>\n<li>500：服务器遇到了不知道如何处理的情况。</li>\n</ul>\n<p><strong>详细状态码请查看：</strong><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\">MDN HTTP状态码</a></p>\n<h2 id=\"六、头部字段\"><a href=\"#六、头部字段\" class=\"headerlink\" title=\"六、头部字段\"></a>六、头部字段</h2><p>头部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。</p>\n<p>头部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。</p>\n<p>首部字段根据实际用途被分为以下4种类型：</p>\n<ul>\n<li><strong>通用头部字段</strong>： 请求报文和响应报文两方都会使用的首部</li>\n<li><strong>请求头部字段</strong>：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</li>\n<li><strong>响应头部字段</strong>：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>\n<li><strong>实体头部字段</strong>：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</li>\n</ul>\n<p>常见头部字段：</p>\n<ol>\n<li><strong>通用头部字段</strong><ul>\n<li><strong>Cache-Control</strong>：操作缓存的工作机制</li>\n<li><strong>Connection</strong>：管理持久连接</li>\n<li><strong>Date</strong>：表明创建 HTTP 报文的日期和时间</li>\n<li><strong>Upgrade</strong>：用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信</li>\n</ul>\n</li>\n<li><strong>请求头部字段</strong><ul>\n<li><strong>Accept</strong>：用户代理可处理的媒体类型</li>\n<li><strong>Accept-Charset</strong>：优先的字符集</li>\n<li><strong>Accept-Encoding</strong>：优先的字符编码</li>\n<li><strong>Accept-Language</strong>： 优先的语言</li>\n<li><strong>Authorization</strong>：Web认证信息</li>\n<li><strong>If-Modified-Since</strong>：比较资源的更新时间</li>\n<li><strong>If-None-Match</strong>：比较实体标记</li>\n<li><strong>Referer</strong>：对请求中 URI 的原始获取方</li>\n<li><strong>User-Agent</strong>：HTTP 客户端程序的信息</li>\n</ul>\n</li>\n<li><strong>响应头部字段</strong><ul>\n<li><strong>ETag</strong>：资源的匹配信息</li>\n<li><strong>Location</strong>：令客户端重定向至指定 URI</li>\n</ul>\n</li>\n<li><strong>实体头部字段</strong><ul>\n<li><strong>Allow</strong>：资源可支持的 HTTP 方法</li>\n<li><strong>Content-Encoding</strong>：实体主体适用的编码方式</li>\n<li><strong>Content-Language</strong>：实体主体的自然语言</li>\n<li><strong>Content-Length</strong>：实体主体的大小（单位：字节）</li>\n<li><strong>Content-Type</strong>：实体主体的媒体类型</li>\n<li><strong>Expires</strong>：实体主体过期的日期时间</li>\n<li><strong>Last-Modified</strong>：资源的最后修改日期时间</li>\n</ul>\n</li>\n</ol>\n<p><strong>详细头部字段请查看</strong>：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\">MDN HTTP头部字段</a></p>\n<p>参考文章：</p>\n<p><a href=\"https://www.cnblogs.com/an-wen/p/11180076.html\">HTTP协议超级详解</a></p>\n<p><a href=\"https://juejin.cn/post/6844903487218647048\">一篇文章带你详解 HTTP 协议</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网络：HTTP详解\"><a href=\"#网络：HTTP详解\" class=\"headerlink\" title=\"网络：HTTP详解\"></a>网络：HTTP详解</h1><p>HTTP超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议</p>\n<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>\n<h2 id=\"一、工作原理\"><a href=\"#一、工作原理\" class=\"headerlink\" title=\"一、工作原理\"></a>一、工作原理</h2><p>客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li><p><strong>客户端发送请求</strong></p>\n<p>客户端根据域名、请求方法、URL、请求数据构建请求报文</p>\n</li>\n<li><p><strong>客户端和服务端建立HTTP连接</strong></p>\n<p>HTTP是基于TCP传输层协议，建立连接采用三次握手</p>\n</li>\n<li><p><strong>服务器返回结果</strong></p>\n<p>服务器返回状态码、提示语、响应数据构成的响应报文</p>\n</li>\n<li><p><strong>客户端和服务器断开连接</strong></p>\n<p>四次挥手断开连接</p>\n</li>\n</ol>\n<h2 id=\"二、特点\"><a href=\"#二、特点\" class=\"headerlink\" title=\"二、特点\"></a>二、特点</h2><ol>\n<li><p><strong>基于 请求-响应 的模式</strong></p>\n<p>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应</p>\n</li>\n<li><p><strong>无状态保存</strong></p>\n<p>　HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。</p>\n</li>\n<li><p><strong>无连接</strong></p>\n<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p>\n<p>但是现在的<code>HTTP/1.1</code>版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒</p>\n</li>\n</ol>\n<h2 id=\"三、请求报文\"><a href=\"#三、请求报文\" class=\"headerlink\" title=\"三、请求报文\"></a>三、请求报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>\n<ol>\n<li><p><strong>请求报文</strong></p>\n<p><img src=\"https://i.loli.net/2021/11/23/hC9Gsc3D2vTwVmJ.png\" alt=\"img\"></p>\n</li>\n<li><p><strong>响应报文</strong></p>\n<p><img src=\"https://i.loli.net/2021/11/23/q9DrdT1yEzAYvKt.png\" alt=\"img\"></p>\n<p>下面逐个介绍报文中的各个部分~</p>\n<p><strong>协议版本参考：</strong><a href=\"https://withstudy.github.io/\">github</a></p>\n</li>\n</ol>\n<h2 id=\"四、请求方法\"><a href=\"#四、请求方法\" class=\"headerlink\" title=\"四、请求方法\"></a>四、请求方法</h2><ul>\n<li><p><code>GET</code>：get方法一般用于获取服务器资源。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作</p>\n</li>\n<li><p><code>POST</code>：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有</p>\n</li>\n<li><p><code>PUT</code>：向指定资源位置上传其最新内容</p>\n</li>\n<li><p><code>DELETE</code>：请求服务器删除Request-URI所标识的资源</p>\n</li>\n<li><p><code>HEAD</code>：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）</p>\n</li>\n<li><p><code>OPTIONS</code>：options方法用于询问请求URI资源支持的方法</p>\n</li>\n<li><p><code>TRACE</code>：回显服务器收到的请求，主要用于测试或诊断</p>\n</li>\n<li><p><code>CONNECT</code>：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>经典面试题：GET和POST的区别</strong></p>\n<ol>\n<li>GET方法的请求没吃得到的结果都是幂等的，也就是每次都是一样的，而POST是不一定的</li>\n<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置</li>\n<li>GET请求只能进行URL编码，而POST支持多种编码方式</li>\n<li>GET请求在URL中传送的参数是有长度限制（浏览器的限制）的，而POST没有</li>\n<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li>\n</ol>\n</blockquote>\n<h2 id=\"五、状态码\"><a href=\"#五、状态码\" class=\"headerlink\" title=\"五、状态码\"></a>五、状态码</h2><p>状态代码的第一个数字代表当前响应的类型</p>\n<p><img src=\"https://i.loli.net/2021/11/23/1pwBQT2qmNtUd75.png\" alt=\"img\"></p>\n<p>常见的状态码：</p>\n<ul>\n<li>100：请求成功，还有后续操作</li>\n<li>101：协议切换，比如HTTP升级为WS</li>\n<li>200：请求成功</li>\n<li>204：请求成功，但是没有实体内容</li>\n<li>206：分块请求成功</li>\n<li>301：永久重定向</li>\n<li>302：临时重定向</li>\n<li>304：资源未更改，缓存有效</li>\n<li>400：请求失败，请求参数或语义有误</li>\n<li>401：认证失败</li>\n<li>404：资源不存在</li>\n<li>405：请求方法错误</li>\n<li>500：服务器遇到了不知道如何处理的情况。</li>\n</ul>\n<p><strong>详细状态码请查看：</strong><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\">MDN HTTP状态码</a></p>\n<h2 id=\"六、头部字段\"><a href=\"#六、头部字段\" class=\"headerlink\" title=\"六、头部字段\"></a>六、头部字段</h2><p>头部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。</p>\n<p>头部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。</p>\n<p>首部字段根据实际用途被分为以下4种类型：</p>\n<ul>\n<li><strong>通用头部字段</strong>： 请求报文和响应报文两方都会使用的首部</li>\n<li><strong>请求头部字段</strong>：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</li>\n<li><strong>响应头部字段</strong>：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>\n<li><strong>实体头部字段</strong>：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</li>\n</ul>\n<p>常见头部字段：</p>\n<ol>\n<li><strong>通用头部字段</strong><ul>\n<li><strong>Cache-Control</strong>：操作缓存的工作机制</li>\n<li><strong>Connection</strong>：管理持久连接</li>\n<li><strong>Date</strong>：表明创建 HTTP 报文的日期和时间</li>\n<li><strong>Upgrade</strong>：用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信</li>\n</ul>\n</li>\n<li><strong>请求头部字段</strong><ul>\n<li><strong>Accept</strong>：用户代理可处理的媒体类型</li>\n<li><strong>Accept-Charset</strong>：优先的字符集</li>\n<li><strong>Accept-Encoding</strong>：优先的字符编码</li>\n<li><strong>Accept-Language</strong>： 优先的语言</li>\n<li><strong>Authorization</strong>：Web认证信息</li>\n<li><strong>If-Modified-Since</strong>：比较资源的更新时间</li>\n<li><strong>If-None-Match</strong>：比较实体标记</li>\n<li><strong>Referer</strong>：对请求中 URI 的原始获取方</li>\n<li><strong>User-Agent</strong>：HTTP 客户端程序的信息</li>\n</ul>\n</li>\n<li><strong>响应头部字段</strong><ul>\n<li><strong>ETag</strong>：资源的匹配信息</li>\n<li><strong>Location</strong>：令客户端重定向至指定 URI</li>\n</ul>\n</li>\n<li><strong>实体头部字段</strong><ul>\n<li><strong>Allow</strong>：资源可支持的 HTTP 方法</li>\n<li><strong>Content-Encoding</strong>：实体主体适用的编码方式</li>\n<li><strong>Content-Language</strong>：实体主体的自然语言</li>\n<li><strong>Content-Length</strong>：实体主体的大小（单位：字节）</li>\n<li><strong>Content-Type</strong>：实体主体的媒体类型</li>\n<li><strong>Expires</strong>：实体主体过期的日期时间</li>\n<li><strong>Last-Modified</strong>：资源的最后修改日期时间</li>\n</ul>\n</li>\n</ol>\n<p><strong>详细头部字段请查看</strong>：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\">MDN HTTP头部字段</a></p>\n<p>参考文章：</p>\n<p><a href=\"https://www.cnblogs.com/an-wen/p/11180076.html\">HTTP协议超级详解</a></p>\n<p><a href=\"https://juejin.cn/post/6844903487218647048\">一篇文章带你详解 HTTP 协议</a></p>\n"},{"title":"网络：HTTP发展过程","date":"2021-11-23T03:15:27.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/23/fa31uAzw7gLdn9P.jpg","_content":"\n# 网络：HTTP发展过程\n\nHTTP超文本传输协议，是浏览器和服务器之间的通信协议。\n\n1991 年 HTTP 正式诞生，到如今已经经过了几个版本的迭代，本片文章主要讲讲各个版本的特点。\n\n![img](http://img.mp.itc.cn/upload/20170731/1e77ec4574774711975f3bab2b339c40.jpg)\n\n## 一、HTTP/0.9\n\n`http0.9`最为最开始诞生的，只是一个简单的协议，只有一个GET方法，没有首部，目标只是为了用来获取HTML。\n\n## 二、HTTP/1.0\n\n随着HTTP的发展，只能传输文本内容已经满足不了需求，所以新增了：\n\n1. **增加了请求头和响应头**\n\n2. **任何格式的内容都可以发送**\n\n   **Content-Type**：服务器回应的时候告诉客户端数据类型是什么\n\n   **Accept**：请求时用于指定客户端接受哪些类型的信息\n\n   **Content-Encoding**：字段说明数据的压缩方法\n\n   **Accept-Encoding：**客户端在请求的时候说明自己可以接受那些压缩方法\n\n3. **引入了POST与HEAD命令**\n\n4. **可以缓存，使用`Expires`头部字段实现**\n\n## 三、HTTP/1.1\n\n`HTTP/1.1`是现在应用最为广泛的一个协议\n\n`HTTP/1.0`每次请求资源都需要新的一个HTTP请求，每次都会三次握手创建连接和四次挥手关闭连接增加了网络开销（`队头阻塞`），并且还是一发一收，增加了时间的消耗\n\n所以新增了：\n\n1. **持久连接**\n\n   TCP连接默认不关闭，可以被多个请求复用，户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。\n\n2. **管道机制**\n\n   在同一个TCP连接里面，客户端可以同时发送多个请求，不用等上一个请求返回，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求\n\n3. **允许范围请求，即在请求头中加入`Range`头部**\n\n4. **引入了更多的缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等**\n\n5. **新增PUT,OPTIONS,DELETE等请求方法**\n\n## 四、HTTP/2.0\n\n新增了：\n\n1. **复用TCP连接**\n\n   在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了\"队头堵塞\"。\n\n   ![img](http://img.mp.itc.cn/upload/20170731/fe1cda26ec2b4cf7b1a7b6a676c05fb5_th.jpg)\n\n2. **头信息压缩机制**\n\n   因为HTTP协议不带状态，所以请求的很多字段都是重复的，比如cookie，User Agent，每次请求都必须附带，会很浪费宽带也影响速度，对此作出了优化。\n   ① 头信息使用`gzip`或`compress`压缩后再发送\n\n   ② 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n\n3. **服务器推送**\n\n   允许服务器未经请求，主动向客户端发送资源\n\n4. **新的二进制格式**\n\n   `HTTP1.x`的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑`HTTP2.0`的协议解析决定采用二进制格式，实现方便且健壮。\n\n## 五、HTTP/3.0\n\n2018 年`HTTP/3` 将底层依赖的` TCP` 改成 `UDP`,`UDP` 相对于 `TCP` 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率很高，缺点就是没有确认机制来保证对方一定能收到数据。\n\n\n\n参考文章：\n\n[HTTP0.9/1.0/1.1/2](https://blog.csdn.net/qq_41047322/article/details/81152135)\n\n[前端基础篇之HTTP协议](https://juejin.cn/post/6844903844216832007)\n\n","source":"_posts/Internet-HTTP_history.md","raw":"---\ntitle: 网络：HTTP发展过程\ndate: 2021-11-23 11:15:27\ncategories: 网络\ntags: [网络]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/23/fa31uAzw7gLdn9P.jpg\n---\n\n# 网络：HTTP发展过程\n\nHTTP超文本传输协议，是浏览器和服务器之间的通信协议。\n\n1991 年 HTTP 正式诞生，到如今已经经过了几个版本的迭代，本片文章主要讲讲各个版本的特点。\n\n![img](http://img.mp.itc.cn/upload/20170731/1e77ec4574774711975f3bab2b339c40.jpg)\n\n## 一、HTTP/0.9\n\n`http0.9`最为最开始诞生的，只是一个简单的协议，只有一个GET方法，没有首部，目标只是为了用来获取HTML。\n\n## 二、HTTP/1.0\n\n随着HTTP的发展，只能传输文本内容已经满足不了需求，所以新增了：\n\n1. **增加了请求头和响应头**\n\n2. **任何格式的内容都可以发送**\n\n   **Content-Type**：服务器回应的时候告诉客户端数据类型是什么\n\n   **Accept**：请求时用于指定客户端接受哪些类型的信息\n\n   **Content-Encoding**：字段说明数据的压缩方法\n\n   **Accept-Encoding：**客户端在请求的时候说明自己可以接受那些压缩方法\n\n3. **引入了POST与HEAD命令**\n\n4. **可以缓存，使用`Expires`头部字段实现**\n\n## 三、HTTP/1.1\n\n`HTTP/1.1`是现在应用最为广泛的一个协议\n\n`HTTP/1.0`每次请求资源都需要新的一个HTTP请求，每次都会三次握手创建连接和四次挥手关闭连接增加了网络开销（`队头阻塞`），并且还是一发一收，增加了时间的消耗\n\n所以新增了：\n\n1. **持久连接**\n\n   TCP连接默认不关闭，可以被多个请求复用，户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。\n\n2. **管道机制**\n\n   在同一个TCP连接里面，客户端可以同时发送多个请求，不用等上一个请求返回，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求\n\n3. **允许范围请求，即在请求头中加入`Range`头部**\n\n4. **引入了更多的缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等**\n\n5. **新增PUT,OPTIONS,DELETE等请求方法**\n\n## 四、HTTP/2.0\n\n新增了：\n\n1. **复用TCP连接**\n\n   在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了\"队头堵塞\"。\n\n   ![img](http://img.mp.itc.cn/upload/20170731/fe1cda26ec2b4cf7b1a7b6a676c05fb5_th.jpg)\n\n2. **头信息压缩机制**\n\n   因为HTTP协议不带状态，所以请求的很多字段都是重复的，比如cookie，User Agent，每次请求都必须附带，会很浪费宽带也影响速度，对此作出了优化。\n   ① 头信息使用`gzip`或`compress`压缩后再发送\n\n   ② 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n\n3. **服务器推送**\n\n   允许服务器未经请求，主动向客户端发送资源\n\n4. **新的二进制格式**\n\n   `HTTP1.x`的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑`HTTP2.0`的协议解析决定采用二进制格式，实现方便且健壮。\n\n## 五、HTTP/3.0\n\n2018 年`HTTP/3` 将底层依赖的` TCP` 改成 `UDP`,`UDP` 相对于 `TCP` 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率很高，缺点就是没有确认机制来保证对方一定能收到数据。\n\n\n\n参考文章：\n\n[HTTP0.9/1.0/1.1/2](https://blog.csdn.net/qq_41047322/article/details/81152135)\n\n[前端基础篇之HTTP协议](https://juejin.cn/post/6844903844216832007)\n\n","slug":"Internet-HTTP_history","published":1,"updated":"2021-11-23T03:16:11.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m5002fdswketh205p9","content":"<h1 id=\"网络：HTTP发展过程\"><a href=\"#网络：HTTP发展过程\" class=\"headerlink\" title=\"网络：HTTP发展过程\"></a>网络：HTTP发展过程</h1><p>HTTP超文本传输协议，是浏览器和服务器之间的通信协议。</p>\n<p>1991 年 HTTP 正式诞生，到如今已经经过了几个版本的迭代，本片文章主要讲讲各个版本的特点。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"http://img.mp.itc.cn/upload/20170731/1e77ec4574774711975f3bab2b339c40.jpg\" alt=\"img\"></p>\n<h2 id=\"一、HTTP-0-9\"><a href=\"#一、HTTP-0-9\" class=\"headerlink\" title=\"一、HTTP/0.9\"></a>一、HTTP/0.9</h2><p><code>http0.9</code>最为最开始诞生的，只是一个简单的协议，只有一个GET方法，没有首部，目标只是为了用来获取HTML。</p>\n<h2 id=\"二、HTTP-1-0\"><a href=\"#二、HTTP-1-0\" class=\"headerlink\" title=\"二、HTTP/1.0\"></a>二、HTTP/1.0</h2><p>随着HTTP的发展，只能传输文本内容已经满足不了需求，所以新增了：</p>\n<ol>\n<li><p><strong>增加了请求头和响应头</strong></p>\n</li>\n<li><p><strong>任何格式的内容都可以发送</strong></p>\n<p><strong>Content-Type</strong>：服务器回应的时候告诉客户端数据类型是什么</p>\n<p><strong>Accept</strong>：请求时用于指定客户端接受哪些类型的信息</p>\n<p><strong>Content-Encoding</strong>：字段说明数据的压缩方法</p>\n<p><strong>Accept-Encoding：</strong>客户端在请求的时候说明自己可以接受那些压缩方法</p>\n</li>\n<li><p><strong>引入了POST与HEAD命令</strong></p>\n</li>\n<li><p><strong>可以缓存，使用<code>Expires</code>头部字段实现</strong></p>\n</li>\n</ol>\n<h2 id=\"三、HTTP-1-1\"><a href=\"#三、HTTP-1-1\" class=\"headerlink\" title=\"三、HTTP/1.1\"></a>三、HTTP/1.1</h2><p><code>HTTP/1.1</code>是现在应用最为广泛的一个协议</p>\n<p><code>HTTP/1.0</code>每次请求资源都需要新的一个HTTP请求，每次都会三次握手创建连接和四次挥手关闭连接增加了网络开销（<code>队头阻塞</code>），并且还是一发一收，增加了时间的消耗</p>\n<p>所以新增了：</p>\n<ol>\n<li><p><strong>持久连接</strong></p>\n<p>TCP连接默认不关闭，可以被多个请求复用，户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。</p>\n</li>\n<li><p><strong>管道机制</strong></p>\n<p>在同一个TCP连接里面，客户端可以同时发送多个请求，不用等上一个请求返回，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求</p>\n</li>\n<li><p><strong>允许范围请求，即在请求头中加入<code>Range</code>头部</strong></p>\n</li>\n<li><p><strong>引入了更多的缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等</strong></p>\n</li>\n<li><p><strong>新增PUT,OPTIONS,DELETE等请求方法</strong></p>\n</li>\n</ol>\n<h2 id=\"四、HTTP-2-0\"><a href=\"#四、HTTP-2-0\" class=\"headerlink\" title=\"四、HTTP/2.0\"></a>四、HTTP/2.0</h2><p>新增了：</p>\n<ol>\n<li><p><strong>复用TCP连接</strong></p>\n<p>在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"http://img.mp.itc.cn/upload/20170731/fe1cda26ec2b4cf7b1a7b6a676c05fb5_th.jpg\" alt=\"img\"></p>\n</li>\n<li><p><strong>头信息压缩机制</strong></p>\n<p>因为HTTP协议不带状态，所以请求的很多字段都是重复的，比如cookie，User Agent，每次请求都必须附带，会很浪费宽带也影响速度，对此作出了优化。<br>① 头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送</p>\n<p>② 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>\n</li>\n<li><p><strong>服务器推送</strong></p>\n<p>允许服务器未经请求，主动向客户端发送资源</p>\n</li>\n<li><p><strong>新的二进制格式</strong></p>\n<p><code>HTTP1.x</code>的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑<code>HTTP2.0</code>的协议解析决定采用二进制格式，实现方便且健壮。</p>\n</li>\n</ol>\n<h2 id=\"五、HTTP-3-0\"><a href=\"#五、HTTP-3-0\" class=\"headerlink\" title=\"五、HTTP/3.0\"></a>五、HTTP/3.0</h2><p>2018 年<code>HTTP/3</code> 将底层依赖的<code>TCP</code> 改成 <code>UDP</code>,<code>UDP</code> 相对于 <code>TCP</code> 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率很高，缺点就是没有确认机制来保证对方一定能收到数据。</p>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/qq_41047322/article/details/81152135\">HTTP0.9/1.0/1.1/2</a></p>\n<p><a href=\"https://juejin.cn/post/6844903844216832007\">前端基础篇之HTTP协议</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网络：HTTP发展过程\"><a href=\"#网络：HTTP发展过程\" class=\"headerlink\" title=\"网络：HTTP发展过程\"></a>网络：HTTP发展过程</h1><p>HTTP超文本传输协议，是浏览器和服务器之间的通信协议。</p>\n<p>1991 年 HTTP 正式诞生，到如今已经经过了几个版本的迭代，本片文章主要讲讲各个版本的特点。</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20170731/1e77ec4574774711975f3bab2b339c40.jpg\" alt=\"img\"></p>\n<h2 id=\"一、HTTP-0-9\"><a href=\"#一、HTTP-0-9\" class=\"headerlink\" title=\"一、HTTP/0.9\"></a>一、HTTP/0.9</h2><p><code>http0.9</code>最为最开始诞生的，只是一个简单的协议，只有一个GET方法，没有首部，目标只是为了用来获取HTML。</p>\n<h2 id=\"二、HTTP-1-0\"><a href=\"#二、HTTP-1-0\" class=\"headerlink\" title=\"二、HTTP/1.0\"></a>二、HTTP/1.0</h2><p>随着HTTP的发展，只能传输文本内容已经满足不了需求，所以新增了：</p>\n<ol>\n<li><p><strong>增加了请求头和响应头</strong></p>\n</li>\n<li><p><strong>任何格式的内容都可以发送</strong></p>\n<p><strong>Content-Type</strong>：服务器回应的时候告诉客户端数据类型是什么</p>\n<p><strong>Accept</strong>：请求时用于指定客户端接受哪些类型的信息</p>\n<p><strong>Content-Encoding</strong>：字段说明数据的压缩方法</p>\n<p><strong>Accept-Encoding：</strong>客户端在请求的时候说明自己可以接受那些压缩方法</p>\n</li>\n<li><p><strong>引入了POST与HEAD命令</strong></p>\n</li>\n<li><p><strong>可以缓存，使用<code>Expires</code>头部字段实现</strong></p>\n</li>\n</ol>\n<h2 id=\"三、HTTP-1-1\"><a href=\"#三、HTTP-1-1\" class=\"headerlink\" title=\"三、HTTP/1.1\"></a>三、HTTP/1.1</h2><p><code>HTTP/1.1</code>是现在应用最为广泛的一个协议</p>\n<p><code>HTTP/1.0</code>每次请求资源都需要新的一个HTTP请求，每次都会三次握手创建连接和四次挥手关闭连接增加了网络开销（<code>队头阻塞</code>），并且还是一发一收，增加了时间的消耗</p>\n<p>所以新增了：</p>\n<ol>\n<li><p><strong>持久连接</strong></p>\n<p>TCP连接默认不关闭，可以被多个请求复用，户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。</p>\n</li>\n<li><p><strong>管道机制</strong></p>\n<p>在同一个TCP连接里面，客户端可以同时发送多个请求，不用等上一个请求返回，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求</p>\n</li>\n<li><p><strong>允许范围请求，即在请求头中加入<code>Range</code>头部</strong></p>\n</li>\n<li><p><strong>引入了更多的缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等</strong></p>\n</li>\n<li><p><strong>新增PUT,OPTIONS,DELETE等请求方法</strong></p>\n</li>\n</ol>\n<h2 id=\"四、HTTP-2-0\"><a href=\"#四、HTTP-2-0\" class=\"headerlink\" title=\"四、HTTP/2.0\"></a>四、HTTP/2.0</h2><p>新增了：</p>\n<ol>\n<li><p><strong>复用TCP连接</strong></p>\n<p>在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20170731/fe1cda26ec2b4cf7b1a7b6a676c05fb5_th.jpg\" alt=\"img\"></p>\n</li>\n<li><p><strong>头信息压缩机制</strong></p>\n<p>因为HTTP协议不带状态，所以请求的很多字段都是重复的，比如cookie，User Agent，每次请求都必须附带，会很浪费宽带也影响速度，对此作出了优化。<br>① 头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送</p>\n<p>② 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>\n</li>\n<li><p><strong>服务器推送</strong></p>\n<p>允许服务器未经请求，主动向客户端发送资源</p>\n</li>\n<li><p><strong>新的二进制格式</strong></p>\n<p><code>HTTP1.x</code>的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑<code>HTTP2.0</code>的协议解析决定采用二进制格式，实现方便且健壮。</p>\n</li>\n</ol>\n<h2 id=\"五、HTTP-3-0\"><a href=\"#五、HTTP-3-0\" class=\"headerlink\" title=\"五、HTTP/3.0\"></a>五、HTTP/3.0</h2><p>2018 年<code>HTTP/3</code> 将底层依赖的<code>TCP</code> 改成 <code>UDP</code>,<code>UDP</code> 相对于 <code>TCP</code> 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率很高，缺点就是没有确认机制来保证对方一定能收到数据。</p>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/qq_41047322/article/details/81152135\">HTTP0.9/1.0/1.1/2</a></p>\n<p><a href=\"https://juejin.cn/post/6844903844216832007\">前端基础篇之HTTP协议</a></p>\n"},{"title":"网络：TCP与UDP总结","date":"2021-11-19T04:32:20.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/19/e5VrMkXSJm9qOKB.png","_content":"\n## 网络：TCP与UDP总结\n\nTCP与UDP都是传输层得协议\n\n### 一、UDP\n\n* udp是面向数据报文、无连接，不可靠得传输层协议\n\n无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。\n\n不可靠：不保证数据能够发送到对端、丢包之后也不会重传等措施\n\n* udp支持一对一、一对多、多对多、多对一得连接方式\n* udp一般用于实时通话、直播等领域\n\n常见使用UDP传输得应用层协议：\n\n* DNS：域名解析系统\n* DHCP：IP分发系统\n\n### 二、TCP\n\n* TCP是面向连接，可靠得传输层协议\n\n连接：每次都需要三次握手来建立连接，四次挥手来释放连接\n\n可靠：保证数据传输到对端，丢包会重新发送，还提供了拥塞控制等措施\n\n#### 1、三次握手\n\nTCP的三次握手可以确保连接双方都具有收发的能力\n\n* 首先客户端发送请求连接SYN，并带上自己的序列号\n\n  客户端表示我想要和你建立连接\n\n* 服务端接收到之后，需要发送ACK确认请求，并且也要发送SYN请求连接，并带上自己的序列号\n\n  服务端表示收到，我也想要和你建立连接\n\n* 客户端收到服务端的确认及请求连接之后，会再发送一次ACK确认请求，该次请求是可以带上数据的\n\n  客户端表示收到\n\n这样就建立了连接\n\n之后的每次请求都需要客户端发送一次确认来保证数据的正确到达，当然如果每次都需要一个请求来应答，比较耗费性能，TCP提供了拥塞窗口，后续会讲到\n\n#### 2、四次挥手\n\nTCP需要客户端和服务端都发送断开连接请求\n\n* 当客户端想要断开请求是，会发送FIN请求\n\n  客户端表示我想走了\n\n* 服务端收到客户端的断开请求后，会发送ACK请求，确认收到\n\n  服务端表示收到\n\n* 在收到客户端的断开请求之后，可能服务端还有数据没有发完，等发完之后，服务端也会发送一个FIN请求断开连接\n\n  服务端表示我也想走了\n\n* 客户端收到服务端的断开连接请求之后，会发送最后的一个ACK确认请求，发送之后，客户端还会等待2**MSL**的时间，保证服务端能够收到\n\n  客户端表示收到\n\n> * MSL：`MSL`是`TCP报文`在发送缓冲区的`最大生存`时间\n>\n> 通过TCP的三次握手和四次挥手很好的看到TCP的这种一发一确认的流程\n>\n> 每一个请求都需要一个确认来保证请求被准确的传递\n\n#### 3、重发超时的确定\n\n重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。\n\n在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。\n\n数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。\n\n数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。\n\n#### 4、拥塞窗口\n\n前面提到过，拥塞窗口是为了解决TCP每次发送都必须收到对方的确认才可以继续这样带来的性能损耗\n\n* **滑动窗口控制**\n\n拥塞窗口采用滑动窗口的方式\n\n窗口大小指的是无需等待确认应答而可以继续发送数据的最大值\n\n![滑动窗口](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/24bc98eb98bcfc56d647fd9f7b4e15f3~tplv-t2oaga2asx-watermark.awebp)\n\n上图中的窗口内的请求即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。\n\n在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。\n\n收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。\n\n* **窗口控制中的重发控制**\n\n① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的\n\n> 比如：上图中的发送了1001之后没有收到确认应答，但是在发送1002的时候收到了`下一个1003`的确认应答，则表示1001已经被正确收到\n\n![部分确认应答丢失](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/8d14175691e335ae297f5160ca7d4504~tplv-t2oaga2asx-watermark.awebp)\n\n② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。\n\n当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。\n\n> 比如：上图中的发送了1001之后没有收到确认应答，在发送1002 的时候收到了`下一个1001`的确认应答，则表示1001丢失了\n\n发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。\n\n![高速重发控制](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/573b1366725bd6fe13b0ecffcde34b40~tplv-t2oaga2asx-watermark.awebp)\n\n#### 5、拥塞控制\n\n有了拥塞窗口解决了一发一确认的性能损耗，但是由于不了解不同网络状态，仍可能产生其他问题，比如：对方的网络状态很差，一时间处理不了这么多请求，就会照成堵塞。\n\nTCP提供了慢开始、快重传、拥塞避免、快恢复\n\n* **慢开始**\n\n假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2\n\n当然慢开始也是有限制的，不可能让它一直这样增长，当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法\n\n* **拥塞避免**\n\n，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法\n\n* **快重传**\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期\n\n* **快恢复**\n\n采用快恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。\n\n当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n\n考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。\n\n![4~SOXTR_NJ7``4QLRCJ@0CK.png](https://i.loli.net/2021/11/19/kLEI69eoRrNXa2Z.png)\n参考链接：\n\n[TCP的拥塞控制](https://www.cnblogs.com/wuchanming/p/4422779.html)\n\n[TCP的拥塞控制（详解）](https://blog.csdn.net/qq_41431406/article/details/97926927)\n\n[TCP和UDP详解(非常详细)](https://blog.csdn.net/hansionz/article/details/86435127)\n\n[一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）](https://juejin.cn/post/6844903510509633550)\n\n","source":"_posts/Internet-TCP_UDP.md","raw":"---\ntitle: 网络：TCP与UDP总结\ndate: 2021-11-19 12:32:20\ncategories:  网络\ntags: [网络]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/19/e5VrMkXSJm9qOKB.png\n---\n\n## 网络：TCP与UDP总结\n\nTCP与UDP都是传输层得协议\n\n### 一、UDP\n\n* udp是面向数据报文、无连接，不可靠得传输层协议\n\n无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。\n\n不可靠：不保证数据能够发送到对端、丢包之后也不会重传等措施\n\n* udp支持一对一、一对多、多对多、多对一得连接方式\n* udp一般用于实时通话、直播等领域\n\n常见使用UDP传输得应用层协议：\n\n* DNS：域名解析系统\n* DHCP：IP分发系统\n\n### 二、TCP\n\n* TCP是面向连接，可靠得传输层协议\n\n连接：每次都需要三次握手来建立连接，四次挥手来释放连接\n\n可靠：保证数据传输到对端，丢包会重新发送，还提供了拥塞控制等措施\n\n#### 1、三次握手\n\nTCP的三次握手可以确保连接双方都具有收发的能力\n\n* 首先客户端发送请求连接SYN，并带上自己的序列号\n\n  客户端表示我想要和你建立连接\n\n* 服务端接收到之后，需要发送ACK确认请求，并且也要发送SYN请求连接，并带上自己的序列号\n\n  服务端表示收到，我也想要和你建立连接\n\n* 客户端收到服务端的确认及请求连接之后，会再发送一次ACK确认请求，该次请求是可以带上数据的\n\n  客户端表示收到\n\n这样就建立了连接\n\n之后的每次请求都需要客户端发送一次确认来保证数据的正确到达，当然如果每次都需要一个请求来应答，比较耗费性能，TCP提供了拥塞窗口，后续会讲到\n\n#### 2、四次挥手\n\nTCP需要客户端和服务端都发送断开连接请求\n\n* 当客户端想要断开请求是，会发送FIN请求\n\n  客户端表示我想走了\n\n* 服务端收到客户端的断开请求后，会发送ACK请求，确认收到\n\n  服务端表示收到\n\n* 在收到客户端的断开请求之后，可能服务端还有数据没有发完，等发完之后，服务端也会发送一个FIN请求断开连接\n\n  服务端表示我也想走了\n\n* 客户端收到服务端的断开连接请求之后，会发送最后的一个ACK确认请求，发送之后，客户端还会等待2**MSL**的时间，保证服务端能够收到\n\n  客户端表示收到\n\n> * MSL：`MSL`是`TCP报文`在发送缓冲区的`最大生存`时间\n>\n> 通过TCP的三次握手和四次挥手很好的看到TCP的这种一发一确认的流程\n>\n> 每一个请求都需要一个确认来保证请求被准确的传递\n\n#### 3、重发超时的确定\n\n重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。\n\n在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。\n\n数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。\n\n数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。\n\n#### 4、拥塞窗口\n\n前面提到过，拥塞窗口是为了解决TCP每次发送都必须收到对方的确认才可以继续这样带来的性能损耗\n\n* **滑动窗口控制**\n\n拥塞窗口采用滑动窗口的方式\n\n窗口大小指的是无需等待确认应答而可以继续发送数据的最大值\n\n![滑动窗口](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/24bc98eb98bcfc56d647fd9f7b4e15f3~tplv-t2oaga2asx-watermark.awebp)\n\n上图中的窗口内的请求即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。\n\n在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。\n\n收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。\n\n* **窗口控制中的重发控制**\n\n① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的\n\n> 比如：上图中的发送了1001之后没有收到确认应答，但是在发送1002的时候收到了`下一个1003`的确认应答，则表示1001已经被正确收到\n\n![部分确认应答丢失](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/8d14175691e335ae297f5160ca7d4504~tplv-t2oaga2asx-watermark.awebp)\n\n② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。\n\n当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。\n\n> 比如：上图中的发送了1001之后没有收到确认应答，在发送1002 的时候收到了`下一个1001`的确认应答，则表示1001丢失了\n\n发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。\n\n![高速重发控制](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/573b1366725bd6fe13b0ecffcde34b40~tplv-t2oaga2asx-watermark.awebp)\n\n#### 5、拥塞控制\n\n有了拥塞窗口解决了一发一确认的性能损耗，但是由于不了解不同网络状态，仍可能产生其他问题，比如：对方的网络状态很差，一时间处理不了这么多请求，就会照成堵塞。\n\nTCP提供了慢开始、快重传、拥塞避免、快恢复\n\n* **慢开始**\n\n假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2\n\n当然慢开始也是有限制的，不可能让它一直这样增长，当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法\n\n* **拥塞避免**\n\n，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法\n\n* **快重传**\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期\n\n* **快恢复**\n\n采用快恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。\n\n当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n\n考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。\n\n![4~SOXTR_NJ7``4QLRCJ@0CK.png](https://i.loli.net/2021/11/19/kLEI69eoRrNXa2Z.png)\n参考链接：\n\n[TCP的拥塞控制](https://www.cnblogs.com/wuchanming/p/4422779.html)\n\n[TCP的拥塞控制（详解）](https://blog.csdn.net/qq_41431406/article/details/97926927)\n\n[TCP和UDP详解(非常详细)](https://blog.csdn.net/hansionz/article/details/86435127)\n\n[一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）](https://juejin.cn/post/6844903510509633550)\n\n","slug":"Internet-TCP_UDP","published":1,"updated":"2021-11-22T02:37:44.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m6002gdswkeasof962","content":"<h2 id=\"网络：TCP与UDP总结\"><a href=\"#网络：TCP与UDP总结\" class=\"headerlink\" title=\"网络：TCP与UDP总结\"></a>网络：TCP与UDP总结</h2><p>TCP与UDP都是传输层得协议</p>\n<h3 id=\"一、UDP\"><a href=\"#一、UDP\" class=\"headerlink\" title=\"一、UDP\"></a>一、UDP</h3><ul>\n<li>udp是面向数据报文、无连接，不可靠得传输层协议</li>\n</ul>\n<p>无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。</p>\n<p>不可靠：不保证数据能够发送到对端、丢包之后也不会重传等措施</p>\n<ul>\n<li>udp支持一对一、一对多、多对多、多对一得连接方式</li>\n<li>udp一般用于实时通话、直播等领域</li>\n</ul>\n<p>常见使用UDP传输得应用层协议：</p>\n<ul>\n<li>DNS：域名解析系统</li>\n<li>DHCP：IP分发系统</li>\n</ul>\n<h3 id=\"二、TCP\"><a href=\"#二、TCP\" class=\"headerlink\" title=\"二、TCP\"></a>二、TCP</h3><ul>\n<li>TCP是面向连接，可靠得传输层协议</li>\n</ul>\n<p>连接：每次都需要三次握手来建立连接，四次挥手来释放连接</p>\n<p>可靠：保证数据传输到对端，丢包会重新发送，还提供了拥塞控制等措施</p>\n<h4 id=\"1、三次握手\"><a href=\"#1、三次握手\" class=\"headerlink\" title=\"1、三次握手\"></a>1、三次握手</h4><p>TCP的三次握手可以确保连接双方都具有收发的能力</p>\n<ul>\n<li><p>首先客户端发送请求连接SYN，并带上自己的序列号</p>\n<p>客户端表示我想要和你建立连接</p>\n</li>\n<li><p>服务端接收到之后，需要发送ACK确认请求，并且也要发送SYN请求连接，并带上自己的序列号</p>\n<p>服务端表示收到，我也想要和你建立连接</p>\n</li>\n<li><p>客户端收到服务端的确认及请求连接之后，会再发送一次ACK确认请求，该次请求是可以带上数据的</p>\n<p>客户端表示收到</p>\n</li>\n</ul>\n<p>这样就建立了连接</p>\n<p>之后的每次请求都需要客户端发送一次确认来保证数据的正确到达，当然如果每次都需要一个请求来应答，比较耗费性能，TCP提供了拥塞窗口，后续会讲到</p>\n<h4 id=\"2、四次挥手\"><a href=\"#2、四次挥手\" class=\"headerlink\" title=\"2、四次挥手\"></a>2、四次挥手</h4><p>TCP需要客户端和服务端都发送断开连接请求</p>\n<ul>\n<li><p>当客户端想要断开请求是，会发送FIN请求</p>\n<p>客户端表示我想走了</p>\n</li>\n<li><p>服务端收到客户端的断开请求后，会发送ACK请求，确认收到</p>\n<p>服务端表示收到</p>\n</li>\n<li><p>在收到客户端的断开请求之后，可能服务端还有数据没有发完，等发完之后，服务端也会发送一个FIN请求断开连接</p>\n<p>服务端表示我也想走了</p>\n</li>\n<li><p>客户端收到服务端的断开连接请求之后，会发送最后的一个ACK确认请求，发送之后，客户端还会等待2<strong>MSL</strong>的时间，保证服务端能够收到</p>\n<p>客户端表示收到</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>MSL：<code>MSL</code>是<code>TCP报文</code>在发送缓冲区的<code>最大生存</code>时间</li>\n</ul>\n<p>通过TCP的三次握手和四次挥手很好的看到TCP的这种一发一确认的流程</p>\n<p>每一个请求都需要一个确认来保证请求被准确的传递</p>\n</blockquote>\n<h4 id=\"3、重发超时的确定\"><a href=\"#3、重发超时的确定\" class=\"headerlink\" title=\"3、重发超时的确定\"></a>3、重发超时的确定</h4><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。</p>\n<p>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</p>\n<p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>\n<p>数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>\n<h4 id=\"4、拥塞窗口\"><a href=\"#4、拥塞窗口\" class=\"headerlink\" title=\"4、拥塞窗口\"></a>4、拥塞窗口</h4><p>前面提到过，拥塞窗口是为了解决TCP每次发送都必须收到对方的确认才可以继续这样带来的性能损耗</p>\n<ul>\n<li><strong>滑动窗口控制</strong></li>\n</ul>\n<p>拥塞窗口采用滑动窗口的方式</p>\n<p>窗口大小指的是无需等待确认应答而可以继续发送数据的最大值</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/24bc98eb98bcfc56d647fd9f7b4e15f3~tplv-t2oaga2asx-watermark.awebp\" alt=\"滑动窗口\"></p>\n<p>上图中的窗口内的请求即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>\n<p>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>\n<p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</p>\n<ul>\n<li><strong>窗口控制中的重发控制</strong></li>\n</ul>\n<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的</p>\n<blockquote>\n<p>比如：上图中的发送了1001之后没有收到确认应答，但是在发送1002的时候收到了<code>下一个1003</code>的确认应答，则表示1001已经被正确收到</p>\n</blockquote>\n<p><img src= \"/img/loading.gif\" data-src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/8d14175691e335ae297f5160ca7d4504~tplv-t2oaga2asx-watermark.awebp\" alt=\"部分确认应答丢失\"></p>\n<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。</p>\n<p>当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。</p>\n<blockquote>\n<p>比如：上图中的发送了1001之后没有收到确认应答，在发送1002 的时候收到了<code>下一个1001</code>的确认应答，则表示1001丢失了</p>\n</blockquote>\n<p>发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/573b1366725bd6fe13b0ecffcde34b40~tplv-t2oaga2asx-watermark.awebp\" alt=\"高速重发控制\"></p>\n<h4 id=\"5、拥塞控制\"><a href=\"#5、拥塞控制\" class=\"headerlink\" title=\"5、拥塞控制\"></a>5、拥塞控制</h4><p>有了拥塞窗口解决了一发一确认的性能损耗，但是由于不了解不同网络状态，仍可能产生其他问题，比如：对方的网络状态很差，一时间处理不了这么多请求，就会照成堵塞。</p>\n<p>TCP提供了慢开始、快重传、拥塞避免、快恢复</p>\n<ul>\n<li><strong>慢开始</strong></li>\n</ul>\n<p>假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2</p>\n<p>当然慢开始也是有限制的，不可能让它一直这样增长，当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法</p>\n<ul>\n<li><strong>拥塞避免</strong></li>\n</ul>\n<p>，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法</p>\n<ul>\n<li><strong>快重传</strong></li>\n</ul>\n<p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</p>\n<ul>\n<li><strong>快恢复</strong></li>\n</ul>\n<p>采用快恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。</p>\n<p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</p>\n<p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2021/11/19/kLEI69eoRrNXa2Z.png\" alt=\"4~SOXTR_NJ7``4QLRCJ@0CK.png\"><br>参考链接：</p>\n<p><a href=\"https://www.cnblogs.com/wuchanming/p/4422779.html\">TCP的拥塞控制</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41431406/article/details/97926927\">TCP的拥塞控制（详解）</a></p>\n<p><a href=\"https://blog.csdn.net/hansionz/article/details/86435127\">TCP和UDP详解(非常详细)</a></p>\n<p><a href=\"https://juejin.cn/post/6844903510509633550\">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"网络：TCP与UDP总结\"><a href=\"#网络：TCP与UDP总结\" class=\"headerlink\" title=\"网络：TCP与UDP总结\"></a>网络：TCP与UDP总结</h2><p>TCP与UDP都是传输层得协议</p>\n<h3 id=\"一、UDP\"><a href=\"#一、UDP\" class=\"headerlink\" title=\"一、UDP\"></a>一、UDP</h3><ul>\n<li>udp是面向数据报文、无连接，不可靠得传输层协议</li>\n</ul>\n<p>无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。</p>\n<p>不可靠：不保证数据能够发送到对端、丢包之后也不会重传等措施</p>\n<ul>\n<li>udp支持一对一、一对多、多对多、多对一得连接方式</li>\n<li>udp一般用于实时通话、直播等领域</li>\n</ul>\n<p>常见使用UDP传输得应用层协议：</p>\n<ul>\n<li>DNS：域名解析系统</li>\n<li>DHCP：IP分发系统</li>\n</ul>\n<h3 id=\"二、TCP\"><a href=\"#二、TCP\" class=\"headerlink\" title=\"二、TCP\"></a>二、TCP</h3><ul>\n<li>TCP是面向连接，可靠得传输层协议</li>\n</ul>\n<p>连接：每次都需要三次握手来建立连接，四次挥手来释放连接</p>\n<p>可靠：保证数据传输到对端，丢包会重新发送，还提供了拥塞控制等措施</p>\n<h4 id=\"1、三次握手\"><a href=\"#1、三次握手\" class=\"headerlink\" title=\"1、三次握手\"></a>1、三次握手</h4><p>TCP的三次握手可以确保连接双方都具有收发的能力</p>\n<ul>\n<li><p>首先客户端发送请求连接SYN，并带上自己的序列号</p>\n<p>客户端表示我想要和你建立连接</p>\n</li>\n<li><p>服务端接收到之后，需要发送ACK确认请求，并且也要发送SYN请求连接，并带上自己的序列号</p>\n<p>服务端表示收到，我也想要和你建立连接</p>\n</li>\n<li><p>客户端收到服务端的确认及请求连接之后，会再发送一次ACK确认请求，该次请求是可以带上数据的</p>\n<p>客户端表示收到</p>\n</li>\n</ul>\n<p>这样就建立了连接</p>\n<p>之后的每次请求都需要客户端发送一次确认来保证数据的正确到达，当然如果每次都需要一个请求来应答，比较耗费性能，TCP提供了拥塞窗口，后续会讲到</p>\n<h4 id=\"2、四次挥手\"><a href=\"#2、四次挥手\" class=\"headerlink\" title=\"2、四次挥手\"></a>2、四次挥手</h4><p>TCP需要客户端和服务端都发送断开连接请求</p>\n<ul>\n<li><p>当客户端想要断开请求是，会发送FIN请求</p>\n<p>客户端表示我想走了</p>\n</li>\n<li><p>服务端收到客户端的断开请求后，会发送ACK请求，确认收到</p>\n<p>服务端表示收到</p>\n</li>\n<li><p>在收到客户端的断开请求之后，可能服务端还有数据没有发完，等发完之后，服务端也会发送一个FIN请求断开连接</p>\n<p>服务端表示我也想走了</p>\n</li>\n<li><p>客户端收到服务端的断开连接请求之后，会发送最后的一个ACK确认请求，发送之后，客户端还会等待2<strong>MSL</strong>的时间，保证服务端能够收到</p>\n<p>客户端表示收到</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>MSL：<code>MSL</code>是<code>TCP报文</code>在发送缓冲区的<code>最大生存</code>时间</li>\n</ul>\n<p>通过TCP的三次握手和四次挥手很好的看到TCP的这种一发一确认的流程</p>\n<p>每一个请求都需要一个确认来保证请求被准确的传递</p>\n</blockquote>\n<h4 id=\"3、重发超时的确定\"><a href=\"#3、重发超时的确定\" class=\"headerlink\" title=\"3、重发超时的确定\"></a>3、重发超时的确定</h4><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。</p>\n<p>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</p>\n<p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>\n<p>数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>\n<h4 id=\"4、拥塞窗口\"><a href=\"#4、拥塞窗口\" class=\"headerlink\" title=\"4、拥塞窗口\"></a>4、拥塞窗口</h4><p>前面提到过，拥塞窗口是为了解决TCP每次发送都必须收到对方的确认才可以继续这样带来的性能损耗</p>\n<ul>\n<li><strong>滑动窗口控制</strong></li>\n</ul>\n<p>拥塞窗口采用滑动窗口的方式</p>\n<p>窗口大小指的是无需等待确认应答而可以继续发送数据的最大值</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/24bc98eb98bcfc56d647fd9f7b4e15f3~tplv-t2oaga2asx-watermark.awebp\" alt=\"滑动窗口\"></p>\n<p>上图中的窗口内的请求即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>\n<p>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>\n<p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</p>\n<ul>\n<li><strong>窗口控制中的重发控制</strong></li>\n</ul>\n<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的</p>\n<blockquote>\n<p>比如：上图中的发送了1001之后没有收到确认应答，但是在发送1002的时候收到了<code>下一个1003</code>的确认应答，则表示1001已经被正确收到</p>\n</blockquote>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/8d14175691e335ae297f5160ca7d4504~tplv-t2oaga2asx-watermark.awebp\" alt=\"部分确认应答丢失\"></p>\n<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。</p>\n<p>当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。</p>\n<blockquote>\n<p>比如：上图中的发送了1001之后没有收到确认应答，在发送1002 的时候收到了<code>下一个1001</code>的确认应答，则表示1001丢失了</p>\n</blockquote>\n<p>发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/573b1366725bd6fe13b0ecffcde34b40~tplv-t2oaga2asx-watermark.awebp\" alt=\"高速重发控制\"></p>\n<h4 id=\"5、拥塞控制\"><a href=\"#5、拥塞控制\" class=\"headerlink\" title=\"5、拥塞控制\"></a>5、拥塞控制</h4><p>有了拥塞窗口解决了一发一确认的性能损耗，但是由于不了解不同网络状态，仍可能产生其他问题，比如：对方的网络状态很差，一时间处理不了这么多请求，就会照成堵塞。</p>\n<p>TCP提供了慢开始、快重传、拥塞避免、快恢复</p>\n<ul>\n<li><strong>慢开始</strong></li>\n</ul>\n<p>假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2</p>\n<p>当然慢开始也是有限制的，不可能让它一直这样增长，当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法</p>\n<ul>\n<li><strong>拥塞避免</strong></li>\n</ul>\n<p>，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法</p>\n<ul>\n<li><strong>快重传</strong></li>\n</ul>\n<p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</p>\n<ul>\n<li><strong>快恢复</strong></li>\n</ul>\n<p>采用快恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。</p>\n<p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</p>\n<p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>\n<p><img src=\"https://i.loli.net/2021/11/19/kLEI69eoRrNXa2Z.png\" alt=\"4~SOXTR_NJ7``4QLRCJ@0CK.png\"><br>参考链接：</p>\n<p><a href=\"https://www.cnblogs.com/wuchanming/p/4422779.html\">TCP的拥塞控制</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41431406/article/details/97926927\">TCP的拥塞控制（详解）</a></p>\n<p><a href=\"https://blog.csdn.net/hansionz/article/details/86435127\">TCP和UDP详解(非常详细)</a></p>\n<p><a href=\"https://juejin.cn/post/6844903510509633550\">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p>\n"},{"title":"Nginx 安装与使用","date":"2022-01-06T07:01:27.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/01/06/Bj5oVxJmUfPwYLA.jpg","_content":"\n# Nginx 安装与使用\n\n**首先安装一些工具**\n\n```shell\nyum install -y wget  \nyum install -y vim-enhanced  \nyum install -y make cmake gcc gcc-c++  \n\nyum install -y pcre pcre-devel\nyum install -y zlib zlib-devel\nyum install -y openssl openssl-devel\n```\n\n> wget是一个下载文件的工具，它用在命令行下。\n\n> Vim是一个类似于 [Vi](http://baike.baidu.com/subview/27682/6112795.htm) 的著名的功能强大、高度可定制的 [文本编辑器](http://baike.baidu.com/view/487023.htm) \n\n> g++编译cpp文件\n\n> gcc编译c文件\n\n> make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。\n\n> *PCRE*是一个Perl库，包括 perl 兼容的正则表达式库\n\n> *zlib*是提供数据压缩用的函式库\n\n> openssl在计算机网络上，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上\n\n* 第一种方式（推荐）\n\n```js\nyum install nginx\n//安装后的目录在 /etc/nginx\n```\n\n来安装 Nginx，然后我们在命令行中 `nginx -v` 就可以看到具体的 Nginx 版本信息，也就安装完毕了\n\n* 第二种方式\n\n```js\nwget http://nginx.org/download/nginx-1.6.2.tar.gz //下载nginx安装包\ntar -zxvf nginx-1.6.2.tar.gz -C /usr/local/  //解压nginx-1.6.2.tar.gz到/usr/local/目录下\n//进入nginx-1.6.2目录然后在执行./configure命令\n[root@MiWiFi-R3-srv nginx-1.6.2]# ./configure --prefix=/usr/local/nginx\n//编译安装\n[root@MiWiFi-R3-srv nginx-1.6.2]# make && make install\n```\n\n**命令**\n\n**nginx -t ** ：验证nginx配置文件是否正确\n\n**netstat -ntlp **：用于显示各种网络相关信息,如网络连接,路由表,接口状态 ，连接,\n\n如果安装启动之后，访问不到，查看服务器得安全组配置，有没有对应得端口\n\n**安装nvm**\n\n```js\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash\nsource   ~/.bashrc    # 安装完毕后，更新配置文件即可使用 nvm 命令\n```\n\n[教程](https://www.jianshu.com/p/6660589df806)\n\n[常用命令](https://blog.csdn.net/ruoxiyun/article/details/86980913)\n","source":"_posts/Nginx-Install.md","raw":"---\ntitle: Nginx 安装与使用\ndate: 2022-01-06 15:01:27\ncategories: 服务器\ntags: [服务器]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/01/06/Bj5oVxJmUfPwYLA.jpg\n---\n\n# Nginx 安装与使用\n\n**首先安装一些工具**\n\n```shell\nyum install -y wget  \nyum install -y vim-enhanced  \nyum install -y make cmake gcc gcc-c++  \n\nyum install -y pcre pcre-devel\nyum install -y zlib zlib-devel\nyum install -y openssl openssl-devel\n```\n\n> wget是一个下载文件的工具，它用在命令行下。\n\n> Vim是一个类似于 [Vi](http://baike.baidu.com/subview/27682/6112795.htm) 的著名的功能强大、高度可定制的 [文本编辑器](http://baike.baidu.com/view/487023.htm) \n\n> g++编译cpp文件\n\n> gcc编译c文件\n\n> make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。\n\n> *PCRE*是一个Perl库，包括 perl 兼容的正则表达式库\n\n> *zlib*是提供数据压缩用的函式库\n\n> openssl在计算机网络上，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上\n\n* 第一种方式（推荐）\n\n```js\nyum install nginx\n//安装后的目录在 /etc/nginx\n```\n\n来安装 Nginx，然后我们在命令行中 `nginx -v` 就可以看到具体的 Nginx 版本信息，也就安装完毕了\n\n* 第二种方式\n\n```js\nwget http://nginx.org/download/nginx-1.6.2.tar.gz //下载nginx安装包\ntar -zxvf nginx-1.6.2.tar.gz -C /usr/local/  //解压nginx-1.6.2.tar.gz到/usr/local/目录下\n//进入nginx-1.6.2目录然后在执行./configure命令\n[root@MiWiFi-R3-srv nginx-1.6.2]# ./configure --prefix=/usr/local/nginx\n//编译安装\n[root@MiWiFi-R3-srv nginx-1.6.2]# make && make install\n```\n\n**命令**\n\n**nginx -t ** ：验证nginx配置文件是否正确\n\n**netstat -ntlp **：用于显示各种网络相关信息,如网络连接,路由表,接口状态 ，连接,\n\n如果安装启动之后，访问不到，查看服务器得安全组配置，有没有对应得端口\n\n**安装nvm**\n\n```js\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash\nsource   ~/.bashrc    # 安装完毕后，更新配置文件即可使用 nvm 命令\n```\n\n[教程](https://www.jianshu.com/p/6660589df806)\n\n[常用命令](https://blog.csdn.net/ruoxiyun/article/details/86980913)\n","slug":"Nginx-Install","published":1,"updated":"2022-01-06T07:04:02.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m7002kdswk4l4z1ark","content":"<h1 id=\"Nginx-安装与使用\"><a href=\"#Nginx-安装与使用\" class=\"headerlink\" title=\"Nginx 安装与使用\"></a>Nginx 安装与使用</h1><p><strong>首先安装一些工具</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y wget  </span><br><span class=\"line\">yum install -y vim-enhanced  </span><br><span class=\"line\">yum install -y make cmake gcc gcc-c++  </span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y pcre pcre-devel</span><br><span class=\"line\">yum install -y zlib zlib-devel</span><br><span class=\"line\">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>wget是一个下载文件的工具，它用在命令行下。</p>\n</blockquote>\n<blockquote>\n<p>Vim是一个类似于 <a href=\"http://baike.baidu.com/subview/27682/6112795.htm\">Vi</a> 的著名的功能强大、高度可定制的 <a href=\"http://baike.baidu.com/view/487023.htm\">文本编辑器</a> </p>\n</blockquote>\n<blockquote>\n<p>g++编译cpp文件</p>\n</blockquote>\n<blockquote>\n<p>gcc编译c文件</p>\n</blockquote>\n<blockquote>\n<p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p>\n</blockquote>\n<blockquote>\n<p><em>PCRE</em>是一个Perl库，包括 perl 兼容的正则表达式库</p>\n</blockquote>\n<blockquote>\n<p><em>zlib</em>是提供数据压缩用的函式库</p>\n</blockquote>\n<blockquote>\n<p>openssl在计算机网络上，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上</p>\n</blockquote>\n<ul>\n<li>第一种方式（推荐）</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install nginx</span><br><span class=\"line\"><span class=\"comment\">//安装后的目录在 /etc/nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>来安装 Nginx，然后我们在命令行中 <code>nginx -v</code> 就可以看到具体的 Nginx 版本信息，也就安装完毕了</p>\n<ul>\n<li>第二种方式</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget <span class=\"attr\">http</span>:<span class=\"comment\">//nginx.org/download/nginx-1.6.2.tar.gz //下载nginx安装包</span></span><br><span class=\"line\">tar -zxvf nginx-<span class=\"number\">1.6</span><span class=\"number\">.2</span>.<span class=\"property\">tar</span>.<span class=\"property\">gz</span> -C /usr/local/  <span class=\"comment\">//解压nginx-1.6.2.tar.gz到/usr/local/目录下</span></span><br><span class=\"line\"><span class=\"comment\">//进入nginx-1.6.2目录然后在执行./configure命令</span></span><br><span class=\"line\">[root@<span class=\"title class_\">MiWiFi</span>-<span class=\"variable constant_\">R3</span>-srv nginx-<span class=\"number\">1.6</span><span class=\"number\">.2</span>]# ./configure --prefix=<span class=\"regexp\">/usr/</span>local/nginx</span><br><span class=\"line\"><span class=\"comment\">//编译安装</span></span><br><span class=\"line\">[root@<span class=\"title class_\">MiWiFi</span>-<span class=\"variable constant_\">R3</span>-srv nginx-<span class=\"number\">1.6</span><span class=\"number\">.2</span>]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令</strong></p>\n<p>*<em>nginx -t *</em> ：验证nginx配置文件是否正确</p>\n<p>*<em>netstat -ntlp *</em>：用于显示各种网络相关信息,如网络连接,路由表,接口状态 ，连接,</p>\n<p>如果安装启动之后，访问不到，查看服务器得安全组配置，有没有对应得端口</p>\n<p><strong>安装nvm</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- <span class=\"attr\">https</span>:<span class=\"comment\">//raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span></span><br><span class=\"line\">source   ~/.<span class=\"property\">bashrc</span>    # 安装完毕后，更新配置文件即可使用 nvm 命令</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.jianshu.com/p/6660589df806\">教程</a></p>\n<p><a href=\"https://blog.csdn.net/ruoxiyun/article/details/86980913\">常用命令</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Nginx-安装与使用\"><a href=\"#Nginx-安装与使用\" class=\"headerlink\" title=\"Nginx 安装与使用\"></a>Nginx 安装与使用</h1><p><strong>首先安装一些工具</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y wget  </span><br><span class=\"line\">yum install -y vim-enhanced  </span><br><span class=\"line\">yum install -y make cmake gcc gcc-c++  </span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y pcre pcre-devel</span><br><span class=\"line\">yum install -y zlib zlib-devel</span><br><span class=\"line\">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>wget是一个下载文件的工具，它用在命令行下。</p>\n</blockquote>\n<blockquote>\n<p>Vim是一个类似于 <a href=\"http://baike.baidu.com/subview/27682/6112795.htm\">Vi</a> 的著名的功能强大、高度可定制的 <a href=\"http://baike.baidu.com/view/487023.htm\">文本编辑器</a> </p>\n</blockquote>\n<blockquote>\n<p>g++编译cpp文件</p>\n</blockquote>\n<blockquote>\n<p>gcc编译c文件</p>\n</blockquote>\n<blockquote>\n<p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p>\n</blockquote>\n<blockquote>\n<p><em>PCRE</em>是一个Perl库，包括 perl 兼容的正则表达式库</p>\n</blockquote>\n<blockquote>\n<p><em>zlib</em>是提供数据压缩用的函式库</p>\n</blockquote>\n<blockquote>\n<p>openssl在计算机网络上，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上</p>\n</blockquote>\n<ul>\n<li>第一种方式（推荐）</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install nginx</span><br><span class=\"line\"><span class=\"comment\">//安装后的目录在 /etc/nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>来安装 Nginx，然后我们在命令行中 <code>nginx -v</code> 就可以看到具体的 Nginx 版本信息，也就安装完毕了</p>\n<ul>\n<li>第二种方式</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget <span class=\"attr\">http</span>:<span class=\"comment\">//nginx.org/download/nginx-1.6.2.tar.gz //下载nginx安装包</span></span><br><span class=\"line\">tar -zxvf nginx-<span class=\"number\">1.6</span><span class=\"number\">.2</span>.<span class=\"property\">tar</span>.<span class=\"property\">gz</span> -C /usr/local/  <span class=\"comment\">//解压nginx-1.6.2.tar.gz到/usr/local/目录下</span></span><br><span class=\"line\"><span class=\"comment\">//进入nginx-1.6.2目录然后在执行./configure命令</span></span><br><span class=\"line\">[root@<span class=\"title class_\">MiWiFi</span>-<span class=\"variable constant_\">R3</span>-srv nginx-<span class=\"number\">1.6</span><span class=\"number\">.2</span>]# ./configure --prefix=<span class=\"regexp\">/usr/</span>local/nginx</span><br><span class=\"line\"><span class=\"comment\">//编译安装</span></span><br><span class=\"line\">[root@<span class=\"title class_\">MiWiFi</span>-<span class=\"variable constant_\">R3</span>-srv nginx-<span class=\"number\">1.6</span><span class=\"number\">.2</span>]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令</strong></p>\n<p>*<em>nginx -t *</em> ：验证nginx配置文件是否正确</p>\n<p>*<em>netstat -ntlp *</em>：用于显示各种网络相关信息,如网络连接,路由表,接口状态 ，连接,</p>\n<p>如果安装启动之后，访问不到，查看服务器得安全组配置，有没有对应得端口</p>\n<p><strong>安装nvm</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- <span class=\"attr\">https</span>:<span class=\"comment\">//raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span></span><br><span class=\"line\">source   ~/.<span class=\"property\">bashrc</span>    # 安装完毕后，更新配置文件即可使用 nvm 命令</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.jianshu.com/p/6660589df806\">教程</a></p>\n<p><a href=\"https://blog.csdn.net/ruoxiyun/article/details/86980913\">常用命令</a></p>\n"},{"title":"将图片base64 转换为 图片文件","date":"2022-01-12T02:32:20.000Z","description":"工作总结","cover":"https://s2.loli.net/2022/03/16/gtfW7Ah85npcvGz.jpg","_content":"\n# 将图片base64 转换为 图片文件\n\n项目中遇到一个需求，图片上传，但是这个图片是base64编码的，需要转换为图片文件对象才能上传\n```js\n        // 将图片base64 转换为 图片文件\n        // dataurl 图片的base64编码\n        // 例：Request URL: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB....\n        function dataURLtoFile(dataurl){\n            let arr = dataurl.split(',');\n            let mime = arr[0].match(/:(.*?);/)[1];//图片类型 png\n            const filename = Date.parse(new Date()) + '.png';\n            let bstr = window.atob(arr[1])\n            let n = bstr.length\n            let u8arr = new Uint8Array(n);\n            while(n--){\n                u8arr[n] = bstr.charCodeAt(n);\n            }\n            return new File([u8arr], filename, {type:mime});\n        }\n```\n\n* **window.atob**\n\natob(encodedStr) 方法用于解码使用 base-64 编码的字符串,base-64 编码使用方法是 btoa()\n\n* **Uint8Array**\n\nUint8Array 数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。\n\n* **File**\n\n***new File(bits, name[, options])***\n\n> bits (required) ArrayBuffer，ArrayBufferView，Blob，或者 Array[string] — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。。\n> \n> name [String] (required) 文件名称，或者文件路径.\n> \n> options [Object] (optional) 选项对象，包含文件的可选属性。可用的选项如下：\n> * type: string, 表示将要放到文件中的内容的MIME类型。默认值为 '' 。\n> * lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。\n\n```js\n            // 创建FormData\n            const params = new FormData();\n            const imgFile = this.dataURLtoFile(this.imgSrc);\n            params.append('fileImport',imgFile);\n            _uploadImg(params);//调用接口\n```","source":"_posts/Project-base64ToFile.md","raw":"---\ntitle: 将图片base64 转换为 图片文件\ndate: 2022-01-12 10:32:20\ncategories: 项目\ntags: [项目]\ndescription: 工作总结\ncover: https://s2.loli.net/2022/03/16/gtfW7Ah85npcvGz.jpg\n---\n\n# 将图片base64 转换为 图片文件\n\n项目中遇到一个需求，图片上传，但是这个图片是base64编码的，需要转换为图片文件对象才能上传\n```js\n        // 将图片base64 转换为 图片文件\n        // dataurl 图片的base64编码\n        // 例：Request URL: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB....\n        function dataURLtoFile(dataurl){\n            let arr = dataurl.split(',');\n            let mime = arr[0].match(/:(.*?);/)[1];//图片类型 png\n            const filename = Date.parse(new Date()) + '.png';\n            let bstr = window.atob(arr[1])\n            let n = bstr.length\n            let u8arr = new Uint8Array(n);\n            while(n--){\n                u8arr[n] = bstr.charCodeAt(n);\n            }\n            return new File([u8arr], filename, {type:mime});\n        }\n```\n\n* **window.atob**\n\natob(encodedStr) 方法用于解码使用 base-64 编码的字符串,base-64 编码使用方法是 btoa()\n\n* **Uint8Array**\n\nUint8Array 数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。\n\n* **File**\n\n***new File(bits, name[, options])***\n\n> bits (required) ArrayBuffer，ArrayBufferView，Blob，或者 Array[string] — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。。\n> \n> name [String] (required) 文件名称，或者文件路径.\n> \n> options [Object] (optional) 选项对象，包含文件的可选属性。可用的选项如下：\n> * type: string, 表示将要放到文件中的内容的MIME类型。默认值为 '' 。\n> * lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。\n\n```js\n            // 创建FormData\n            const params = new FormData();\n            const imgFile = this.dataURLtoFile(this.imgSrc);\n            params.append('fileImport',imgFile);\n            _uploadImg(params);//调用接口\n```","slug":"Project-base64ToFile","published":1,"updated":"2022-03-16T07:36:21.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m8002mdswkeefj19iw","content":"<h1 id=\"将图片base64-转换为-图片文件\"><a href=\"#将图片base64-转换为-图片文件\" class=\"headerlink\" title=\"将图片base64 转换为 图片文件\"></a>将图片base64 转换为 图片文件</h1><p>项目中遇到一个需求，图片上传，但是这个图片是base64编码的，需要转换为图片文件对象才能上传</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将图片base64 转换为 图片文件</span></span><br><span class=\"line\"><span class=\"comment\">// dataurl 图片的base64编码</span></span><br><span class=\"line\"><span class=\"comment\">// 例：Request URL: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB....</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dataURLtoFile</span>(<span class=\"params\">dataurl</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = dataurl.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mime = arr[<span class=\"number\">0</span>].<span class=\"title function_\">match</span>(<span class=\"regexp\">/:(.*?);/</span>)[<span class=\"number\">1</span>];<span class=\"comment\">//图片类型 png</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> filename = <span class=\"title class_\">Date</span>.<span class=\"title function_\">parse</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()) + <span class=\"string\">&#x27;.png&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bstr = <span class=\"variable language_\">window</span>.<span class=\"title function_\">atob</span>(arr[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = bstr.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> u8arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Uint8Array</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        u8arr[n] = bstr.<span class=\"title function_\">charCodeAt</span>(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>([u8arr], filename, &#123;<span class=\"attr\">type</span>:mime&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>window.atob</strong></li>\n</ul>\n<p>atob(encodedStr) 方法用于解码使用 base-64 编码的字符串,base-64 编码使用方法是 btoa()</p>\n<ul>\n<li><strong>Uint8Array</strong></li>\n</ul>\n<p>Uint8Array 数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。</p>\n<ul>\n<li><strong>File</strong></li>\n</ul>\n<p><strong><em>new File(bits, name[, options])</em></strong></p>\n<blockquote>\n<p>bits (required) ArrayBuffer，ArrayBufferView，Blob，或者 Array[string] — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。。</p>\n<p>name [String] (required) 文件名称，或者文件路径.</p>\n<p>options [Object] (optional) 选项对象，包含文件的可选属性。可用的选项如下：</p>\n<ul>\n<li>type: string, 表示将要放到文件中的内容的MIME类型。默认值为 ‘’ 。</li>\n<li>lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建FormData</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> params = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> imgFile = <span class=\"variable language_\">this</span>.<span class=\"title function_\">dataURLtoFile</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">imgSrc</span>);</span><br><span class=\"line\">params.<span class=\"title function_\">append</span>(<span class=\"string\">&#x27;fileImport&#x27;</span>,imgFile);</span><br><span class=\"line\"><span class=\"title function_\">_uploadImg</span>(params);<span class=\"comment\">//调用接口</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"将图片base64-转换为-图片文件\"><a href=\"#将图片base64-转换为-图片文件\" class=\"headerlink\" title=\"将图片base64 转换为 图片文件\"></a>将图片base64 转换为 图片文件</h1><p>项目中遇到一个需求，图片上传，但是这个图片是base64编码的，需要转换为图片文件对象才能上传</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将图片base64 转换为 图片文件</span></span><br><span class=\"line\"><span class=\"comment\">// dataurl 图片的base64编码</span></span><br><span class=\"line\"><span class=\"comment\">// 例：Request URL: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB....</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dataURLtoFile</span>(<span class=\"params\">dataurl</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = dataurl.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mime = arr[<span class=\"number\">0</span>].<span class=\"title function_\">match</span>(<span class=\"regexp\">/:(.*?);/</span>)[<span class=\"number\">1</span>];<span class=\"comment\">//图片类型 png</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> filename = <span class=\"title class_\">Date</span>.<span class=\"title function_\">parse</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()) + <span class=\"string\">&#x27;.png&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bstr = <span class=\"variable language_\">window</span>.<span class=\"title function_\">atob</span>(arr[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = bstr.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> u8arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Uint8Array</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        u8arr[n] = bstr.<span class=\"title function_\">charCodeAt</span>(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>([u8arr], filename, &#123;<span class=\"attr\">type</span>:mime&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>window.atob</strong></li>\n</ul>\n<p>atob(encodedStr) 方法用于解码使用 base-64 编码的字符串,base-64 编码使用方法是 btoa()</p>\n<ul>\n<li><strong>Uint8Array</strong></li>\n</ul>\n<p>Uint8Array 数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。</p>\n<ul>\n<li><strong>File</strong></li>\n</ul>\n<p><strong><em>new File(bits, name[, options])</em></strong></p>\n<blockquote>\n<p>bits (required) ArrayBuffer，ArrayBufferView，Blob，或者 Array[string] — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。。</p>\n<p>name [String] (required) 文件名称，或者文件路径.</p>\n<p>options [Object] (optional) 选项对象，包含文件的可选属性。可用的选项如下：</p>\n<ul>\n<li>type: string, 表示将要放到文件中的内容的MIME类型。默认值为 ‘’ 。</li>\n<li>lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建FormData</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> params = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> imgFile = <span class=\"variable language_\">this</span>.<span class=\"title function_\">dataURLtoFile</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">imgSrc</span>);</span><br><span class=\"line\">params.<span class=\"title function_\">append</span>(<span class=\"string\">&#x27;fileImport&#x27;</span>,imgFile);</span><br><span class=\"line\"><span class=\"title function_\">_uploadImg</span>(params);<span class=\"comment\">//调用接口</span></span><br></pre></td></tr></table></figure>"},{"title":"React","date":"2020-06-22T04:36:18.000Z","description":"React","_content":"\n### React\n\nReact 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的UI 界面，这些代码片段被称作“组件”。\n\n#### 一、js支持\n\n- react.js   :     React的核心库\n- react-dom.js   :   提供操作Dom 的react 扩展库\n- babel.min.js   ： 解析 JSX 语法代码转为纯JS 语法代码库\n\n#### 二、组件\n\n##### 1、工厂方法组件 ：简单组件，只有数据显示等简单操作\n\n```js\n function MyCompoent() {\n         return (\n             <h1>MyCompoent,方法组件</h1>\n         );\n }\n```\n\n##### 2、ES6 类组件 ：复杂组件，需要对数据进行操作的操作的复杂操作\n\n```js\nclass MyCompoent2 extends React.Component{\n     render(){\n          return (\n              <h1>MyCompoent2,类组件</h1>\n          );\n     }\n}\n```\n\n#### 三、组件三大属性 \n\n##### 1、state\n\n类组件中，才会state 属性\nstate 是一个对象，也称是组件的状态，如果state 的值改变，也称状态改变，就会重新渲染页面（一般结合 事件方法 来改变状态）\n\n###### （1）设置状态：一个类组件，最开始的state 为 null，我们通过构造方法来初始化 state\n\n```js\nconstructor(props){\n       super(props); \n            this.state={\n            is:true\n      }\n}\n```\n\n注意：构造函数中需要调用父类的构造函数 ```super(props);```\n\n###### (2) 使用状态：使用state 的值 通过 this.state.is  来使用\n\n```js\n<h1>{this.state.is ? \"我喜欢你\":\"你喜欢我\"}</h1>\n```\n\n###### (3) 修改状态：改变state 通过 this.setState() 方法来实现，传入一个对象\n\n```js\nthis.setState({\n    is:false\n})\n```\n\n注意：我们需要通过一种操作来改变状态，需要结合事件方法来实现，这个时候我们要注意事件处理方法中的this 指向问题\n\t          方法的this 是 undefined，我们就不能调用到组件的属性\n\t          我们可以在 ```构造方法``` 中使用  \n\t\t\t```this.fun=this.fun.bind(this);```\n\t         来绑定this  的指向 或者 \n\t\t \t```<h1 onClick={()=>this.fun()}></h1>```\n\n##### 2、props\n\n方法组件、类组件 都存在props 属性\n\n###### （1）设置props\n\n   props 是通过组件自定义的属性，传递给组件，供组件使用，可以是对象 等任意类型，\n\n```js\n<MyCompoent msg=\"this is MyCompoent\"/>\n```\n\n###### (2）使用props\n\n- 方法组件 通过传入的参数来使用\n\n```js\nfunction MyCompoent(props) {\n     return (\n         <h1>{props.msg}</h1>\n     );\n}\n```\n\n- 类组件 通过this.props.msg 使用\n\n```js\nclass MyCompoent2 extends React.Component{\n      render(){\n          return (\n               <h1>{this.props.msg}</h1>\n          );\n     }\n}\n```\n\n###### (3）其他\n\n- 设置属性默认值\n\n```js\nMyCompoent.defaultProps={\n\tmsg:\"666\"\n}\t\n```\n\n- 设置属性类型 和必要性\n\n```js\nTime.propTypes={\n       name:PropTypes.string.isRequired,    //name属性  字符串类型     必须有\n       age:PropTypes.number //age 属性    数字类型  \n}\n```\n\n##### 3、refs\n\n表示组件内的元素\n\n###### （1）设置refs\n\n​\t\t第一种\n​\t\t      ```<input type=\"text\" ref=\"context\"/>   //老版本   现在也可以用```\n​\t\t第二种\n​\t\t      ``` <input type=\"text\" ref={ e => this.context=e}/>  //新版本\n​\t\t\t//直接将该标签 绑定给 组件对象的一个属性```\n\n###### (2）使用refs\n\n​\t\t第一种\n​\t\t\t```this.refs.context.value  //获取input的值```\n​\t\t第二种\n​\t\t\t```this.context.value   //获取input的```\n\n###### (3) 获取表单数据\n\n- > 使用ref绑定input 输入框，获取输入数据\n\n-   >  创建一个状态state，将其设置为输入框的value\n    >\n    >  输入框通过onChange 实时改变状态的值，就得到了输入数据\n\n#### 四、组件生命周期\n\n##### 1、第一次初始化渲染显示：ReactDom.render()\n\n> constructor()：创建对象初始化 state\n>\n> componentWillMount()：将插入回调\n>\n> render()：用于插入虚拟DOM回调\n>\n> componentDidMount()：已经插入回电\n\n##### 2、每次更新state：this.setState()\n\n> componentWillUpadate()：将要更新回调\n> render()：更新，重新渲染\n> componentDidUpdate()：已经更新回调\n\n##### 3、移除组件：ReactDOM.unmountComponentAtNode(contarnerDom)\n\n> componentWillUnmount()：组件将要被移除回调\n\n#### 五、组件间的通信\n\n- 方式一：通过props 传递\n\n> 共同的数据放在父组件上，特有的数据放在自己组件内部state\n> 通过props 可以传递一般数据和函数数据，只能一层一层的传递\n> 一般数据 --> 父组件传递数据给子组件 --> 子组件使用数据\n> 函数数据 --> 子组件传递数据个父组件 --> 子组件调用函数\n\n- 方式二：使用消息订阅（subscribe）-发布（publish）机制\n\n  > 工具库：PubSubJS\n  >\n  > 下载：npm install pubsub-js --save\n  > 使用：\n  >          PubSub.subcribe(\"名称\",“回调函数”)；//订阅\n  >          PubSub.publish(\"名称\",\"参数..\"); //发布\n\n#### 六、React-Router\n\n##### 1、安装\n\n```js\nnpm install --save react-router-dom\n```\n\n##### 2、使用\n\n- 在应用的入口文件 使用根组件（App.js）时，引入 BrowserRouter 或者 HashRouter 标签，将根组件作为它的子标签\n\n```js\n import {BrowserRouter} from \"react-router-dom\";\nReactDOM.render(\n\t<BrowserRouter>\n\t\t <App />\n\t</BrowserRouter>,\n\tdocument.getElementById('root')\n);\n```\n\n- 编写路由组件\n- 路由链接：```<Link/>,<NavLink/>```\n-  路由：```<Route/>```\n\n##### 例子：\n\n```js\n<div className=\"App\">\n\t        <div>\n\t            <Link to=\"home\" >home</Link>\n\t            <Link to=\"about\" >about</Link>\n\t        </div>\n\t        <div>\n\t            <Switch>\n\t                <Route path=\"/home\" component={Home}></Route>\n\t                <Route path=\"/about\" component={About}></Route>\n\t                <Redirect to=\"/home\"></Redirect>\n\t            </Switch>\n\t        </div>\n</div>\n```\n\n- ``<Switch/>`` : 同一时刻只能显示一个组件\n- ```<Redirect/>```：重定向\n\n##### 3、路由传值\n\n###### (1）设置路由\n\n```js\n<Route path=\"/about/:id\" component={About} />\n```\n\n#id 可任意取\n\n######  (2）设置路由链接\n\n```js\n<Link to=\"/about/1\">about</Link>\n```\n\n###### (3）获取值\n\n```js\n this.props.match.params.id\n```\n\n #id 对应路由中的名称\n\n##### 4、路由跳转方式\n\n###### (1）路由链接\n\n  就是使用Link 标签，这样的方式不会发送请求\n\n```js\n<Link to=\"/about/1\">about</Link>\n```\n\n###### (2）非路由链接\n\n一般是指a 标签，这样的方式会发送请求\n\n```js\n<a href=\"/home\">home</a>\n```\n\n###### (3）history    ----   this.props.history\n\n 通过给history push或者replace来跳转\n\n- ``this.props.history.push(\"/home\");``\n- ``this.props.history.replace(\"/home\");``\n\n 区别：replace 会替换掉上一个页面，如果向返回上一个页面，就不会返回成功\n\n history 的回退与前进\n\n> this.props.history.goBack();\n> this.props.history.goForward();\n\n一般这种方式用于不用链接的方式跳转，比如：按钮点击","source":"_posts/React.md","raw":"---\ntitle: React\ndate: 2020-06-22 12:36:18\ncategories: React\ntags: [React]\ndescription: React\n---\n\n### React\n\nReact 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的UI 界面，这些代码片段被称作“组件”。\n\n#### 一、js支持\n\n- react.js   :     React的核心库\n- react-dom.js   :   提供操作Dom 的react 扩展库\n- babel.min.js   ： 解析 JSX 语法代码转为纯JS 语法代码库\n\n#### 二、组件\n\n##### 1、工厂方法组件 ：简单组件，只有数据显示等简单操作\n\n```js\n function MyCompoent() {\n         return (\n             <h1>MyCompoent,方法组件</h1>\n         );\n }\n```\n\n##### 2、ES6 类组件 ：复杂组件，需要对数据进行操作的操作的复杂操作\n\n```js\nclass MyCompoent2 extends React.Component{\n     render(){\n          return (\n              <h1>MyCompoent2,类组件</h1>\n          );\n     }\n}\n```\n\n#### 三、组件三大属性 \n\n##### 1、state\n\n类组件中，才会state 属性\nstate 是一个对象，也称是组件的状态，如果state 的值改变，也称状态改变，就会重新渲染页面（一般结合 事件方法 来改变状态）\n\n###### （1）设置状态：一个类组件，最开始的state 为 null，我们通过构造方法来初始化 state\n\n```js\nconstructor(props){\n       super(props); \n            this.state={\n            is:true\n      }\n}\n```\n\n注意：构造函数中需要调用父类的构造函数 ```super(props);```\n\n###### (2) 使用状态：使用state 的值 通过 this.state.is  来使用\n\n```js\n<h1>{this.state.is ? \"我喜欢你\":\"你喜欢我\"}</h1>\n```\n\n###### (3) 修改状态：改变state 通过 this.setState() 方法来实现，传入一个对象\n\n```js\nthis.setState({\n    is:false\n})\n```\n\n注意：我们需要通过一种操作来改变状态，需要结合事件方法来实现，这个时候我们要注意事件处理方法中的this 指向问题\n\t          方法的this 是 undefined，我们就不能调用到组件的属性\n\t          我们可以在 ```构造方法``` 中使用  \n\t\t\t```this.fun=this.fun.bind(this);```\n\t         来绑定this  的指向 或者 \n\t\t \t```<h1 onClick={()=>this.fun()}></h1>```\n\n##### 2、props\n\n方法组件、类组件 都存在props 属性\n\n###### （1）设置props\n\n   props 是通过组件自定义的属性，传递给组件，供组件使用，可以是对象 等任意类型，\n\n```js\n<MyCompoent msg=\"this is MyCompoent\"/>\n```\n\n###### (2）使用props\n\n- 方法组件 通过传入的参数来使用\n\n```js\nfunction MyCompoent(props) {\n     return (\n         <h1>{props.msg}</h1>\n     );\n}\n```\n\n- 类组件 通过this.props.msg 使用\n\n```js\nclass MyCompoent2 extends React.Component{\n      render(){\n          return (\n               <h1>{this.props.msg}</h1>\n          );\n     }\n}\n```\n\n###### (3）其他\n\n- 设置属性默认值\n\n```js\nMyCompoent.defaultProps={\n\tmsg:\"666\"\n}\t\n```\n\n- 设置属性类型 和必要性\n\n```js\nTime.propTypes={\n       name:PropTypes.string.isRequired,    //name属性  字符串类型     必须有\n       age:PropTypes.number //age 属性    数字类型  \n}\n```\n\n##### 3、refs\n\n表示组件内的元素\n\n###### （1）设置refs\n\n​\t\t第一种\n​\t\t      ```<input type=\"text\" ref=\"context\"/>   //老版本   现在也可以用```\n​\t\t第二种\n​\t\t      ``` <input type=\"text\" ref={ e => this.context=e}/>  //新版本\n​\t\t\t//直接将该标签 绑定给 组件对象的一个属性```\n\n###### (2）使用refs\n\n​\t\t第一种\n​\t\t\t```this.refs.context.value  //获取input的值```\n​\t\t第二种\n​\t\t\t```this.context.value   //获取input的```\n\n###### (3) 获取表单数据\n\n- > 使用ref绑定input 输入框，获取输入数据\n\n-   >  创建一个状态state，将其设置为输入框的value\n    >\n    >  输入框通过onChange 实时改变状态的值，就得到了输入数据\n\n#### 四、组件生命周期\n\n##### 1、第一次初始化渲染显示：ReactDom.render()\n\n> constructor()：创建对象初始化 state\n>\n> componentWillMount()：将插入回调\n>\n> render()：用于插入虚拟DOM回调\n>\n> componentDidMount()：已经插入回电\n\n##### 2、每次更新state：this.setState()\n\n> componentWillUpadate()：将要更新回调\n> render()：更新，重新渲染\n> componentDidUpdate()：已经更新回调\n\n##### 3、移除组件：ReactDOM.unmountComponentAtNode(contarnerDom)\n\n> componentWillUnmount()：组件将要被移除回调\n\n#### 五、组件间的通信\n\n- 方式一：通过props 传递\n\n> 共同的数据放在父组件上，特有的数据放在自己组件内部state\n> 通过props 可以传递一般数据和函数数据，只能一层一层的传递\n> 一般数据 --> 父组件传递数据给子组件 --> 子组件使用数据\n> 函数数据 --> 子组件传递数据个父组件 --> 子组件调用函数\n\n- 方式二：使用消息订阅（subscribe）-发布（publish）机制\n\n  > 工具库：PubSubJS\n  >\n  > 下载：npm install pubsub-js --save\n  > 使用：\n  >          PubSub.subcribe(\"名称\",“回调函数”)；//订阅\n  >          PubSub.publish(\"名称\",\"参数..\"); //发布\n\n#### 六、React-Router\n\n##### 1、安装\n\n```js\nnpm install --save react-router-dom\n```\n\n##### 2、使用\n\n- 在应用的入口文件 使用根组件（App.js）时，引入 BrowserRouter 或者 HashRouter 标签，将根组件作为它的子标签\n\n```js\n import {BrowserRouter} from \"react-router-dom\";\nReactDOM.render(\n\t<BrowserRouter>\n\t\t <App />\n\t</BrowserRouter>,\n\tdocument.getElementById('root')\n);\n```\n\n- 编写路由组件\n- 路由链接：```<Link/>,<NavLink/>```\n-  路由：```<Route/>```\n\n##### 例子：\n\n```js\n<div className=\"App\">\n\t        <div>\n\t            <Link to=\"home\" >home</Link>\n\t            <Link to=\"about\" >about</Link>\n\t        </div>\n\t        <div>\n\t            <Switch>\n\t                <Route path=\"/home\" component={Home}></Route>\n\t                <Route path=\"/about\" component={About}></Route>\n\t                <Redirect to=\"/home\"></Redirect>\n\t            </Switch>\n\t        </div>\n</div>\n```\n\n- ``<Switch/>`` : 同一时刻只能显示一个组件\n- ```<Redirect/>```：重定向\n\n##### 3、路由传值\n\n###### (1）设置路由\n\n```js\n<Route path=\"/about/:id\" component={About} />\n```\n\n#id 可任意取\n\n######  (2）设置路由链接\n\n```js\n<Link to=\"/about/1\">about</Link>\n```\n\n###### (3）获取值\n\n```js\n this.props.match.params.id\n```\n\n #id 对应路由中的名称\n\n##### 4、路由跳转方式\n\n###### (1）路由链接\n\n  就是使用Link 标签，这样的方式不会发送请求\n\n```js\n<Link to=\"/about/1\">about</Link>\n```\n\n###### (2）非路由链接\n\n一般是指a 标签，这样的方式会发送请求\n\n```js\n<a href=\"/home\">home</a>\n```\n\n###### (3）history    ----   this.props.history\n\n 通过给history push或者replace来跳转\n\n- ``this.props.history.push(\"/home\");``\n- ``this.props.history.replace(\"/home\");``\n\n 区别：replace 会替换掉上一个页面，如果向返回上一个页面，就不会返回成功\n\n history 的回退与前进\n\n> this.props.history.goBack();\n> this.props.history.goForward();\n\n一般这种方式用于不用链接的方式跳转，比如：按钮点击","slug":"React","published":1,"updated":"2021-09-08T14:15:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1m9002rdswkdueq7o10","content":"<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的UI 界面，这些代码片段被称作“组件”。</p>\n<h4 id=\"一、js支持\"><a href=\"#一、js支持\" class=\"headerlink\" title=\"一、js支持\"></a>一、js支持</h4><ul>\n<li>react.js   :     React的核心库</li>\n<li>react-dom.js   :   提供操作Dom 的react 扩展库</li>\n<li>babel.min.js   ： 解析 JSX 语法代码转为纯JS 语法代码库</li>\n</ul>\n<h4 id=\"二、组件\"><a href=\"#二、组件\" class=\"headerlink\" title=\"二、组件\"></a>二、组件</h4><h5 id=\"1、工厂方法组件-：简单组件，只有数据显示等简单操作\"><a href=\"#1、工厂方法组件-：简单组件，只有数据显示等简单操作\" class=\"headerlink\" title=\"1、工厂方法组件 ：简单组件，只有数据显示等简单操作\"></a>1、工厂方法组件 ：简单组件，只有数据显示等简单操作</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyCompoent</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>MyCompoent,方法组件<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2、ES6-类组件-：复杂组件，需要对数据进行操作的操作的复杂操作\"><a href=\"#2、ES6-类组件-：复杂组件，需要对数据进行操作的操作的复杂操作\" class=\"headerlink\" title=\"2、ES6 类组件 ：复杂组件，需要对数据进行操作的操作的复杂操作\"></a>2、ES6 类组件 ：复杂组件，需要对数据进行操作的操作的复杂操作</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCompoent2</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&#123;</span><br><span class=\"line\">     <span class=\"title function_\">render</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>MyCompoent2,类组件<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">          );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"三、组件三大属性\"><a href=\"#三、组件三大属性\" class=\"headerlink\" title=\"三、组件三大属性\"></a>三、组件三大属性</h4><h5 id=\"1、state\"><a href=\"#1、state\" class=\"headerlink\" title=\"1、state\"></a>1、state</h5><p>类组件中，才会state 属性<br>state 是一个对象，也称是组件的状态，如果state 的值改变，也称状态改变，就会重新渲染页面（一般结合 事件方法 来改变状态）</p>\n<h6 id=\"（1）设置状态：一个类组件，最开始的state-为-null，我们通过构造方法来初始化-state\"><a href=\"#（1）设置状态：一个类组件，最开始的state-为-null，我们通过构造方法来初始化-state\" class=\"headerlink\" title=\"（1）设置状态：一个类组件，最开始的state 为 null，我们通过构造方法来初始化 state\"></a>（1）设置状态：一个类组件，最开始的state 为 null，我们通过构造方法来初始化 state</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>)&#123;</span><br><span class=\"line\">       <span class=\"variable language_\">super</span>(props); </span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=&#123;</span><br><span class=\"line\">            <span class=\"attr\">is</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：构造函数中需要调用父类的构造函数 <code>super(props);</code></p>\n<h6 id=\"2-使用状态：使用state-的值-通过-this-state-is-来使用\"><a href=\"#2-使用状态：使用state-的值-通过-this-state-is-来使用\" class=\"headerlink\" title=\"(2) 使用状态：使用state 的值 通过 this.state.is  来使用\"></a>(2) 使用状态：使用state 的值 通过 this.state.is  来使用</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;&#123;<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">is</span> ? <span class=\"string\">&quot;我喜欢你&quot;</span>:<span class=\"string\">&quot;你喜欢我&quot;</span>&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3-修改状态：改变state-通过-this-setState-方法来实现，传入一个对象\"><a href=\"#3-修改状态：改变state-通过-this-setState-方法来实现，传入一个对象\" class=\"headerlink\" title=\"(3) 修改状态：改变state 通过 this.setState() 方法来实现，传入一个对象\"></a>(3) 修改状态：改变state 通过 this.setState() 方法来实现，传入一个对象</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">is</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>注意：我们需要通过一种操作来改变状态，需要结合事件方法来实现，这个时候我们要注意事件处理方法中的this 指向问题<br>              方法的this 是 undefined，我们就不能调用到组件的属性<br>              我们可以在 <code>构造方法</code> 中使用<br>            <code>this.fun=this.fun.bind(this);</code><br>             来绑定this  的指向 或者<br>             <code>&lt;h1 onClick=&#123;()=&gt;this.fun()&#125;&gt;&lt;/h1&gt;</code></p>\n<h5 id=\"2、props\"><a href=\"#2、props\" class=\"headerlink\" title=\"2、props\"></a>2、props</h5><p>方法组件、类组件 都存在props 属性</p>\n<h6 id=\"（1）设置props\"><a href=\"#（1）设置props\" class=\"headerlink\" title=\"（1）设置props\"></a>（1）设置props</h6><p>   props 是通过组件自定义的属性，传递给组件，供组件使用，可以是对象 等任意类型，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">MyCompoent</span> msg=<span class=\"string\">&quot;this is MyCompoent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2）使用props\"><a href=\"#2）使用props\" class=\"headerlink\" title=\"(2）使用props\"></a>(2）使用props</h6><ul>\n<li>方法组件 通过传入的参数来使用</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyCompoent</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (</span><br><span class=\"line\">         <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;props.msg&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">     );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类组件 通过this.props.msg 使用</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCompoent2</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&#123;</span><br><span class=\"line\">      <span class=\"title function_\">render</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">               <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;this.props.msg&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">          );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3）其他\"><a href=\"#3）其他\" class=\"headerlink\" title=\"(3）其他\"></a>(3）其他</h6><ul>\n<li>设置属性默认值</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">MyCompoent</span>.<span class=\"property\">defaultProps</span>=&#123;</span><br><span class=\"line\">\t<span class=\"attr\">msg</span>:<span class=\"string\">&quot;666&quot;</span></span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置属性类型 和必要性</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Time</span>.<span class=\"property\">propTypes</span>=&#123;</span><br><span class=\"line\">       <span class=\"attr\">name</span>:<span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,    <span class=\"comment\">//name属性  字符串类型     必须有</span></span><br><span class=\"line\">       <span class=\"attr\">age</span>:<span class=\"title class_\">PropTypes</span>.<span class=\"property\">number</span> <span class=\"comment\">//age 属性    数字类型  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3、refs\"><a href=\"#3、refs\" class=\"headerlink\" title=\"3、refs\"></a>3、refs</h5><p>表示组件内的元素</p>\n<h6 id=\"（1）设置refs\"><a href=\"#（1）设置refs\" class=\"headerlink\" title=\"（1）设置refs\"></a>（1）设置refs</h6><p>​        第一种<br>​              <code>&lt;input type=&quot;text&quot; ref=&quot;context&quot;/&gt;   //老版本   现在也可以用</code><br>​        第二种<br>​              <code>&lt;input type=&quot;text&quot; ref=&#123; e =&gt; this.context=e&#125;/&gt;  //新版本\n​            //直接将该标签 绑定给 组件对象的一个属性</code></p>\n<h6 id=\"2）使用refs\"><a href=\"#2）使用refs\" class=\"headerlink\" title=\"(2）使用refs\"></a>(2）使用refs</h6><p>​        第一种<br>​            <code>this.refs.context.value  //获取input的值</code><br>​        第二种<br>​            <code>this.context.value   //获取input的</code></p>\n<h6 id=\"3-获取表单数据\"><a href=\"#3-获取表单数据\" class=\"headerlink\" title=\"(3) 获取表单数据\"></a>(3) 获取表单数据</h6><ul>\n<li><blockquote>\n<p>使用ref绑定input 输入框，获取输入数据</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p> 创建一个状态state，将其设置为输入框的value</p>\n<p> 输入框通过onChange 实时改变状态的值，就得到了输入数据</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"四、组件生命周期\"><a href=\"#四、组件生命周期\" class=\"headerlink\" title=\"四、组件生命周期\"></a>四、组件生命周期</h4><h5 id=\"1、第一次初始化渲染显示：ReactDom-render\"><a href=\"#1、第一次初始化渲染显示：ReactDom-render\" class=\"headerlink\" title=\"1、第一次初始化渲染显示：ReactDom.render()\"></a>1、第一次初始化渲染显示：ReactDom.render()</h5><blockquote>\n<p>constructor()：创建对象初始化 state</p>\n<p>componentWillMount()：将插入回调</p>\n<p>render()：用于插入虚拟DOM回调</p>\n<p>componentDidMount()：已经插入回电</p>\n</blockquote>\n<h5 id=\"2、每次更新state：this-setState\"><a href=\"#2、每次更新state：this-setState\" class=\"headerlink\" title=\"2、每次更新state：this.setState()\"></a>2、每次更新state：this.setState()</h5><blockquote>\n<p>componentWillUpadate()：将要更新回调<br>render()：更新，重新渲染<br>componentDidUpdate()：已经更新回调</p>\n</blockquote>\n<h5 id=\"3、移除组件：ReactDOM-unmountComponentAtNode-contarnerDom\"><a href=\"#3、移除组件：ReactDOM-unmountComponentAtNode-contarnerDom\" class=\"headerlink\" title=\"3、移除组件：ReactDOM.unmountComponentAtNode(contarnerDom)\"></a>3、移除组件：ReactDOM.unmountComponentAtNode(contarnerDom)</h5><blockquote>\n<p>componentWillUnmount()：组件将要被移除回调</p>\n</blockquote>\n<h4 id=\"五、组件间的通信\"><a href=\"#五、组件间的通信\" class=\"headerlink\" title=\"五、组件间的通信\"></a>五、组件间的通信</h4><ul>\n<li>方式一：通过props 传递</li>\n</ul>\n<blockquote>\n<p>共同的数据放在父组件上，特有的数据放在自己组件内部state<br>通过props 可以传递一般数据和函数数据，只能一层一层的传递<br>一般数据 –&gt; 父组件传递数据给子组件 –&gt; 子组件使用数据<br>函数数据 –&gt; 子组件传递数据个父组件 –&gt; 子组件调用函数</p>\n</blockquote>\n<ul>\n<li><p>方式二：使用消息订阅（subscribe）-发布（publish）机制</p>\n<blockquote>\n<p>工具库：PubSubJS</p>\n<p>下载：npm install pubsub-js –save<br>使用：</p>\n<pre><code>PubSub.subcribe(&quot;名称&quot;,“回调函数”)；//订阅\nPubSub.publish(&quot;名称&quot;,&quot;参数..&quot;); //发布</code></pre></blockquote>\n</li>\n</ul>\n<h4 id=\"六、React-Router\"><a href=\"#六、React-Router\" class=\"headerlink\" title=\"六、React-Router\"></a>六、React-Router</h4><h5 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save react-router-dom</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2、使用\"><a href=\"#2、使用\" class=\"headerlink\" title=\"2、使用\"></a>2、使用</h5><ul>\n<li>在应用的入口文件 使用根组件（App.js）时，引入 BrowserRouter 或者 HashRouter 标签，将根组件作为它的子标签</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(</span><br><span class=\"line\">\t<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t <span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span>,</span><br><span class=\"line\">\t<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;root&#x27;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编写路由组件</li>\n<li>路由链接：<code>&lt;Link/&gt;,&lt;NavLink/&gt;</code></li>\n<li>路由：<code>&lt;Route/&gt;</code></li>\n</ul>\n<h5 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div className=<span class=\"string\">&quot;App&quot;</span>&gt;</span><br><span class=\"line\">\t        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;home&quot;</span> &gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;about&quot;</span> &gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/home&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/about&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t                <span class=\"tag\">&lt;<span class=\"name\">Redirect</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;/home&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Redirect</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>&lt;Switch/&gt;</code> : 同一时刻只能显示一个组件</li>\n<li><code>&lt;Redirect/&gt;</code>：重定向</li>\n</ul>\n<h5 id=\"3、路由传值\"><a href=\"#3、路由传值\" class=\"headerlink\" title=\"3、路由传值\"></a>3、路由传值</h5><h6 id=\"1）设置路由\"><a href=\"#1）设置路由\" class=\"headerlink\" title=\"(1）设置路由\"></a>(1）设置路由</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Route</span> path=<span class=\"string\">&quot;/about/:id&quot;</span> component=&#123;<span class=\"title class_\">About</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>#id 可任意取</p>\n<h6 id=\"2）设置路由链接\"><a href=\"#2）设置路由链接\" class=\"headerlink\" title=\"(2）设置路由链接\"></a>(2）设置路由链接</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Link</span> to=<span class=\"string\">&quot;/about/1&quot;</span>&gt;about&lt;/<span class=\"title class_\">Link</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3）获取值\"><a href=\"#3）获取值\" class=\"headerlink\" title=\"(3）获取值\"></a>(3）获取值</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">match</span>.<span class=\"property\">params</span>.<span class=\"property\">id</span></span><br></pre></td></tr></table></figure>\n\n<p> #id 对应路由中的名称</p>\n<h5 id=\"4、路由跳转方式\"><a href=\"#4、路由跳转方式\" class=\"headerlink\" title=\"4、路由跳转方式\"></a>4、路由跳转方式</h5><h6 id=\"1）路由链接\"><a href=\"#1）路由链接\" class=\"headerlink\" title=\"(1）路由链接\"></a>(1）路由链接</h6><p>  就是使用Link 标签，这样的方式不会发送请求</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Link</span> to=<span class=\"string\">&quot;/about/1&quot;</span>&gt;about&lt;/<span class=\"title class_\">Link</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2）非路由链接\"><a href=\"#2）非路由链接\" class=\"headerlink\" title=\"(2）非路由链接\"></a>(2）非路由链接</h6><p>一般是指a 标签，这样的方式会发送请求</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;/home&quot;</span>&gt;home&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3）history-—-this-props-history\"><a href=\"#3）history-—-this-props-history\" class=\"headerlink\" title=\"(3）history    —-   this.props.history\"></a>(3）history    —-   this.props.history</h6><p> 通过给history push或者replace来跳转</p>\n<ul>\n<li><p><code>this.props.history.push(&quot;/home&quot;);</code></p>\n</li>\n<li><p><code>this.props.history.replace(&quot;/home&quot;);</code></p>\n<p>区别：replace 会替换掉上一个页面，如果向返回上一个页面，就不会返回成功</p>\n<p>history 的回退与前进</p>\n</li>\n</ul>\n<blockquote>\n<p>this.props.history.goBack();<br>this.props.history.goForward();</p>\n</blockquote>\n<p>一般这种方式用于不用链接的方式跳转，比如：按钮点击</p>\n","site":{"data":{}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","excerpt":"","more":"<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的UI 界面，这些代码片段被称作“组件”。</p>\n<h4 id=\"一、js支持\"><a href=\"#一、js支持\" class=\"headerlink\" title=\"一、js支持\"></a>一、js支持</h4><ul>\n<li>react.js   :     React的核心库</li>\n<li>react-dom.js   :   提供操作Dom 的react 扩展库</li>\n<li>babel.min.js   ： 解析 JSX 语法代码转为纯JS 语法代码库</li>\n</ul>\n<h4 id=\"二、组件\"><a href=\"#二、组件\" class=\"headerlink\" title=\"二、组件\"></a>二、组件</h4><h5 id=\"1、工厂方法组件-：简单组件，只有数据显示等简单操作\"><a href=\"#1、工厂方法组件-：简单组件，只有数据显示等简单操作\" class=\"headerlink\" title=\"1、工厂方法组件 ：简单组件，只有数据显示等简单操作\"></a>1、工厂方法组件 ：简单组件，只有数据显示等简单操作</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyCompoent</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>MyCompoent,方法组件<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2、ES6-类组件-：复杂组件，需要对数据进行操作的操作的复杂操作\"><a href=\"#2、ES6-类组件-：复杂组件，需要对数据进行操作的操作的复杂操作\" class=\"headerlink\" title=\"2、ES6 类组件 ：复杂组件，需要对数据进行操作的操作的复杂操作\"></a>2、ES6 类组件 ：复杂组件，需要对数据进行操作的操作的复杂操作</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCompoent2</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&#123;</span><br><span class=\"line\">     <span class=\"title function_\">render</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>MyCompoent2,类组件<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">          );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"三、组件三大属性\"><a href=\"#三、组件三大属性\" class=\"headerlink\" title=\"三、组件三大属性\"></a>三、组件三大属性</h4><h5 id=\"1、state\"><a href=\"#1、state\" class=\"headerlink\" title=\"1、state\"></a>1、state</h5><p>类组件中，才会state 属性<br>state 是一个对象，也称是组件的状态，如果state 的值改变，也称状态改变，就会重新渲染页面（一般结合 事件方法 来改变状态）</p>\n<h6 id=\"（1）设置状态：一个类组件，最开始的state-为-null，我们通过构造方法来初始化-state\"><a href=\"#（1）设置状态：一个类组件，最开始的state-为-null，我们通过构造方法来初始化-state\" class=\"headerlink\" title=\"（1）设置状态：一个类组件，最开始的state 为 null，我们通过构造方法来初始化 state\"></a>（1）设置状态：一个类组件，最开始的state 为 null，我们通过构造方法来初始化 state</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>)&#123;</span><br><span class=\"line\">       <span class=\"variable language_\">super</span>(props); </span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=&#123;</span><br><span class=\"line\">            <span class=\"attr\">is</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：构造函数中需要调用父类的构造函数 <code>super(props);</code></p>\n<h6 id=\"2-使用状态：使用state-的值-通过-this-state-is-来使用\"><a href=\"#2-使用状态：使用state-的值-通过-this-state-is-来使用\" class=\"headerlink\" title=\"(2) 使用状态：使用state 的值 通过 this.state.is  来使用\"></a>(2) 使用状态：使用state 的值 通过 this.state.is  来使用</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;&#123;<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">is</span> ? <span class=\"string\">&quot;我喜欢你&quot;</span>:<span class=\"string\">&quot;你喜欢我&quot;</span>&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3-修改状态：改变state-通过-this-setState-方法来实现，传入一个对象\"><a href=\"#3-修改状态：改变state-通过-this-setState-方法来实现，传入一个对象\" class=\"headerlink\" title=\"(3) 修改状态：改变state 通过 this.setState() 方法来实现，传入一个对象\"></a>(3) 修改状态：改变state 通过 this.setState() 方法来实现，传入一个对象</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">is</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>注意：我们需要通过一种操作来改变状态，需要结合事件方法来实现，这个时候我们要注意事件处理方法中的this 指向问题<br>              方法的this 是 undefined，我们就不能调用到组件的属性<br>              我们可以在 <code>构造方法</code> 中使用<br>            <code>this.fun=this.fun.bind(this);</code><br>             来绑定this  的指向 或者<br>             <code>&lt;h1 onClick=&#123;()=&gt;this.fun()&#125;&gt;&lt;/h1&gt;</code></p>\n<h5 id=\"2、props\"><a href=\"#2、props\" class=\"headerlink\" title=\"2、props\"></a>2、props</h5><p>方法组件、类组件 都存在props 属性</p>\n<h6 id=\"（1）设置props\"><a href=\"#（1）设置props\" class=\"headerlink\" title=\"（1）设置props\"></a>（1）设置props</h6><p>   props 是通过组件自定义的属性，传递给组件，供组件使用，可以是对象 等任意类型，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">MyCompoent</span> msg=<span class=\"string\">&quot;this is MyCompoent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2）使用props\"><a href=\"#2）使用props\" class=\"headerlink\" title=\"(2）使用props\"></a>(2）使用props</h6><ul>\n<li>方法组件 通过传入的参数来使用</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyCompoent</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (</span><br><span class=\"line\">         <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;props.msg&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">     );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类组件 通过this.props.msg 使用</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCompoent2</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&#123;</span><br><span class=\"line\">      <span class=\"title function_\">render</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (</span><br><span class=\"line\">               <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;this.props.msg&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">          );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3）其他\"><a href=\"#3）其他\" class=\"headerlink\" title=\"(3）其他\"></a>(3）其他</h6><ul>\n<li>设置属性默认值</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">MyCompoent</span>.<span class=\"property\">defaultProps</span>=&#123;</span><br><span class=\"line\">\t<span class=\"attr\">msg</span>:<span class=\"string\">&quot;666&quot;</span></span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置属性类型 和必要性</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Time</span>.<span class=\"property\">propTypes</span>=&#123;</span><br><span class=\"line\">       <span class=\"attr\">name</span>:<span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,    <span class=\"comment\">//name属性  字符串类型     必须有</span></span><br><span class=\"line\">       <span class=\"attr\">age</span>:<span class=\"title class_\">PropTypes</span>.<span class=\"property\">number</span> <span class=\"comment\">//age 属性    数字类型  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3、refs\"><a href=\"#3、refs\" class=\"headerlink\" title=\"3、refs\"></a>3、refs</h5><p>表示组件内的元素</p>\n<h6 id=\"（1）设置refs\"><a href=\"#（1）设置refs\" class=\"headerlink\" title=\"（1）设置refs\"></a>（1）设置refs</h6><p>​        第一种<br>​              <code>&lt;input type=&quot;text&quot; ref=&quot;context&quot;/&gt;   //老版本   现在也可以用</code><br>​        第二种<br>​              <code>&lt;input type=&quot;text&quot; ref=&#123; e =&gt; this.context=e&#125;/&gt;  //新版本\n​            //直接将该标签 绑定给 组件对象的一个属性</code></p>\n<h6 id=\"2）使用refs\"><a href=\"#2）使用refs\" class=\"headerlink\" title=\"(2）使用refs\"></a>(2）使用refs</h6><p>​        第一种<br>​            <code>this.refs.context.value  //获取input的值</code><br>​        第二种<br>​            <code>this.context.value   //获取input的</code></p>\n<h6 id=\"3-获取表单数据\"><a href=\"#3-获取表单数据\" class=\"headerlink\" title=\"(3) 获取表单数据\"></a>(3) 获取表单数据</h6><ul>\n<li><blockquote>\n<p>使用ref绑定input 输入框，获取输入数据</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p> 创建一个状态state，将其设置为输入框的value</p>\n<p> 输入框通过onChange 实时改变状态的值，就得到了输入数据</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"四、组件生命周期\"><a href=\"#四、组件生命周期\" class=\"headerlink\" title=\"四、组件生命周期\"></a>四、组件生命周期</h4><h5 id=\"1、第一次初始化渲染显示：ReactDom-render\"><a href=\"#1、第一次初始化渲染显示：ReactDom-render\" class=\"headerlink\" title=\"1、第一次初始化渲染显示：ReactDom.render()\"></a>1、第一次初始化渲染显示：ReactDom.render()</h5><blockquote>\n<p>constructor()：创建对象初始化 state</p>\n<p>componentWillMount()：将插入回调</p>\n<p>render()：用于插入虚拟DOM回调</p>\n<p>componentDidMount()：已经插入回电</p>\n</blockquote>\n<h5 id=\"2、每次更新state：this-setState\"><a href=\"#2、每次更新state：this-setState\" class=\"headerlink\" title=\"2、每次更新state：this.setState()\"></a>2、每次更新state：this.setState()</h5><blockquote>\n<p>componentWillUpadate()：将要更新回调<br>render()：更新，重新渲染<br>componentDidUpdate()：已经更新回调</p>\n</blockquote>\n<h5 id=\"3、移除组件：ReactDOM-unmountComponentAtNode-contarnerDom\"><a href=\"#3、移除组件：ReactDOM-unmountComponentAtNode-contarnerDom\" class=\"headerlink\" title=\"3、移除组件：ReactDOM.unmountComponentAtNode(contarnerDom)\"></a>3、移除组件：ReactDOM.unmountComponentAtNode(contarnerDom)</h5><blockquote>\n<p>componentWillUnmount()：组件将要被移除回调</p>\n</blockquote>\n<h4 id=\"五、组件间的通信\"><a href=\"#五、组件间的通信\" class=\"headerlink\" title=\"五、组件间的通信\"></a>五、组件间的通信</h4><ul>\n<li>方式一：通过props 传递</li>\n</ul>\n<blockquote>\n<p>共同的数据放在父组件上，特有的数据放在自己组件内部state<br>通过props 可以传递一般数据和函数数据，只能一层一层的传递<br>一般数据 –&gt; 父组件传递数据给子组件 –&gt; 子组件使用数据<br>函数数据 –&gt; 子组件传递数据个父组件 –&gt; 子组件调用函数</p>\n</blockquote>\n<ul>\n<li><p>方式二：使用消息订阅（subscribe）-发布（publish）机制</p>\n<blockquote>\n<p>工具库：PubSubJS</p>\n<p>下载：npm install pubsub-js –save<br>使用：</p>\n<pre><code>PubSub.subcribe(&quot;名称&quot;,“回调函数”)；//订阅\nPubSub.publish(&quot;名称&quot;,&quot;参数..&quot;); //发布</code></pre></blockquote>\n</li>\n</ul>\n<h4 id=\"六、React-Router\"><a href=\"#六、React-Router\" class=\"headerlink\" title=\"六、React-Router\"></a>六、React-Router</h4><h5 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save react-router-dom</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2、使用\"><a href=\"#2、使用\" class=\"headerlink\" title=\"2、使用\"></a>2、使用</h5><ul>\n<li>在应用的入口文件 使用根组件（App.js）时，引入 BrowserRouter 或者 HashRouter 标签，将根组件作为它的子标签</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(</span><br><span class=\"line\">\t<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t <span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span>,</span><br><span class=\"line\">\t<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;root&#x27;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编写路由组件</li>\n<li>路由链接：<code>&lt;Link/&gt;,&lt;NavLink/&gt;</code></li>\n<li>路由：<code>&lt;Route/&gt;</code></li>\n</ul>\n<h5 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div className=<span class=\"string\">&quot;App&quot;</span>&gt;</span><br><span class=\"line\">\t        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;home&quot;</span> &gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;about&quot;</span> &gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/home&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/about&quot;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t                <span class=\"tag\">&lt;<span class=\"name\">Redirect</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;/home&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Redirect</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>&lt;Switch/&gt;</code> : 同一时刻只能显示一个组件</li>\n<li><code>&lt;Redirect/&gt;</code>：重定向</li>\n</ul>\n<h5 id=\"3、路由传值\"><a href=\"#3、路由传值\" class=\"headerlink\" title=\"3、路由传值\"></a>3、路由传值</h5><h6 id=\"1）设置路由\"><a href=\"#1）设置路由\" class=\"headerlink\" title=\"(1）设置路由\"></a>(1）设置路由</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Route</span> path=<span class=\"string\">&quot;/about/:id&quot;</span> component=&#123;<span class=\"title class_\">About</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>#id 可任意取</p>\n<h6 id=\"2）设置路由链接\"><a href=\"#2）设置路由链接\" class=\"headerlink\" title=\"(2）设置路由链接\"></a>(2）设置路由链接</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Link</span> to=<span class=\"string\">&quot;/about/1&quot;</span>&gt;about&lt;/<span class=\"title class_\">Link</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3）获取值\"><a href=\"#3）获取值\" class=\"headerlink\" title=\"(3）获取值\"></a>(3）获取值</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">match</span>.<span class=\"property\">params</span>.<span class=\"property\">id</span></span><br></pre></td></tr></table></figure>\n\n<p> #id 对应路由中的名称</p>\n<h5 id=\"4、路由跳转方式\"><a href=\"#4、路由跳转方式\" class=\"headerlink\" title=\"4、路由跳转方式\"></a>4、路由跳转方式</h5><h6 id=\"1）路由链接\"><a href=\"#1）路由链接\" class=\"headerlink\" title=\"(1）路由链接\"></a>(1）路由链接</h6><p>  就是使用Link 标签，这样的方式不会发送请求</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Link</span> to=<span class=\"string\">&quot;/about/1&quot;</span>&gt;about&lt;/<span class=\"title class_\">Link</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2）非路由链接\"><a href=\"#2）非路由链接\" class=\"headerlink\" title=\"(2）非路由链接\"></a>(2）非路由链接</h6><p>一般是指a 标签，这样的方式会发送请求</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;/home&quot;</span>&gt;home&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3）history-—-this-props-history\"><a href=\"#3）history-—-this-props-history\" class=\"headerlink\" title=\"(3）history    —-   this.props.history\"></a>(3）history    —-   this.props.history</h6><p> 通过给history push或者replace来跳转</p>\n<ul>\n<li><p><code>this.props.history.push(&quot;/home&quot;);</code></p>\n</li>\n<li><p><code>this.props.history.replace(&quot;/home&quot;);</code></p>\n<p>区别：replace 会替换掉上一个页面，如果向返回上一个页面，就不会返回成功</p>\n<p>history 的回退与前进</p>\n</li>\n</ul>\n<blockquote>\n<p>this.props.history.goBack();<br>this.props.history.goForward();</p>\n</blockquote>\n<p>一般这种方式用于不用链接的方式跳转，比如：按钮点击</p>\n"},{"title":"React Fiber 简单理解","date":"2021-11-08T02:19:20.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/08/5FyRd9cuxGIzXYt.jpg","_content":"\n### React Fiber 简单理解\n\nReact Fiber解决了页面卡顿的问题，React 在diff 新旧vdom的时候，是对比的整个vdom，如果应用比较大的时候，就会存在卡顿。不像vue，vue的响应式，将更改确定在组件层级，diff不会涉及整个vdom。\n\n主要原因还是因为浏览器和js单线程的关系，都知道浏览器在执行js脚本的时候会阻塞页面的解析和渲染，React 在没有Fiber的时候，就相当于对浏览器说：‘先执行我的脚本，再做其他的’，有了Fiber之后，就相当于对浏览器说：‘等你有空了再执行我的脚本’。\n\n* requestIdleCallback API\n\n这是谷歌浏览器提供的一个api，主要作用就是告诉浏览器，让它在空闲的时候执行我们传入的callback\n\n但是这个api有兼容性问题，React并没用采用，而是自己重新实现了一个，它利用[`MessageChannel`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMessageChannel) 模拟将回调延迟到'绘制操作'之后执行\n\n并且react 将任务分成不同的优先级：\n\n* `Immediate`(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断\n\n* `UserBlocking`(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈\n\n* `Normal` (5s) 应对哪些不需要立即感受到的任务，例如网络请求\n\n* `Low` (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知\n\n* `Idle` (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死\n\nreact 使用链表来模拟函数调用栈，为了更好的知道中断位置来恢复执行\n\nreact将渲染分成两个阶段：\n\n* 协调阶段：可以认为是 Diff 阶段, **这个阶段可以被中断**, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等,\n* 提交阶段： 将上一个阶段计算出来的需要处理的**副作用(Effects)**一次性执行了。**这个阶段必须同步执行，不能被打断**.\n\n","source":"_posts/ReactFiber.md","raw":"---\ntitle: React Fiber 简单理解\ndate: 2021-11-08 10:19:20\ncategories:  react\ntags: [react]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/08/5FyRd9cuxGIzXYt.jpg\n---\n\n### React Fiber 简单理解\n\nReact Fiber解决了页面卡顿的问题，React 在diff 新旧vdom的时候，是对比的整个vdom，如果应用比较大的时候，就会存在卡顿。不像vue，vue的响应式，将更改确定在组件层级，diff不会涉及整个vdom。\n\n主要原因还是因为浏览器和js单线程的关系，都知道浏览器在执行js脚本的时候会阻塞页面的解析和渲染，React 在没有Fiber的时候，就相当于对浏览器说：‘先执行我的脚本，再做其他的’，有了Fiber之后，就相当于对浏览器说：‘等你有空了再执行我的脚本’。\n\n* requestIdleCallback API\n\n这是谷歌浏览器提供的一个api，主要作用就是告诉浏览器，让它在空闲的时候执行我们传入的callback\n\n但是这个api有兼容性问题，React并没用采用，而是自己重新实现了一个，它利用[`MessageChannel`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMessageChannel) 模拟将回调延迟到'绘制操作'之后执行\n\n并且react 将任务分成不同的优先级：\n\n* `Immediate`(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断\n\n* `UserBlocking`(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈\n\n* `Normal` (5s) 应对哪些不需要立即感受到的任务，例如网络请求\n\n* `Low` (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知\n\n* `Idle` (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死\n\nreact 使用链表来模拟函数调用栈，为了更好的知道中断位置来恢复执行\n\nreact将渲染分成两个阶段：\n\n* 协调阶段：可以认为是 Diff 阶段, **这个阶段可以被中断**, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等,\n* 提交阶段： 将上一个阶段计算出来的需要处理的**副作用(Effects)**一次性执行了。**这个阶段必须同步执行，不能被打断**.\n\n","slug":"ReactFiber","published":1,"updated":"2021-11-08T02:22:30.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1ma002udswkfaif0ovl","content":"<h3 id=\"React-Fiber-简单理解\"><a href=\"#React-Fiber-简单理解\" class=\"headerlink\" title=\"React Fiber 简单理解\"></a>React Fiber 简单理解</h3><p>React Fiber解决了页面卡顿的问题，React 在diff 新旧vdom的时候，是对比的整个vdom，如果应用比较大的时候，就会存在卡顿。不像vue，vue的响应式，将更改确定在组件层级，diff不会涉及整个vdom。</p>\n<p>主要原因还是因为浏览器和js单线程的关系，都知道浏览器在执行js脚本的时候会阻塞页面的解析和渲染，React 在没有Fiber的时候，就相当于对浏览器说：‘先执行我的脚本，再做其他的’，有了Fiber之后，就相当于对浏览器说：‘等你有空了再执行我的脚本’。</p>\n<ul>\n<li>requestIdleCallback API</li>\n</ul>\n<p>这是谷歌浏览器提供的一个api，主要作用就是告诉浏览器，让它在空闲的时候执行我们传入的callback</p>\n<p>但是这个api有兼容性问题，React并没用采用，而是自己重新实现了一个，它利用<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMessageChannel\"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行</p>\n<p>并且react 将任务分成不同的优先级：</p>\n<ul>\n<li><p><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</p>\n</li>\n<li><p><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</p>\n</li>\n<li><p><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</p>\n</li>\n<li><p><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</p>\n</li>\n<li><p><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</p>\n</li>\n</ul>\n<p>react 使用链表来模拟函数调用栈，为了更好的知道中断位置来恢复执行</p>\n<p>react将渲染分成两个阶段：</p>\n<ul>\n<li>协调阶段：可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等,</li>\n<li>提交阶段： 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React-Fiber-简单理解\"><a href=\"#React-Fiber-简单理解\" class=\"headerlink\" title=\"React Fiber 简单理解\"></a>React Fiber 简单理解</h3><p>React Fiber解决了页面卡顿的问题，React 在diff 新旧vdom的时候，是对比的整个vdom，如果应用比较大的时候，就会存在卡顿。不像vue，vue的响应式，将更改确定在组件层级，diff不会涉及整个vdom。</p>\n<p>主要原因还是因为浏览器和js单线程的关系，都知道浏览器在执行js脚本的时候会阻塞页面的解析和渲染，React 在没有Fiber的时候，就相当于对浏览器说：‘先执行我的脚本，再做其他的’，有了Fiber之后，就相当于对浏览器说：‘等你有空了再执行我的脚本’。</p>\n<ul>\n<li>requestIdleCallback API</li>\n</ul>\n<p>这是谷歌浏览器提供的一个api，主要作用就是告诉浏览器，让它在空闲的时候执行我们传入的callback</p>\n<p>但是这个api有兼容性问题，React并没用采用，而是自己重新实现了一个，它利用<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMessageChannel\"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行</p>\n<p>并且react 将任务分成不同的优先级：</p>\n<ul>\n<li><p><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</p>\n</li>\n<li><p><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</p>\n</li>\n<li><p><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</p>\n</li>\n<li><p><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</p>\n</li>\n<li><p><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</p>\n</li>\n</ul>\n<p>react 使用链表来模拟函数调用栈，为了更好的知道中断位置来恢复执行</p>\n<p>react将渲染分成两个阶段：</p>\n<ul>\n<li>协调阶段：可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等,</li>\n<li>提交阶段： 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)</strong>一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>.</li>\n</ul>\n"},{"title":"微前端:micro-app","date":"2022-03-16T08:27:27.000Z","description":"学习总结","cover":"https://s2.loli.net/2022/03/16/okgAipbt8jS5rs2.jpg","_content":"\n# 微前端：京东的MicroApp\n\n[文档](https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/start)\n\n微前端在前端领域中是炙手可热的话题，将一个应用的不同模块单独建立应用，使用不同的框架生态来实现，再整合成一个应用\n\n在实际业务中，我们也遇到同样的问题，并且在不同的业务场景下尝试了各种解决方案，如iframe、npm包、微前端框架，并对各种方案的优劣进行了对比。\n\n**iframe**：在所有微前端方案中，iframe是最稳定的、上手难度最低的，但它有一些无法解决的问题，例如性能低、通信复杂、双滚动条、弹窗无法全局覆盖，它的成长性不高，只适合简单的页面渲染。\n\n**npm包**：将子应用封装成npm包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。\n\n**微前端框架**：流行的微前端框架有single-spa和qiankun，它们将维护成本和功能上达到一种平衡，是目前实现微前端备受推崇的方案。\n由于iframe和npm包存在问题理论上无法解决，在最初我们采用qiankun作为解决方案，qiankun是在single-spa基础上进行了封装，提供了js沙箱、样式隔离、预加载等功能，并且与技术栈无关，可以兼容不同的框架。\n\n而**micro-app**利用了WebComponent,自定义元素`micro-app`,在生命周期函数connectedCallback监听元素被渲染，加载子应用的html并转换为DOM结构，递归查询所有js和css等静态资源并加载，设置元素隔离，拦截所有动态创建的script、link等标签，提取标签内容。将加载的js经过插件系统处理后放入沙箱中运行，对css资源进行样式隔离，最后将格式化后的元素放入micro-app中，最终将micro-app元素渲染为一个微前端的子应用\n![](https://s2.loli.net/2022/03/16/yer1OwGfJo2du3C.png)\n[参考文章](https://juejin.cn/post/6989435430559023117)","source":"_posts/Study-microApp.md","raw":"---\ntitle: 微前端:micro-app\ndate: 2022-03-16 16:27:27\ncategories: 微前端\ntags: [微前端]\ndescription: 学习总结\ncover: https://s2.loli.net/2022/03/16/okgAipbt8jS5rs2.jpg\n---\n\n# 微前端：京东的MicroApp\n\n[文档](https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/start)\n\n微前端在前端领域中是炙手可热的话题，将一个应用的不同模块单独建立应用，使用不同的框架生态来实现，再整合成一个应用\n\n在实际业务中，我们也遇到同样的问题，并且在不同的业务场景下尝试了各种解决方案，如iframe、npm包、微前端框架，并对各种方案的优劣进行了对比。\n\n**iframe**：在所有微前端方案中，iframe是最稳定的、上手难度最低的，但它有一些无法解决的问题，例如性能低、通信复杂、双滚动条、弹窗无法全局覆盖，它的成长性不高，只适合简单的页面渲染。\n\n**npm包**：将子应用封装成npm包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。\n\n**微前端框架**：流行的微前端框架有single-spa和qiankun，它们将维护成本和功能上达到一种平衡，是目前实现微前端备受推崇的方案。\n由于iframe和npm包存在问题理论上无法解决，在最初我们采用qiankun作为解决方案，qiankun是在single-spa基础上进行了封装，提供了js沙箱、样式隔离、预加载等功能，并且与技术栈无关，可以兼容不同的框架。\n\n而**micro-app**利用了WebComponent,自定义元素`micro-app`,在生命周期函数connectedCallback监听元素被渲染，加载子应用的html并转换为DOM结构，递归查询所有js和css等静态资源并加载，设置元素隔离，拦截所有动态创建的script、link等标签，提取标签内容。将加载的js经过插件系统处理后放入沙箱中运行，对css资源进行样式隔离，最后将格式化后的元素放入micro-app中，最终将micro-app元素渲染为一个微前端的子应用\n![](https://s2.loli.net/2022/03/16/yer1OwGfJo2du3C.png)\n[参考文章](https://juejin.cn/post/6989435430559023117)","slug":"Study-microApp","published":1,"updated":"2022-03-16T08:49:44.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1mc002zdswk9bby5keh","content":"<h1 id=\"微前端：京东的MicroApp\"><a href=\"#微前端：京东的MicroApp\" class=\"headerlink\" title=\"微前端：京东的MicroApp\"></a>微前端：京东的MicroApp</h1><p><a href=\"https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/start\">文档</a></p>\n<p>微前端在前端领域中是炙手可热的话题，将一个应用的不同模块单独建立应用，使用不同的框架生态来实现，再整合成一个应用</p>\n<p>在实际业务中，我们也遇到同样的问题，并且在不同的业务场景下尝试了各种解决方案，如iframe、npm包、微前端框架，并对各种方案的优劣进行了对比。</p>\n<p><strong>iframe</strong>：在所有微前端方案中，iframe是最稳定的、上手难度最低的，但它有一些无法解决的问题，例如性能低、通信复杂、双滚动条、弹窗无法全局覆盖，它的成长性不高，只适合简单的页面渲染。</p>\n<p><strong>npm包</strong>：将子应用封装成npm包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。</p>\n<p><strong>微前端框架</strong>：流行的微前端框架有single-spa和qiankun，它们将维护成本和功能上达到一种平衡，是目前实现微前端备受推崇的方案。<br>由于iframe和npm包存在问题理论上无法解决，在最初我们采用qiankun作为解决方案，qiankun是在single-spa基础上进行了封装，提供了js沙箱、样式隔离、预加载等功能，并且与技术栈无关，可以兼容不同的框架。</p>\n<p>而<strong>micro-app</strong>利用了WebComponent,自定义元素<code>micro-app</code>,在生命周期函数connectedCallback监听元素被渲染，加载子应用的html并转换为DOM结构，递归查询所有js和css等静态资源并加载，设置元素隔离，拦截所有动态创建的script、link等标签，提取标签内容。将加载的js经过插件系统处理后放入沙箱中运行，对css资源进行样式隔离，最后将格式化后的元素放入micro-app中，最终将micro-app元素渲染为一个微前端的子应用<br><img src= \"/img/loading.gif\" data-src=\"https://s2.loli.net/2022/03/16/yer1OwGfJo2du3C.png\" alt=\"\"><br><a href=\"https://juejin.cn/post/6989435430559023117\">参考文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"微前端：京东的MicroApp\"><a href=\"#微前端：京东的MicroApp\" class=\"headerlink\" title=\"微前端：京东的MicroApp\"></a>微前端：京东的MicroApp</h1><p><a href=\"https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/start\">文档</a></p>\n<p>微前端在前端领域中是炙手可热的话题，将一个应用的不同模块单独建立应用，使用不同的框架生态来实现，再整合成一个应用</p>\n<p>在实际业务中，我们也遇到同样的问题，并且在不同的业务场景下尝试了各种解决方案，如iframe、npm包、微前端框架，并对各种方案的优劣进行了对比。</p>\n<p><strong>iframe</strong>：在所有微前端方案中，iframe是最稳定的、上手难度最低的，但它有一些无法解决的问题，例如性能低、通信复杂、双滚动条、弹窗无法全局覆盖，它的成长性不高，只适合简单的页面渲染。</p>\n<p><strong>npm包</strong>：将子应用封装成npm包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。</p>\n<p><strong>微前端框架</strong>：流行的微前端框架有single-spa和qiankun，它们将维护成本和功能上达到一种平衡，是目前实现微前端备受推崇的方案。<br>由于iframe和npm包存在问题理论上无法解决，在最初我们采用qiankun作为解决方案，qiankun是在single-spa基础上进行了封装，提供了js沙箱、样式隔离、预加载等功能，并且与技术栈无关，可以兼容不同的框架。</p>\n<p>而<strong>micro-app</strong>利用了WebComponent,自定义元素<code>micro-app</code>,在生命周期函数connectedCallback监听元素被渲染，加载子应用的html并转换为DOM结构，递归查询所有js和css等静态资源并加载，设置元素隔离，拦截所有动态创建的script、link等标签，提取标签内容。将加载的js经过插件系统处理后放入沙箱中运行，对css资源进行样式隔离，最后将格式化后的元素放入micro-app中，最终将micro-app元素渲染为一个微前端的子应用<br><img src=\"https://s2.loli.net/2022/03/16/yer1OwGfJo2du3C.png\" alt=\"\"><br><a href=\"https://juejin.cn/post/6989435430559023117\">参考文章</a></p>\n"},{"title":"WebComponent","date":"2021-11-08T02:25:20.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/08/LoPrsA7Y8XRwSk6.jpg","_content":"\n## WebComponent\n\n在了解WebComponent是什么之前，先了解一下组件.\n\n### 一、组件\n\n组件已经是老生常谈得话题了，相信大家都用过了，毕竟React、Vue等框架等会使用到。\n\n在vue中，组件提高了我们得代码复用率，让我们把公共得页面提取出来，并且通过prop等方式将数据传递给组件。还有solt插槽，都是为了更好的封装组件。\n\n但是不同的框架的组件化实现方式不一样，这就导致在学习了新的框架，就要采用新的组件化方式。\n\n为了让Web组件模型得到统一， [W3C](https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2F) 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。它就是WebComponent。\n\n### 二、使用方式\n\n#### 1、定义模板\n\n首先可以使用template标签来定义一个HTML模板\n\n```html\n  <template id=\"custom-component\">\n    <style>\n      h1{\n        color: red;\n      }\n      p{\n        color: blue;\n      }\n    </style>\n    <solt name=\"text\"></solt>\n    <p>component-text</p>\n  </template>\n```\n\n在web Component中同样支持solt插槽，在使用的时候就可以传入其他元素\n\n在web Component中使用style可以定义组件元素的样式，但是是全局应用，后面会讲样式组件化\n\n#### 2、定义组件\n\n可以通过创建一个类继承HTMLElement来定义一个组件\n\n```js\n class CustomComponent extends HTMLElement {\n      constructor(){\n        super();\n         //获取HTML模板的id\n        const customComponent = document.getElementById('custom-component');\n        //将标签里面的内容插入到模板里\n        this.appendChild(customComponent.content.cloneNode(true));\n      }\n    }\n```\n\n把本来DOM树中的一部分封装起来，并且隐藏起来，隐藏起来的树概念为Shadow Tree。把它理解成DOM上一棵特殊的子树，称之为shadow tree或影子树。也是树，但是很特殊，树里面也是DOM，就像我们上面用document.createElement创建的DOM一样。\n\n```js\nclass CustomComponent extends HTMLElement {\n      constructor(){\n        super();\n        //创建shadow\n        const shadow = this.attachShadow({mode:'closed'})\n        //获取HTML模板的id\n        const customComponent = document.getElementById('custom-component');\n        //将标签里面的内容插入到shadow\n        shadow.appendChild(customComponent.content.cloneNode(true));\n      }\n    }\n```\n\nshadow可以防止样式应用到全局，但是使用shadow之后不能使用solt\n\n然后使用window.customElements.define自定义个标签\n\n```js\nwindow.customElements.define('custom-component',CustomComponent)\n```\n\n#### 3、使用组件\n\n```html\n<custom-component>\n    <p solt=\"text\">solt-text</p>\n  </custom-component>\n```\n\n","source":"_posts/WebComponent.md","raw":"---\ntitle: WebComponent\ndate: 2021-11-08 10:25:20\ncategories:  component\ntags: [component]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/08/LoPrsA7Y8XRwSk6.jpg\n---\n\n## WebComponent\n\n在了解WebComponent是什么之前，先了解一下组件.\n\n### 一、组件\n\n组件已经是老生常谈得话题了，相信大家都用过了，毕竟React、Vue等框架等会使用到。\n\n在vue中，组件提高了我们得代码复用率，让我们把公共得页面提取出来，并且通过prop等方式将数据传递给组件。还有solt插槽，都是为了更好的封装组件。\n\n但是不同的框架的组件化实现方式不一样，这就导致在学习了新的框架，就要采用新的组件化方式。\n\n为了让Web组件模型得到统一， [W3C](https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2F) 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。它就是WebComponent。\n\n### 二、使用方式\n\n#### 1、定义模板\n\n首先可以使用template标签来定义一个HTML模板\n\n```html\n  <template id=\"custom-component\">\n    <style>\n      h1{\n        color: red;\n      }\n      p{\n        color: blue;\n      }\n    </style>\n    <solt name=\"text\"></solt>\n    <p>component-text</p>\n  </template>\n```\n\n在web Component中同样支持solt插槽，在使用的时候就可以传入其他元素\n\n在web Component中使用style可以定义组件元素的样式，但是是全局应用，后面会讲样式组件化\n\n#### 2、定义组件\n\n可以通过创建一个类继承HTMLElement来定义一个组件\n\n```js\n class CustomComponent extends HTMLElement {\n      constructor(){\n        super();\n         //获取HTML模板的id\n        const customComponent = document.getElementById('custom-component');\n        //将标签里面的内容插入到模板里\n        this.appendChild(customComponent.content.cloneNode(true));\n      }\n    }\n```\n\n把本来DOM树中的一部分封装起来，并且隐藏起来，隐藏起来的树概念为Shadow Tree。把它理解成DOM上一棵特殊的子树，称之为shadow tree或影子树。也是树，但是很特殊，树里面也是DOM，就像我们上面用document.createElement创建的DOM一样。\n\n```js\nclass CustomComponent extends HTMLElement {\n      constructor(){\n        super();\n        //创建shadow\n        const shadow = this.attachShadow({mode:'closed'})\n        //获取HTML模板的id\n        const customComponent = document.getElementById('custom-component');\n        //将标签里面的内容插入到shadow\n        shadow.appendChild(customComponent.content.cloneNode(true));\n      }\n    }\n```\n\nshadow可以防止样式应用到全局，但是使用shadow之后不能使用solt\n\n然后使用window.customElements.define自定义个标签\n\n```js\nwindow.customElements.define('custom-component',CustomComponent)\n```\n\n#### 3、使用组件\n\n```html\n<custom-component>\n    <p solt=\"text\">solt-text</p>\n  </custom-component>\n```\n\n","slug":"WebComponent","published":1,"updated":"2021-11-08T02:25:07.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1md0031dswkf40u1ti0","content":"<h2 id=\"WebComponent\"><a href=\"#WebComponent\" class=\"headerlink\" title=\"WebComponent\"></a>WebComponent</h2><p>在了解WebComponent是什么之前，先了解一下组件.</p>\n<h3 id=\"一、组件\"><a href=\"#一、组件\" class=\"headerlink\" title=\"一、组件\"></a>一、组件</h3><p>组件已经是老生常谈得话题了，相信大家都用过了，毕竟React、Vue等框架等会使用到。</p>\n<p>在vue中，组件提高了我们得代码复用率，让我们把公共得页面提取出来，并且通过prop等方式将数据传递给组件。还有solt插槽，都是为了更好的封装组件。</p>\n<p>但是不同的框架的组件化实现方式不一样，这就导致在学习了新的框架，就要采用新的组件化方式。</p>\n<p>为了让Web组件模型得到统一， <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2F\">W3C</a> 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。它就是WebComponent。</p>\n<h3 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h3><h4 id=\"1、定义模板\"><a href=\"#1、定义模板\" class=\"headerlink\" title=\"1、定义模板\"></a>1、定义模板</h4><p>首先可以使用template标签来定义一个HTML模板</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;custom-component&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-tag\">h1</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">color</span>: red;</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-tag\">p</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">color</span>: blue;</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">solt</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">solt</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>component-text<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在web Component中同样支持solt插槽，在使用的时候就可以传入其他元素</p>\n<p>在web Component中使用style可以定义组件元素的样式，但是是全局应用，后面会讲样式组件化</p>\n<h4 id=\"2、定义组件\"><a href=\"#2、定义组件\" class=\"headerlink\" title=\"2、定义组件\"></a>2、定义组件</h4><p>可以通过创建一个类继承HTMLElement来定义一个组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">     <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">       <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"comment\">//获取HTML模板的id</span></span><br><span class=\"line\">       <span class=\"keyword\">const</span> customComponent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;custom-component&#x27;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//将标签里面的内容插入到模板里</span></span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"title function_\">appendChild</span>(customComponent.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把本来DOM树中的一部分封装起来，并且隐藏起来，隐藏起来的树概念为Shadow Tree。把它理解成DOM上一棵特殊的子树，称之为shadow tree或影子树。也是树，但是很特殊，树里面也是DOM，就像我们上面用document.createElement创建的DOM一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"comment\">//创建shadow</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> shadow = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachShadow</span>(&#123;<span class=\"attr\">mode</span>:<span class=\"string\">&#x27;closed&#x27;</span>&#125;)</span><br><span class=\"line\">        <span class=\"comment\">//获取HTML模板的id</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> customComponent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;custom-component&#x27;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//将标签里面的内容插入到shadow</span></span><br><span class=\"line\">        shadow.<span class=\"title function_\">appendChild</span>(customComponent.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>shadow可以防止样式应用到全局，但是使用shadow之后不能使用solt</p>\n<p>然后使用window.customElements.define自定义个标签</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">customElements</span>.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;custom-component&#x27;</span>,<span class=\"title class_\">CustomComponent</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、使用组件\"><a href=\"#3、使用组件\" class=\"headerlink\" title=\"3、使用组件\"></a>3、使用组件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">custom-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">solt</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>solt-text<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">custom-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"WebComponent\"><a href=\"#WebComponent\" class=\"headerlink\" title=\"WebComponent\"></a>WebComponent</h2><p>在了解WebComponent是什么之前，先了解一下组件.</p>\n<h3 id=\"一、组件\"><a href=\"#一、组件\" class=\"headerlink\" title=\"一、组件\"></a>一、组件</h3><p>组件已经是老生常谈得话题了，相信大家都用过了，毕竟React、Vue等框架等会使用到。</p>\n<p>在vue中，组件提高了我们得代码复用率，让我们把公共得页面提取出来，并且通过prop等方式将数据传递给组件。还有solt插槽，都是为了更好的封装组件。</p>\n<p>但是不同的框架的组件化实现方式不一样，这就导致在学习了新的框架，就要采用新的组件化方式。</p>\n<p>为了让Web组件模型得到统一， <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2F\">W3C</a> 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。它就是WebComponent。</p>\n<h3 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h3><h4 id=\"1、定义模板\"><a href=\"#1、定义模板\" class=\"headerlink\" title=\"1、定义模板\"></a>1、定义模板</h4><p>首先可以使用template标签来定义一个HTML模板</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;custom-component&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-tag\">h1</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">color</span>: red;</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-tag\">p</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">color</span>: blue;</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">solt</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">solt</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>component-text<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在web Component中同样支持solt插槽，在使用的时候就可以传入其他元素</p>\n<p>在web Component中使用style可以定义组件元素的样式，但是是全局应用，后面会讲样式组件化</p>\n<h4 id=\"2、定义组件\"><a href=\"#2、定义组件\" class=\"headerlink\" title=\"2、定义组件\"></a>2、定义组件</h4><p>可以通过创建一个类继承HTMLElement来定义一个组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">     <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">       <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"comment\">//获取HTML模板的id</span></span><br><span class=\"line\">       <span class=\"keyword\">const</span> customComponent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;custom-component&#x27;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//将标签里面的内容插入到模板里</span></span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"title function_\">appendChild</span>(customComponent.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把本来DOM树中的一部分封装起来，并且隐藏起来，隐藏起来的树概念为Shadow Tree。把它理解成DOM上一棵特殊的子树，称之为shadow tree或影子树。也是树，但是很特殊，树里面也是DOM，就像我们上面用document.createElement创建的DOM一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"comment\">//创建shadow</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> shadow = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachShadow</span>(&#123;<span class=\"attr\">mode</span>:<span class=\"string\">&#x27;closed&#x27;</span>&#125;)</span><br><span class=\"line\">        <span class=\"comment\">//获取HTML模板的id</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> customComponent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;custom-component&#x27;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//将标签里面的内容插入到shadow</span></span><br><span class=\"line\">        shadow.<span class=\"title function_\">appendChild</span>(customComponent.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>shadow可以防止样式应用到全局，但是使用shadow之后不能使用solt</p>\n<p>然后使用window.customElements.define自定义个标签</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">customElements</span>.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;custom-component&#x27;</span>,<span class=\"title class_\">CustomComponent</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、使用组件\"><a href=\"#3、使用组件\" class=\"headerlink\" title=\"3、使用组件\"></a>3、使用组件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">custom-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">solt</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>solt-text<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">custom-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Webpack Loader详解","date":"2021-11-11T07:06:55.000Z","description":"学习总结","cover":"https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg","_content":"\n## Webpack Loader详解\n\nLoader 的本质是导出一个**函数**的 Node 模块，它所导出的函数将在读取到目标类型（通常在 `module.rules` 中配置）源文件时调用，源文件字符串将作为参数传入这个函数，并且函数中可以通过 this 关键字访问到上下文信息和使用[ Loader API](https://webpack.js.org/api/loaders/) 中指定的属性和方法，最终**同步**或**异步**地返回处理后的结果\n\nLoader处理过程：\n\n- 根据解析的 Loader 文件路径，加载 Loader 模块，兼容 commonJS、ESModule 或 SystemJS 方式\n- 按 Loader 链数组控制 Loader 的调用过程，具体调用顺序在 Pitching Loader 小节中进一步说明，简单来说包括三个部分：pitch阶段 => 处理资源内容阶段 => Loader 函数调用阶段（同步或异步）\n\n- 持续更新 Loader Context 信息\n- 获取执行后的结果并返回 Webpack 编译流程\n\n### 一、自定义简单的Loader\n\n```js\nfunction loaderDemo(content) {\n  // 可以查看 this 提供的上下文信息和可以使用的API\n  console.log(this);\n  // 该函数需要返回处理后的结果，直接返回输入source，相当于未对资源做任何处理\n  return content;\n}\nmodule.exports = loaderDemo;\n```\n\n**注意：loader必须返回js字符串**\n\n#### 1、获取配置\n\n在 `module.rule` 配置中可以给 Loader 提供用户配置，使用 `loader-utils` 提供的 `getOptions` API 获取，\n\n```js\nconst loaderUtils = require('loader-utils');\nmodule.exports = function(content) {\n  // 获取到用户给当前 Loader 传入的配置\n  const options = loaderUtils.getOptions(this);\n  return content;\n};\n```\n\n#### 2、二进制格式数据\n\n默认情况下 Loader 函数中获取到的源码是 UTF-8 编码的字符串，在某些场景下需要获取到二进制格式的数据，比如 `file-loader` ，这时需要配置 `raw` 标记为 true\n\n```js\nmodule.exports = function(content) {\n  content instanceof Buffer === true;\n  return content;\n};\n// 通过 exports.raw = true 表示该 Loader 需要二进制格式数据\nmodule.exports.raw = true;\n```\n\n#### 3、返回其他结果\n\nLoader 通过 `return` 语句返回翻译后的内容，内容可以是 String 或 Buffer 格式，但如果需要返回其他额外信息， `return` 就不够用了，需要使用 `this.callback` 这个 API ，它有四个主要参数：\n\n```js\nthis.callback(\n  err: Error | null, // Loader处理过程中出错时，需要抛出一个Error，无错误时需要指定为 null\n  content: string | Buffer, // 转换后的内容，可以是 String 或 Buffer 格式\n  sourceMap?: SourceMap, // 可选：可被 Webpack 解析的 SourceMap\n  meta?: any, // 可选：用户自定义的其他数据，会被 Webpack 忽略\n  ... // 可选：任意个数其他参数\n);\n```\n\n使用 `this.callback` ，则函数的 return 必须返回 `undefined` ，Webpack 根据 return 内容来确认从哪里获取 Loader 翻译的结果\n\n#### 4、异步 Loader\n\nLoader 函数除了同步返回（ return 或 this.callback ）解析结果，还可以异步执行再返回结果，比如有些场景下需要异步请求网络或长时间的计算操作，此时同步返回会阻塞整个构建流程，建议借助 this.async API等待异步操作执行完成后再返回转化结果：\n\n```\nmodule.exports = function(content) {\n  // 通过 this.async API 获取异步返回的回调函数\n  const callback = this.async();\n  // 使用定时器模拟异步操作\n  setTimeout(()=>{\n    // 通过 callback 返回异步执行后的结果\n    callback(err, content, sourceMap, meta);\n  }, 2000);\n};\n```\n\n#### 5、Pitching Loader\n\n大家都知道Loader的执行顺序是从右到左执行的，其实不然，比如：\n\n```js\n... ... \nmodule: {\n  rules: [\n    {\n      //...\n      use: [\n        'a-loader',\n        'b-loader',\n        'c-loader'\n      ]\n    }\n  ]\n}\n... ...\n```\n\n实际的调用执行顺序如下：\n\n```\n|- a-loader `pitch` 调用\n  |- b-loader `pitch` 调用\n    |- c-loader `pitch` 调用\n      |- 请求模块资源文件被读取，并添加到依赖中\n    |- c-loader 调用\n  |- b-loader 调用\n|- a-loader 调用\n```\n\n pitch 函数中的入参包括：\n\n●remainingRequest \n\n●precedingRequest\n\n●data\n\n```\nmodule.exports.pitch = function(remainingRequest, precedingRequest, data) {\n  // ... ...\n};\n```\n\n如果在 `pitch` 函数中返回值，会跳过余下所有 Loader 的 `pitch` 函数的调用和 Loader 正常调用流程，仅执行已经历 `pitch` 函数调用流程的 Loader 的正常调用流程。","source":"_posts/WebpackLoader.md","raw":"---\ntitle: Webpack Loader详解\ndate: 2021-11-11 15:06:55\ncategories:  webpack\ntags: [webpack]\ndescription: 学习总结\ncover: https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg\n---\n\n## Webpack Loader详解\n\nLoader 的本质是导出一个**函数**的 Node 模块，它所导出的函数将在读取到目标类型（通常在 `module.rules` 中配置）源文件时调用，源文件字符串将作为参数传入这个函数，并且函数中可以通过 this 关键字访问到上下文信息和使用[ Loader API](https://webpack.js.org/api/loaders/) 中指定的属性和方法，最终**同步**或**异步**地返回处理后的结果\n\nLoader处理过程：\n\n- 根据解析的 Loader 文件路径，加载 Loader 模块，兼容 commonJS、ESModule 或 SystemJS 方式\n- 按 Loader 链数组控制 Loader 的调用过程，具体调用顺序在 Pitching Loader 小节中进一步说明，简单来说包括三个部分：pitch阶段 => 处理资源内容阶段 => Loader 函数调用阶段（同步或异步）\n\n- 持续更新 Loader Context 信息\n- 获取执行后的结果并返回 Webpack 编译流程\n\n### 一、自定义简单的Loader\n\n```js\nfunction loaderDemo(content) {\n  // 可以查看 this 提供的上下文信息和可以使用的API\n  console.log(this);\n  // 该函数需要返回处理后的结果，直接返回输入source，相当于未对资源做任何处理\n  return content;\n}\nmodule.exports = loaderDemo;\n```\n\n**注意：loader必须返回js字符串**\n\n#### 1、获取配置\n\n在 `module.rule` 配置中可以给 Loader 提供用户配置，使用 `loader-utils` 提供的 `getOptions` API 获取，\n\n```js\nconst loaderUtils = require('loader-utils');\nmodule.exports = function(content) {\n  // 获取到用户给当前 Loader 传入的配置\n  const options = loaderUtils.getOptions(this);\n  return content;\n};\n```\n\n#### 2、二进制格式数据\n\n默认情况下 Loader 函数中获取到的源码是 UTF-8 编码的字符串，在某些场景下需要获取到二进制格式的数据，比如 `file-loader` ，这时需要配置 `raw` 标记为 true\n\n```js\nmodule.exports = function(content) {\n  content instanceof Buffer === true;\n  return content;\n};\n// 通过 exports.raw = true 表示该 Loader 需要二进制格式数据\nmodule.exports.raw = true;\n```\n\n#### 3、返回其他结果\n\nLoader 通过 `return` 语句返回翻译后的内容，内容可以是 String 或 Buffer 格式，但如果需要返回其他额外信息， `return` 就不够用了，需要使用 `this.callback` 这个 API ，它有四个主要参数：\n\n```js\nthis.callback(\n  err: Error | null, // Loader处理过程中出错时，需要抛出一个Error，无错误时需要指定为 null\n  content: string | Buffer, // 转换后的内容，可以是 String 或 Buffer 格式\n  sourceMap?: SourceMap, // 可选：可被 Webpack 解析的 SourceMap\n  meta?: any, // 可选：用户自定义的其他数据，会被 Webpack 忽略\n  ... // 可选：任意个数其他参数\n);\n```\n\n使用 `this.callback` ，则函数的 return 必须返回 `undefined` ，Webpack 根据 return 内容来确认从哪里获取 Loader 翻译的结果\n\n#### 4、异步 Loader\n\nLoader 函数除了同步返回（ return 或 this.callback ）解析结果，还可以异步执行再返回结果，比如有些场景下需要异步请求网络或长时间的计算操作，此时同步返回会阻塞整个构建流程，建议借助 this.async API等待异步操作执行完成后再返回转化结果：\n\n```\nmodule.exports = function(content) {\n  // 通过 this.async API 获取异步返回的回调函数\n  const callback = this.async();\n  // 使用定时器模拟异步操作\n  setTimeout(()=>{\n    // 通过 callback 返回异步执行后的结果\n    callback(err, content, sourceMap, meta);\n  }, 2000);\n};\n```\n\n#### 5、Pitching Loader\n\n大家都知道Loader的执行顺序是从右到左执行的，其实不然，比如：\n\n```js\n... ... \nmodule: {\n  rules: [\n    {\n      //...\n      use: [\n        'a-loader',\n        'b-loader',\n        'c-loader'\n      ]\n    }\n  ]\n}\n... ...\n```\n\n实际的调用执行顺序如下：\n\n```\n|- a-loader `pitch` 调用\n  |- b-loader `pitch` 调用\n    |- c-loader `pitch` 调用\n      |- 请求模块资源文件被读取，并添加到依赖中\n    |- c-loader 调用\n  |- b-loader 调用\n|- a-loader 调用\n```\n\n pitch 函数中的入参包括：\n\n●remainingRequest \n\n●precedingRequest\n\n●data\n\n```\nmodule.exports.pitch = function(remainingRequest, precedingRequest, data) {\n  // ... ...\n};\n```\n\n如果在 `pitch` 函数中返回值，会跳过余下所有 Loader 的 `pitch` 函数的调用和 Loader 正常调用流程，仅执行已经历 `pitch` 函数调用流程的 Loader 的正常调用流程。","slug":"WebpackLoader","published":1,"updated":"2021-11-11T07:06:22.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1me0035dswkhwmxaxp8","content":"<h2 id=\"Webpack-Loader详解\"><a href=\"#Webpack-Loader详解\" class=\"headerlink\" title=\"Webpack Loader详解\"></a>Webpack Loader详解</h2><p>Loader 的本质是导出一个<strong>函数</strong>的 Node 模块，它所导出的函数将在读取到目标类型（通常在 <code>module.rules</code> 中配置）源文件时调用，源文件字符串将作为参数传入这个函数，并且函数中可以通过 this 关键字访问到上下文信息和使用<a href=\"https://webpack.js.org/api/loaders/\"> Loader API</a> 中指定的属性和方法，最终<strong>同步</strong>或<strong>异步</strong>地返回处理后的结果</p>\n<p>Loader处理过程：</p>\n<ul>\n<li><p>根据解析的 Loader 文件路径，加载 Loader 模块，兼容 commonJS、ESModule 或 SystemJS 方式</p>\n</li>\n<li><p>按 Loader 链数组控制 Loader 的调用过程，具体调用顺序在 Pitching Loader 小节中进一步说明，简单来说包括三个部分：pitch阶段 =&gt; 处理资源内容阶段 =&gt; Loader 函数调用阶段（同步或异步）</p>\n</li>\n<li><p>持续更新 Loader Context 信息</p>\n</li>\n<li><p>获取执行后的结果并返回 Webpack 编译流程</p>\n</li>\n</ul>\n<h3 id=\"一、自定义简单的Loader\"><a href=\"#一、自定义简单的Loader\" class=\"headerlink\" title=\"一、自定义简单的Loader\"></a>一、自定义简单的Loader</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">loaderDemo</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 可以查看 this 提供的上下文信息和可以使用的API</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 该函数需要返回处理后的结果，直接返回输入source，相当于未对资源做任何处理</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = loaderDemo;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：loader必须返回js字符串</strong></p>\n<h4 id=\"1、获取配置\"><a href=\"#1、获取配置\" class=\"headerlink\" title=\"1、获取配置\"></a>1、获取配置</h4><p>在 <code>module.rule</code> 配置中可以给 Loader 提供用户配置，使用 <code>loader-utils</code> 提供的 <code>getOptions</code> API 获取，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> loaderUtils = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;loader-utils&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取到用户给当前 Loader 传入的配置</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = loaderUtils.<span class=\"title function_\">getOptions</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、二进制格式数据\"><a href=\"#2、二进制格式数据\" class=\"headerlink\" title=\"2、二进制格式数据\"></a>2、二进制格式数据</h4><p>默认情况下 Loader 函数中获取到的源码是 UTF-8 编码的字符串，在某些场景下需要获取到二进制格式的数据，比如 <code>file-loader</code> ，这时需要配置 <code>raw</code> 标记为 true</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  content <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Buffer</span> === <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 通过 exports.raw = true 表示该 Loader 需要二进制格式数据</span></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>.<span class=\"property\">raw</span> = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、返回其他结果\"><a href=\"#3、返回其他结果\" class=\"headerlink\" title=\"3、返回其他结果\"></a>3、返回其他结果</h4><p>Loader 通过 <code>return</code> 语句返回翻译后的内容，内容可以是 String 或 Buffer 格式，但如果需要返回其他额外信息， <code>return</code> 就不够用了，需要使用 <code>this.callback</code> 这个 API ，它有四个主要参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">callback</span>(</span><br><span class=\"line\">  <span class=\"attr\">err</span>: <span class=\"title class_\">Error</span> | <span class=\"literal\">null</span>, <span class=\"comment\">// Loader处理过程中出错时，需要抛出一个Error，无错误时需要指定为 null</span></span><br><span class=\"line\">  <span class=\"attr\">content</span>: string | <span class=\"title class_\">Buffer</span>, <span class=\"comment\">// 转换后的内容，可以是 String 或 Buffer 格式</span></span><br><span class=\"line\">  sourceMap?: <span class=\"title class_\">SourceMap</span>, <span class=\"comment\">// 可选：可被 Webpack 解析的 SourceMap</span></span><br><span class=\"line\">  meta?: any, <span class=\"comment\">// 可选：用户自定义的其他数据，会被 Webpack 忽略</span></span><br><span class=\"line\">  ... <span class=\"comment\">// 可选：任意个数其他参数</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>this.callback</code> ，则函数的 return 必须返回 <code>undefined</code> ，Webpack 根据 return 内容来确认从哪里获取 Loader 翻译的结果</p>\n<h4 id=\"4、异步-Loader\"><a href=\"#4、异步-Loader\" class=\"headerlink\" title=\"4、异步 Loader\"></a>4、异步 Loader</h4><p>Loader 函数除了同步返回（ return 或 this.callback ）解析结果，还可以异步执行再返回结果，比如有些场景下需要异步请求网络或长时间的计算操作，此时同步返回会阻塞整个构建流程，建议借助 this.async API等待异步操作执行完成后再返回转化结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(content) &#123;</span><br><span class=\"line\">  // 通过 this.async API 获取异步返回的回调函数</span><br><span class=\"line\">  const callback = this.async();</span><br><span class=\"line\">  // 使用定时器模拟异步操作</span><br><span class=\"line\">  setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    // 通过 callback 返回异步执行后的结果</span><br><span class=\"line\">    callback(err, content, sourceMap, meta);</span><br><span class=\"line\">  &#125;, 2000);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、Pitching-Loader\"><a href=\"#5、Pitching-Loader\" class=\"headerlink\" title=\"5、Pitching Loader\"></a>5、Pitching Loader</h4><p>大家都知道Loader的执行顺序是从右到左执行的，其实不然，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">... ... </span><br><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"attr\">use</span>: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;a-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;b-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;c-loader&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">... ...</span><br></pre></td></tr></table></figure>\n\n<p>实际的调用执行顺序如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- a-loader `pitch` 调用</span><br><span class=\"line\">  |- b-loader `pitch` 调用</span><br><span class=\"line\">    |- c-loader `pitch` 调用</span><br><span class=\"line\">      |- 请求模块资源文件被读取，并添加到依赖中</span><br><span class=\"line\">    |- c-loader 调用</span><br><span class=\"line\">  |- b-loader 调用</span><br><span class=\"line\">|- a-loader 调用</span><br></pre></td></tr></table></figure>\n\n<p> pitch 函数中的入参包括：</p>\n<p>●remainingRequest </p>\n<p>●precedingRequest</p>\n<p>●data</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports.pitch = function(remainingRequest, precedingRequest, data) &#123;</span><br><span class=\"line\">  // ... ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果在 <code>pitch</code> 函数中返回值，会跳过余下所有 Loader 的 <code>pitch</code> 函数的调用和 Loader 正常调用流程，仅执行已经历 <code>pitch</code> 函数调用流程的 Loader 的正常调用流程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Webpack-Loader详解\"><a href=\"#Webpack-Loader详解\" class=\"headerlink\" title=\"Webpack Loader详解\"></a>Webpack Loader详解</h2><p>Loader 的本质是导出一个<strong>函数</strong>的 Node 模块，它所导出的函数将在读取到目标类型（通常在 <code>module.rules</code> 中配置）源文件时调用，源文件字符串将作为参数传入这个函数，并且函数中可以通过 this 关键字访问到上下文信息和使用<a href=\"https://webpack.js.org/api/loaders/\"> Loader API</a> 中指定的属性和方法，最终<strong>同步</strong>或<strong>异步</strong>地返回处理后的结果</p>\n<p>Loader处理过程：</p>\n<ul>\n<li><p>根据解析的 Loader 文件路径，加载 Loader 模块，兼容 commonJS、ESModule 或 SystemJS 方式</p>\n</li>\n<li><p>按 Loader 链数组控制 Loader 的调用过程，具体调用顺序在 Pitching Loader 小节中进一步说明，简单来说包括三个部分：pitch阶段 =&gt; 处理资源内容阶段 =&gt; Loader 函数调用阶段（同步或异步）</p>\n</li>\n<li><p>持续更新 Loader Context 信息</p>\n</li>\n<li><p>获取执行后的结果并返回 Webpack 编译流程</p>\n</li>\n</ul>\n<h3 id=\"一、自定义简单的Loader\"><a href=\"#一、自定义简单的Loader\" class=\"headerlink\" title=\"一、自定义简单的Loader\"></a>一、自定义简单的Loader</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">loaderDemo</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 可以查看 this 提供的上下文信息和可以使用的API</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 该函数需要返回处理后的结果，直接返回输入source，相当于未对资源做任何处理</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = loaderDemo;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：loader必须返回js字符串</strong></p>\n<h4 id=\"1、获取配置\"><a href=\"#1、获取配置\" class=\"headerlink\" title=\"1、获取配置\"></a>1、获取配置</h4><p>在 <code>module.rule</code> 配置中可以给 Loader 提供用户配置，使用 <code>loader-utils</code> 提供的 <code>getOptions</code> API 获取，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> loaderUtils = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;loader-utils&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取到用户给当前 Loader 传入的配置</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = loaderUtils.<span class=\"title function_\">getOptions</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、二进制格式数据\"><a href=\"#2、二进制格式数据\" class=\"headerlink\" title=\"2、二进制格式数据\"></a>2、二进制格式数据</h4><p>默认情况下 Loader 函数中获取到的源码是 UTF-8 编码的字符串，在某些场景下需要获取到二进制格式的数据，比如 <code>file-loader</code> ，这时需要配置 <code>raw</code> 标记为 true</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span>(<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  content <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Buffer</span> === <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 通过 exports.raw = true 表示该 Loader 需要二进制格式数据</span></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>.<span class=\"property\">raw</span> = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、返回其他结果\"><a href=\"#3、返回其他结果\" class=\"headerlink\" title=\"3、返回其他结果\"></a>3、返回其他结果</h4><p>Loader 通过 <code>return</code> 语句返回翻译后的内容，内容可以是 String 或 Buffer 格式，但如果需要返回其他额外信息， <code>return</code> 就不够用了，需要使用 <code>this.callback</code> 这个 API ，它有四个主要参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">callback</span>(</span><br><span class=\"line\">  <span class=\"attr\">err</span>: <span class=\"title class_\">Error</span> | <span class=\"literal\">null</span>, <span class=\"comment\">// Loader处理过程中出错时，需要抛出一个Error，无错误时需要指定为 null</span></span><br><span class=\"line\">  <span class=\"attr\">content</span>: string | <span class=\"title class_\">Buffer</span>, <span class=\"comment\">// 转换后的内容，可以是 String 或 Buffer 格式</span></span><br><span class=\"line\">  sourceMap?: <span class=\"title class_\">SourceMap</span>, <span class=\"comment\">// 可选：可被 Webpack 解析的 SourceMap</span></span><br><span class=\"line\">  meta?: any, <span class=\"comment\">// 可选：用户自定义的其他数据，会被 Webpack 忽略</span></span><br><span class=\"line\">  ... <span class=\"comment\">// 可选：任意个数其他参数</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>this.callback</code> ，则函数的 return 必须返回 <code>undefined</code> ，Webpack 根据 return 内容来确认从哪里获取 Loader 翻译的结果</p>\n<h4 id=\"4、异步-Loader\"><a href=\"#4、异步-Loader\" class=\"headerlink\" title=\"4、异步 Loader\"></a>4、异步 Loader</h4><p>Loader 函数除了同步返回（ return 或 this.callback ）解析结果，还可以异步执行再返回结果，比如有些场景下需要异步请求网络或长时间的计算操作，此时同步返回会阻塞整个构建流程，建议借助 this.async API等待异步操作执行完成后再返回转化结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(content) &#123;</span><br><span class=\"line\">  // 通过 this.async API 获取异步返回的回调函数</span><br><span class=\"line\">  const callback = this.async();</span><br><span class=\"line\">  // 使用定时器模拟异步操作</span><br><span class=\"line\">  setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    // 通过 callback 返回异步执行后的结果</span><br><span class=\"line\">    callback(err, content, sourceMap, meta);</span><br><span class=\"line\">  &#125;, 2000);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、Pitching-Loader\"><a href=\"#5、Pitching-Loader\" class=\"headerlink\" title=\"5、Pitching Loader\"></a>5、Pitching Loader</h4><p>大家都知道Loader的执行顺序是从右到左执行的，其实不然，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">... ... </span><br><span class=\"line\"><span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"attr\">use</span>: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;a-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;b-loader&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;c-loader&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">... ...</span><br></pre></td></tr></table></figure>\n\n<p>实际的调用执行顺序如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- a-loader `pitch` 调用</span><br><span class=\"line\">  |- b-loader `pitch` 调用</span><br><span class=\"line\">    |- c-loader `pitch` 调用</span><br><span class=\"line\">      |- 请求模块资源文件被读取，并添加到依赖中</span><br><span class=\"line\">    |- c-loader 调用</span><br><span class=\"line\">  |- b-loader 调用</span><br><span class=\"line\">|- a-loader 调用</span><br></pre></td></tr></table></figure>\n\n<p> pitch 函数中的入参包括：</p>\n<p>●remainingRequest </p>\n<p>●precedingRequest</p>\n<p>●data</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports.pitch = function(remainingRequest, precedingRequest, data) &#123;</span><br><span class=\"line\">  // ... ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果在 <code>pitch</code> 函数中返回值，会跳过余下所有 Loader 的 <code>pitch</code> 函数的调用和 Loader 正常调用流程，仅执行已经历 <code>pitch</code> 函数调用流程的 Loader 的正常调用流程。</p>\n"},{"title":"Webpack Plugin详解","date":"2021-11-11T06:44:55.000Z","description":"学习总结","cover":"https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg","_content":"\n## Webpack Plugin详解\n\nPlugIn (插件) 系统是 Webpack 世界中最重要又最难以理解的概念，理解 Plugin 原理将有助于更灵活地使用 Webpack\n\n### 一、基本概念\n\n#### 1、Tapable\n\nWebpack的打包过程就是一个黑盒，你只需要写好配置，就能从入口文件开始将所有的依赖打包在一起，最后给你一个结果。\n\n而我们对打包的过程是不清楚的，Webpack提供了插件机制，让我们可以在打包的过程中，做一些自己的操作，而这个机制的原理就是订阅发布模式。Webpack向外透露出不同阶段的钩子，然后让我们可以传入要做的操作，Webpack在打包的过程中就会去执行。\n\nTapable就是提供这个钩子的一个内部库，提供了基于发布订阅模式（观察者模式或事件流）的架构。\n\n#### 2、Compiler\n\nCompiler 是 Webpack 的编译器对象，它主要负责主流程运作，在 Webpack 启动时通过 `new` 实例化，接收所有配置文件中的配置项（entry，output，module，plugin等），并实例化 Compilation 对象开启编译流程，它的生命周期就是 Webpack 整个运行时期。\n\nCompiler是**全局唯一**的。\n\n#### 3、Compilation\n\nCompilation 负责每一次版本的编译构建和资源生成流程中的细节，在 Compiler 对象的生命周期内（即 Webpack 运行时）可能有多次编译流程，比如常用的开发环境下，文件内容变更会引起重新编译。\n\n**Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等**。当 `Webpack` 以开发模式运行时，每当检测到一个文件变化，一次新的 `Compilation` 将被创建。\n\n\n\n**Compiler和Compilation都继承于Tapable，也就是说它们都有自己的钩子**\n\n#### 基本使用\n\n```js\n<instance>.hooks.<hook name>.<tap API>('<plugin name>', callback )\n```\n\n- `instance` 即为 `compiler` 或 `compilation` 对象的实例引用\n- `hook name` 是需要挂载钩子的名称，通过查阅 官网文档 获取所有对外暴露的事件钩子名称、触发时机、类型、注入参数\n\n- `tap API` 有三种：\n\n- - `tap` 用于挂载一个同步回调，适合任何事件钩子类型\n- `tapAsync` 用于挂载一个异步回调，不能对同步类型钩子使用，回调中会注入 `callback` 供插件处理完操作后调用，如果不调用 `callback` 流程将无法继续进行\n\n- - `tapPromise` 和 `tapAsync` 的作用和限制类似，不同在于要求返回一个 `Promise` 实例，并且这个 `Promise` 一定会被决议（无论 resolve 或 reject ）\n\n### 二、自定义Plugin\n\n#### fileList.md案例\n\n在每次`webpack`打包之后，自动产生一个打包文件清单，实际上就是一个`markdown`文件，上面记录了打包之后的文件夹`dist`里所有的文件的一些信息。\n\n```js\nclass No2Plugin {\n    constructor(options){\n        this.options = options;\n        this.fileName = options.fileName;\n    }\n    apply(compiler){\n        compiler.hooks.emit.tapAsync('No2',(compilation,callback)=>{\n            //获取文件数量\n            const len = Object.keys(compilation.assets).length;\n            let content = `# 一共有${len}个文件\\n\\n`;\n            //遍历文件列表获取文件名称\n            for (let filename in compilation.assets){\n                content += `- ${filename}\\n`;\n            }\n            //保存md文件\n            compilation.assets[this.fileName] = {\n                source:function (){\n                    return content;\n                },\n                size:function () {\n                    return content.length;\n                }\n            }\n            callback();\n        })\n    }\n}\n\nmodule.exports = No2Plugin;\n```\n\n\n\n![1.png](https://i.loli.net/2021/11/11/SNYU1GjCaqJxZQ9.png)\n\n","source":"_posts/WebpackPlugin.md","raw":"---\ntitle: Webpack Plugin详解\ndate: 2021-11-11 14:44:55\ncategories:  webpack\ntags: [webpack]\ndescription: 学习总结\ncover: https://i.loli.net/2021/09/15/2lhb6RSkeMdw8ar.jpg\n---\n\n## Webpack Plugin详解\n\nPlugIn (插件) 系统是 Webpack 世界中最重要又最难以理解的概念，理解 Plugin 原理将有助于更灵活地使用 Webpack\n\n### 一、基本概念\n\n#### 1、Tapable\n\nWebpack的打包过程就是一个黑盒，你只需要写好配置，就能从入口文件开始将所有的依赖打包在一起，最后给你一个结果。\n\n而我们对打包的过程是不清楚的，Webpack提供了插件机制，让我们可以在打包的过程中，做一些自己的操作，而这个机制的原理就是订阅发布模式。Webpack向外透露出不同阶段的钩子，然后让我们可以传入要做的操作，Webpack在打包的过程中就会去执行。\n\nTapable就是提供这个钩子的一个内部库，提供了基于发布订阅模式（观察者模式或事件流）的架构。\n\n#### 2、Compiler\n\nCompiler 是 Webpack 的编译器对象，它主要负责主流程运作，在 Webpack 启动时通过 `new` 实例化，接收所有配置文件中的配置项（entry，output，module，plugin等），并实例化 Compilation 对象开启编译流程，它的生命周期就是 Webpack 整个运行时期。\n\nCompiler是**全局唯一**的。\n\n#### 3、Compilation\n\nCompilation 负责每一次版本的编译构建和资源生成流程中的细节，在 Compiler 对象的生命周期内（即 Webpack 运行时）可能有多次编译流程，比如常用的开发环境下，文件内容变更会引起重新编译。\n\n**Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等**。当 `Webpack` 以开发模式运行时，每当检测到一个文件变化，一次新的 `Compilation` 将被创建。\n\n\n\n**Compiler和Compilation都继承于Tapable，也就是说它们都有自己的钩子**\n\n#### 基本使用\n\n```js\n<instance>.hooks.<hook name>.<tap API>('<plugin name>', callback )\n```\n\n- `instance` 即为 `compiler` 或 `compilation` 对象的实例引用\n- `hook name` 是需要挂载钩子的名称，通过查阅 官网文档 获取所有对外暴露的事件钩子名称、触发时机、类型、注入参数\n\n- `tap API` 有三种：\n\n- - `tap` 用于挂载一个同步回调，适合任何事件钩子类型\n- `tapAsync` 用于挂载一个异步回调，不能对同步类型钩子使用，回调中会注入 `callback` 供插件处理完操作后调用，如果不调用 `callback` 流程将无法继续进行\n\n- - `tapPromise` 和 `tapAsync` 的作用和限制类似，不同在于要求返回一个 `Promise` 实例，并且这个 `Promise` 一定会被决议（无论 resolve 或 reject ）\n\n### 二、自定义Plugin\n\n#### fileList.md案例\n\n在每次`webpack`打包之后，自动产生一个打包文件清单，实际上就是一个`markdown`文件，上面记录了打包之后的文件夹`dist`里所有的文件的一些信息。\n\n```js\nclass No2Plugin {\n    constructor(options){\n        this.options = options;\n        this.fileName = options.fileName;\n    }\n    apply(compiler){\n        compiler.hooks.emit.tapAsync('No2',(compilation,callback)=>{\n            //获取文件数量\n            const len = Object.keys(compilation.assets).length;\n            let content = `# 一共有${len}个文件\\n\\n`;\n            //遍历文件列表获取文件名称\n            for (let filename in compilation.assets){\n                content += `- ${filename}\\n`;\n            }\n            //保存md文件\n            compilation.assets[this.fileName] = {\n                source:function (){\n                    return content;\n                },\n                size:function () {\n                    return content.length;\n                }\n            }\n            callback();\n        })\n    }\n}\n\nmodule.exports = No2Plugin;\n```\n\n\n\n![1.png](https://i.loli.net/2021/11/11/SNYU1GjCaqJxZQ9.png)\n\n","slug":"WebpackPlugin","published":1,"updated":"2021-11-11T06:46:32.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1mf0037dswk26qpav4w","content":"<h2 id=\"Webpack-Plugin详解\"><a href=\"#Webpack-Plugin详解\" class=\"headerlink\" title=\"Webpack Plugin详解\"></a>Webpack Plugin详解</h2><p>PlugIn (插件) 系统是 Webpack 世界中最重要又最难以理解的概念，理解 Plugin 原理将有助于更灵活地使用 Webpack</p>\n<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><h4 id=\"1、Tapable\"><a href=\"#1、Tapable\" class=\"headerlink\" title=\"1、Tapable\"></a>1、Tapable</h4><p>Webpack的打包过程就是一个黑盒，你只需要写好配置，就能从入口文件开始将所有的依赖打包在一起，最后给你一个结果。</p>\n<p>而我们对打包的过程是不清楚的，Webpack提供了插件机制，让我们可以在打包的过程中，做一些自己的操作，而这个机制的原理就是订阅发布模式。Webpack向外透露出不同阶段的钩子，然后让我们可以传入要做的操作，Webpack在打包的过程中就会去执行。</p>\n<p>Tapable就是提供这个钩子的一个内部库，提供了基于发布订阅模式（观察者模式或事件流）的架构。</p>\n<h4 id=\"2、Compiler\"><a href=\"#2、Compiler\" class=\"headerlink\" title=\"2、Compiler\"></a>2、Compiler</h4><p>Compiler 是 Webpack 的编译器对象，它主要负责主流程运作，在 Webpack 启动时通过 <code>new</code> 实例化，接收所有配置文件中的配置项（entry，output，module，plugin等），并实例化 Compilation 对象开启编译流程，它的生命周期就是 Webpack 整个运行时期。</p>\n<p>Compiler是<strong>全局唯一</strong>的。</p>\n<h4 id=\"3、Compilation\"><a href=\"#3、Compilation\" class=\"headerlink\" title=\"3、Compilation\"></a>3、Compilation</h4><p>Compilation 负责每一次版本的编译构建和资源生成流程中的细节，在 Compiler 对象的生命周期内（即 Webpack 运行时）可能有多次编译流程，比如常用的开发环境下，文件内容变更会引起重新编译。</p>\n<p><strong>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等</strong>。当 <code>Webpack</code> 以开发模式运行时，每当检测到一个文件变化，一次新的 <code>Compilation</code> 将被创建。</p>\n<p><strong>Compiler和Compilation都继承于Tapable，也就是说它们都有自己的钩子</strong></p>\n<h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;instance&gt;.<span class=\"property\">hooks</span>.&lt;hook name&gt;.&lt;tap <span class=\"variable constant_\">API</span>&gt;(<span class=\"string\">&#x27;&lt;plugin name&gt;&#x27;</span>, callback )</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>instance</code> 即为 <code>compiler</code> 或 <code>compilation</code> 对象的实例引用</p>\n</li>\n<li><p><code>hook name</code> 是需要挂载钩子的名称，通过查阅 官网文档 获取所有对外暴露的事件钩子名称、触发时机、类型、注入参数</p>\n</li>\n<li><p><code>tap API</code> 有三种：</p>\n</li>\n<li><ul>\n<li><code>tap</code> 用于挂载一个同步回调，适合任何事件钩子类型</li>\n</ul>\n</li>\n<li><p><code>tapAsync</code> 用于挂载一个异步回调，不能对同步类型钩子使用，回调中会注入 <code>callback</code> 供插件处理完操作后调用，如果不调用 <code>callback</code> 流程将无法继续进行</p>\n</li>\n<li><ul>\n<li><code>tapPromise</code> 和 <code>tapAsync</code> 的作用和限制类似，不同在于要求返回一个 <code>Promise</code> 实例，并且这个 <code>Promise</code> 一定会被决议（无论 resolve 或 reject ）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、自定义Plugin\"><a href=\"#二、自定义Plugin\" class=\"headerlink\" title=\"二、自定义Plugin\"></a>二、自定义Plugin</h3><h4 id=\"fileList-md案例\"><a href=\"#fileList-md案例\" class=\"headerlink\" title=\"fileList.md案例\"></a>fileList.md案例</h4><p>在每次<code>webpack</code>打包之后，自动产生一个打包文件清单，实际上就是一个<code>markdown</code>文件，上面记录了打包之后的文件夹<code>dist</code>里所有的文件的一些信息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">No2Plugin</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">options</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">options</span> = options;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">fileName</span> = options.<span class=\"property\">fileName</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">apply</span>(<span class=\"params\">compiler</span>)&#123;</span><br><span class=\"line\">        compiler.<span class=\"property\">hooks</span>.<span class=\"property\">emit</span>.<span class=\"title function_\">tapAsync</span>(<span class=\"string\">&#x27;No2&#x27;</span>,<span class=\"function\">(<span class=\"params\">compilation,callback</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取文件数量</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> len = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(compilation.<span class=\"property\">assets</span>).<span class=\"property\">length</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = <span class=\"string\">`# 一共有<span class=\"subst\">$&#123;len&#125;</span>个文件\\n\\n`</span>;</span><br><span class=\"line\">            <span class=\"comment\">//遍历文件列表获取文件名称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> filename <span class=\"keyword\">in</span> compilation.<span class=\"property\">assets</span>)&#123;</span><br><span class=\"line\">                content += <span class=\"string\">`- <span class=\"subst\">$&#123;filename&#125;</span>\\n`</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//保存md文件</span></span><br><span class=\"line\">            compilation.<span class=\"property\">assets</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">fileName</span>] = &#123;</span><br><span class=\"line\">                <span class=\"attr\">source</span>:<span class=\"keyword\">function</span> (<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"attr\">size</span>:<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> content.<span class=\"property\">length</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"title function_\">callback</span>();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title class_\">No2Plugin</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2021/11/11/SNYU1GjCaqJxZQ9.png\" alt=\"1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Webpack-Plugin详解\"><a href=\"#Webpack-Plugin详解\" class=\"headerlink\" title=\"Webpack Plugin详解\"></a>Webpack Plugin详解</h2><p>PlugIn (插件) 系统是 Webpack 世界中最重要又最难以理解的概念，理解 Plugin 原理将有助于更灵活地使用 Webpack</p>\n<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><h4 id=\"1、Tapable\"><a href=\"#1、Tapable\" class=\"headerlink\" title=\"1、Tapable\"></a>1、Tapable</h4><p>Webpack的打包过程就是一个黑盒，你只需要写好配置，就能从入口文件开始将所有的依赖打包在一起，最后给你一个结果。</p>\n<p>而我们对打包的过程是不清楚的，Webpack提供了插件机制，让我们可以在打包的过程中，做一些自己的操作，而这个机制的原理就是订阅发布模式。Webpack向外透露出不同阶段的钩子，然后让我们可以传入要做的操作，Webpack在打包的过程中就会去执行。</p>\n<p>Tapable就是提供这个钩子的一个内部库，提供了基于发布订阅模式（观察者模式或事件流）的架构。</p>\n<h4 id=\"2、Compiler\"><a href=\"#2、Compiler\" class=\"headerlink\" title=\"2、Compiler\"></a>2、Compiler</h4><p>Compiler 是 Webpack 的编译器对象，它主要负责主流程运作，在 Webpack 启动时通过 <code>new</code> 实例化，接收所有配置文件中的配置项（entry，output，module，plugin等），并实例化 Compilation 对象开启编译流程，它的生命周期就是 Webpack 整个运行时期。</p>\n<p>Compiler是<strong>全局唯一</strong>的。</p>\n<h4 id=\"3、Compilation\"><a href=\"#3、Compilation\" class=\"headerlink\" title=\"3、Compilation\"></a>3、Compilation</h4><p>Compilation 负责每一次版本的编译构建和资源生成流程中的细节，在 Compiler 对象的生命周期内（即 Webpack 运行时）可能有多次编译流程，比如常用的开发环境下，文件内容变更会引起重新编译。</p>\n<p><strong>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等</strong>。当 <code>Webpack</code> 以开发模式运行时，每当检测到一个文件变化，一次新的 <code>Compilation</code> 将被创建。</p>\n<p><strong>Compiler和Compilation都继承于Tapable，也就是说它们都有自己的钩子</strong></p>\n<h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;instance&gt;.<span class=\"property\">hooks</span>.&lt;hook name&gt;.&lt;tap <span class=\"variable constant_\">API</span>&gt;(<span class=\"string\">&#x27;&lt;plugin name&gt;&#x27;</span>, callback )</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>instance</code> 即为 <code>compiler</code> 或 <code>compilation</code> 对象的实例引用</p>\n</li>\n<li><p><code>hook name</code> 是需要挂载钩子的名称，通过查阅 官网文档 获取所有对外暴露的事件钩子名称、触发时机、类型、注入参数</p>\n</li>\n<li><p><code>tap API</code> 有三种：</p>\n</li>\n<li><ul>\n<li><code>tap</code> 用于挂载一个同步回调，适合任何事件钩子类型</li>\n</ul>\n</li>\n<li><p><code>tapAsync</code> 用于挂载一个异步回调，不能对同步类型钩子使用，回调中会注入 <code>callback</code> 供插件处理完操作后调用，如果不调用 <code>callback</code> 流程将无法继续进行</p>\n</li>\n<li><ul>\n<li><code>tapPromise</code> 和 <code>tapAsync</code> 的作用和限制类似，不同在于要求返回一个 <code>Promise</code> 实例，并且这个 <code>Promise</code> 一定会被决议（无论 resolve 或 reject ）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、自定义Plugin\"><a href=\"#二、自定义Plugin\" class=\"headerlink\" title=\"二、自定义Plugin\"></a>二、自定义Plugin</h3><h4 id=\"fileList-md案例\"><a href=\"#fileList-md案例\" class=\"headerlink\" title=\"fileList.md案例\"></a>fileList.md案例</h4><p>在每次<code>webpack</code>打包之后，自动产生一个打包文件清单，实际上就是一个<code>markdown</code>文件，上面记录了打包之后的文件夹<code>dist</code>里所有的文件的一些信息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">No2Plugin</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">options</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">options</span> = options;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">fileName</span> = options.<span class=\"property\">fileName</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">apply</span>(<span class=\"params\">compiler</span>)&#123;</span><br><span class=\"line\">        compiler.<span class=\"property\">hooks</span>.<span class=\"property\">emit</span>.<span class=\"title function_\">tapAsync</span>(<span class=\"string\">&#x27;No2&#x27;</span>,<span class=\"function\">(<span class=\"params\">compilation,callback</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取文件数量</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> len = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(compilation.<span class=\"property\">assets</span>).<span class=\"property\">length</span>;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = <span class=\"string\">`# 一共有<span class=\"subst\">$&#123;len&#125;</span>个文件\\n\\n`</span>;</span><br><span class=\"line\">            <span class=\"comment\">//遍历文件列表获取文件名称</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> filename <span class=\"keyword\">in</span> compilation.<span class=\"property\">assets</span>)&#123;</span><br><span class=\"line\">                content += <span class=\"string\">`- <span class=\"subst\">$&#123;filename&#125;</span>\\n`</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//保存md文件</span></span><br><span class=\"line\">            compilation.<span class=\"property\">assets</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">fileName</span>] = &#123;</span><br><span class=\"line\">                <span class=\"attr\">source</span>:<span class=\"keyword\">function</span> (<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"attr\">size</span>:<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> content.<span class=\"property\">length</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"title function_\">callback</span>();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title class_\">No2Plugin</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://i.loli.net/2021/11/11/SNYU1GjCaqJxZQ9.png\" alt=\"1.png\"></p>\n"},{"title":"工作总结-项目优化","date":"2022-03-31T08:41:20.000Z","description":"工作总结","cover":"https://s2.loli.net/2022/03/31/oTNACnmX6yefaLE.jpg","_content":"\n# 项目优化\n\n公司的项目是一个vue的多页面应用，还比较大，在使用的过程中每次打开新的一个页面的时候，白屏时间就会很长\n\n通过调试发现，每个页面打开都会去加载`chunk-vendors.js`和`chunk-common.js`\n\n* `chunk-vendors.js`是*node-modules*下面的库集合\n* `chunk-common.js`是通用chunk\n\n因为项目比较大，*node-modules*下面的库比较多，`chunk-vendors.js`就会很大，所以再进入新页面的时候加载时间就会很长\n\n而一些页面并没有依赖所有的库，导致加载了一些这个页面不需要的库\n\n### 解决方案：删除默认 splitChunk 配置，抽离公共资源\n\n删除默认的 splitChunk 配置，多入口会单独各自打包，但是公共资源不会抽取。\n\n每个页面会单独各自打包，只需要将自己入口用到的依赖打包，而不需要加载等个`chunk-vendors.js`，加载速度就得到了提升\n\n然后再将多页面的公共引用的再抽取出来\n\n```js\nmodule.export= {\n    //...其他\n    chainWebpack: config => {\n        // 删除默认的splitChunk\n        config.optimization.delete(\"splitChunks\");\n    },\n    configureWebpack: config => {\n        config.optimization = {\n            splitChunks: {\n                cacheGroups: {\n                    common: {\n                        //抽取所有入口页面都需要的公共chunk\n                        name: \"chunk-common\",\n                        chunks: \"initial\",\n                        minChunks: 2,\n                        maxInitialRequests: 5,\n                        minSize: 0,\n                        priority: 1,\n                        reuseExistingChunk: true,\n                        enforce: true\n                    }\n                }\n            }\n        };\n    }\n}\n```\n\n","source":"_posts/Work-optimize.md","raw":"---\ntitle: 工作总结-项目优化\ndate: 2022-03-31 16:41:20\ncategories: 项目优化\ntags: [WORK]\ndescription: 工作总结\ncover: https://s2.loli.net/2022/03/31/oTNACnmX6yefaLE.jpg\n---\n\n# 项目优化\n\n公司的项目是一个vue的多页面应用，还比较大，在使用的过程中每次打开新的一个页面的时候，白屏时间就会很长\n\n通过调试发现，每个页面打开都会去加载`chunk-vendors.js`和`chunk-common.js`\n\n* `chunk-vendors.js`是*node-modules*下面的库集合\n* `chunk-common.js`是通用chunk\n\n因为项目比较大，*node-modules*下面的库比较多，`chunk-vendors.js`就会很大，所以再进入新页面的时候加载时间就会很长\n\n而一些页面并没有依赖所有的库，导致加载了一些这个页面不需要的库\n\n### 解决方案：删除默认 splitChunk 配置，抽离公共资源\n\n删除默认的 splitChunk 配置，多入口会单独各自打包，但是公共资源不会抽取。\n\n每个页面会单独各自打包，只需要将自己入口用到的依赖打包，而不需要加载等个`chunk-vendors.js`，加载速度就得到了提升\n\n然后再将多页面的公共引用的再抽取出来\n\n```js\nmodule.export= {\n    //...其他\n    chainWebpack: config => {\n        // 删除默认的splitChunk\n        config.optimization.delete(\"splitChunks\");\n    },\n    configureWebpack: config => {\n        config.optimization = {\n            splitChunks: {\n                cacheGroups: {\n                    common: {\n                        //抽取所有入口页面都需要的公共chunk\n                        name: \"chunk-common\",\n                        chunks: \"initial\",\n                        minChunks: 2,\n                        maxInitialRequests: 5,\n                        minSize: 0,\n                        priority: 1,\n                        reuseExistingChunk: true,\n                        enforce: true\n                    }\n                }\n            }\n        };\n    }\n}\n```\n\n","slug":"Work-optimize","published":1,"updated":"2022-03-31T09:12:57.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1mg003cdswkfapie6u5","content":"<h1 id=\"项目优化\"><a href=\"#项目优化\" class=\"headerlink\" title=\"项目优化\"></a>项目优化</h1><p>公司的项目是一个vue的多页面应用，还比较大，在使用的过程中每次打开新的一个页面的时候，白屏时间就会很长</p>\n<p>通过调试发现，每个页面打开都会去加载<code>chunk-vendors.js</code>和<code>chunk-common.js</code></p>\n<ul>\n<li><code>chunk-vendors.js</code>是<em>node-modules</em>下面的库集合</li>\n<li><code>chunk-common.js</code>是通用chunk</li>\n</ul>\n<p>因为项目比较大，<em>node-modules</em>下面的库比较多，<code>chunk-vendors.js</code>就会很大，所以再进入新页面的时候加载时间就会很长</p>\n<p>而一些页面并没有依赖所有的库，导致加载了一些这个页面不需要的库</p>\n<h3 id=\"解决方案：删除默认-splitChunk-配置，抽离公共资源\"><a href=\"#解决方案：删除默认-splitChunk-配置，抽离公共资源\" class=\"headerlink\" title=\"解决方案：删除默认 splitChunk 配置，抽离公共资源\"></a>解决方案：删除默认 splitChunk 配置，抽离公共资源</h3><p>删除默认的 splitChunk 配置，多入口会单独各自打包，但是公共资源不会抽取。</p>\n<p>每个页面会单独各自打包，只需要将自己入口用到的依赖打包，而不需要加载等个<code>chunk-vendors.js</code>，加载速度就得到了提升</p>\n<p>然后再将多页面的公共引用的再抽取出来</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">export</span>= &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...其他</span></span><br><span class=\"line\">    <span class=\"attr\">chainWebpack</span>: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除默认的splitChunk</span></span><br><span class=\"line\">        config.<span class=\"property\">optimization</span>.<span class=\"title function_\">delete</span>(<span class=\"string\">&quot;splitChunks&quot;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">configureWebpack</span>: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">        config.<span class=\"property\">optimization</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">splitChunks</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">cacheGroups</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">common</span>: &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//抽取所有入口页面都需要的公共chunk</span></span><br><span class=\"line\">                        <span class=\"attr\">name</span>: <span class=\"string\">&quot;chunk-common&quot;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">chunks</span>: <span class=\"string\">&quot;initial&quot;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">minChunks</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">                        <span class=\"attr\">maxInitialRequests</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">                        <span class=\"attr\">minSize</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                        <span class=\"attr\">priority</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">                        <span class=\"attr\">reuseExistingChunk</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        <span class=\"attr\">enforce</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"项目优化\"><a href=\"#项目优化\" class=\"headerlink\" title=\"项目优化\"></a>项目优化</h1><p>公司的项目是一个vue的多页面应用，还比较大，在使用的过程中每次打开新的一个页面的时候，白屏时间就会很长</p>\n<p>通过调试发现，每个页面打开都会去加载<code>chunk-vendors.js</code>和<code>chunk-common.js</code></p>\n<ul>\n<li><code>chunk-vendors.js</code>是<em>node-modules</em>下面的库集合</li>\n<li><code>chunk-common.js</code>是通用chunk</li>\n</ul>\n<p>因为项目比较大，<em>node-modules</em>下面的库比较多，<code>chunk-vendors.js</code>就会很大，所以再进入新页面的时候加载时间就会很长</p>\n<p>而一些页面并没有依赖所有的库，导致加载了一些这个页面不需要的库</p>\n<h3 id=\"解决方案：删除默认-splitChunk-配置，抽离公共资源\"><a href=\"#解决方案：删除默认-splitChunk-配置，抽离公共资源\" class=\"headerlink\" title=\"解决方案：删除默认 splitChunk 配置，抽离公共资源\"></a>解决方案：删除默认 splitChunk 配置，抽离公共资源</h3><p>删除默认的 splitChunk 配置，多入口会单独各自打包，但是公共资源不会抽取。</p>\n<p>每个页面会单独各自打包，只需要将自己入口用到的依赖打包，而不需要加载等个<code>chunk-vendors.js</code>，加载速度就得到了提升</p>\n<p>然后再将多页面的公共引用的再抽取出来</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">export</span>= &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...其他</span></span><br><span class=\"line\">    <span class=\"attr\">chainWebpack</span>: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除默认的splitChunk</span></span><br><span class=\"line\">        config.<span class=\"property\">optimization</span>.<span class=\"title function_\">delete</span>(<span class=\"string\">&quot;splitChunks&quot;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">configureWebpack</span>: <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">        config.<span class=\"property\">optimization</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">splitChunks</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">cacheGroups</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">common</span>: &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//抽取所有入口页面都需要的公共chunk</span></span><br><span class=\"line\">                        <span class=\"attr\">name</span>: <span class=\"string\">&quot;chunk-common&quot;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">chunks</span>: <span class=\"string\">&quot;initial&quot;</span>,</span><br><span class=\"line\">                        <span class=\"attr\">minChunks</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">                        <span class=\"attr\">maxInitialRequests</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">                        <span class=\"attr\">minSize</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                        <span class=\"attr\">priority</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">                        <span class=\"attr\">reuseExistingChunk</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        <span class=\"attr\">enforce</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Vue 3 新特性","date":"2021-10-22T05:45:20.000Z","description":"学习总结","cover":"https://i.loli.net/2021/11/08/oMIHzClBQfEOgmu.jpg","_content":"\n## Vue 3 新特性\n\n`Vue3.0`的设计目标可以概括为体积更小、速度更快、加强`TypeScript`支持、加强`API`设计一致性、提高自身可维护性、开放更多底层功能。\n\n### 一、生命周期\n\n在vue3中`setup`替代了`beforeCreate`和`created`，并且其他得生命周期都改变了名字\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eadd1ec0ac94343951ae2453cf41fce~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"img\" style=\"zoom:25%;\" />\n\n### 二、编码方式\n\n1、vue3的采用了函数式的编码方式，将很多的api都实现为了函数，比如：`reactive`、`ref `\n\n`reactive`和`ref`都可以创建响应式数据，不同的是`ref`应用于基本数据类型的数据，`reactive`应用于复杂数据类型的数据\n\n`toRefs`可以实现`reactive`到`ref`的转换\n\n\n\n2、vue3从options api转为compositon api\n\n使用过vue2的都知道，在vue实例中都有，`data`、`methods`、`computed`、`watch`等属性，在对应的地方写上代码就可以使用，这样方式的有点就是简单，上手快，但是也带来了很多缺点，①、代码可读性差，明明一块逻辑代码，但是要写在不同的地方。②、代码复用能力差，在vue2中代码的复用都是采用`mixin`的方式，但是`mixin`也有很多的缺点。\n\n而在vue3中，所有的逻辑代码都卸载setup函数中，data、computed、watch都可以通过vue提供的函数来创建，一块逻辑就可以写在一起，如果是公共逻辑，也可以提成单独文件来实现代码的复用\n\n\n\n### 三、源码实现\n\n1、响应式实现\n\n在vue2中的响应式采用的是`Object.defineProperty`api来实现的，缺点就是对于数组监听并不理想，所以在vue2中监听数据采用的是拦截数组中能够修改自身的方法来实现。\n\n而在vue3中，采用了ES6 新增的 Proxy来实现的，更加方便\n\n2、diff优化\n\n在vue3中的虚拟DOM中，对于静态的标签和组件添加了静态标记，在diff的时候，如果发现静态标记，将跳过diff，\n\nVue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法。","source":"_posts/vue3-newChacater.md","raw":"---\ntitle: Vue 3 新特性\ndate: 2021-10-22 13:45:20\ncategories:  vue\ntags: [vue]\ndescription: 学习总结\ncover: https://i.loli.net/2021/11/08/oMIHzClBQfEOgmu.jpg\n---\n\n## Vue 3 新特性\n\n`Vue3.0`的设计目标可以概括为体积更小、速度更快、加强`TypeScript`支持、加强`API`设计一致性、提高自身可维护性、开放更多底层功能。\n\n### 一、生命周期\n\n在vue3中`setup`替代了`beforeCreate`和`created`，并且其他得生命周期都改变了名字\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eadd1ec0ac94343951ae2453cf41fce~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"img\" style=\"zoom:25%;\" />\n\n### 二、编码方式\n\n1、vue3的采用了函数式的编码方式，将很多的api都实现为了函数，比如：`reactive`、`ref `\n\n`reactive`和`ref`都可以创建响应式数据，不同的是`ref`应用于基本数据类型的数据，`reactive`应用于复杂数据类型的数据\n\n`toRefs`可以实现`reactive`到`ref`的转换\n\n\n\n2、vue3从options api转为compositon api\n\n使用过vue2的都知道，在vue实例中都有，`data`、`methods`、`computed`、`watch`等属性，在对应的地方写上代码就可以使用，这样方式的有点就是简单，上手快，但是也带来了很多缺点，①、代码可读性差，明明一块逻辑代码，但是要写在不同的地方。②、代码复用能力差，在vue2中代码的复用都是采用`mixin`的方式，但是`mixin`也有很多的缺点。\n\n而在vue3中，所有的逻辑代码都卸载setup函数中，data、computed、watch都可以通过vue提供的函数来创建，一块逻辑就可以写在一起，如果是公共逻辑，也可以提成单独文件来实现代码的复用\n\n\n\n### 三、源码实现\n\n1、响应式实现\n\n在vue2中的响应式采用的是`Object.defineProperty`api来实现的，缺点就是对于数组监听并不理想，所以在vue2中监听数据采用的是拦截数组中能够修改自身的方法来实现。\n\n而在vue3中，采用了ES6 新增的 Proxy来实现的，更加方便\n\n2、diff优化\n\n在vue3中的虚拟DOM中，对于静态的标签和组件添加了静态标记，在diff的时候，如果发现静态标记，将跳过diff，\n\nVue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法。","slug":"vue3-newChacater","published":1,"updated":"2021-11-08T03:45:58.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1mh003edswkhypc0fbg","content":"<h2 id=\"Vue-3-新特性\"><a href=\"#Vue-3-新特性\" class=\"headerlink\" title=\"Vue 3 新特性\"></a>Vue 3 新特性</h2><p><code>Vue3.0</code>的设计目标可以概括为体积更小、速度更快、加强<code>TypeScript</code>支持、加强<code>API</code>设计一致性、提高自身可维护性、开放更多底层功能。</p>\n<h3 id=\"一、生命周期\"><a href=\"#一、生命周期\" class=\"headerlink\" title=\"一、生命周期\"></a>一、生命周期</h3><p>在vue3中<code>setup</code>替代了<code>beforeCreate</code>和<code>created</code>，并且其他得生命周期都改变了名字</p>\n<img src= \"/img/loading.gif\" data-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eadd1ec0ac94343951ae2453cf41fce~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"img\" style=\"zoom:25%;\" />\n\n<h3 id=\"二、编码方式\"><a href=\"#二、编码方式\" class=\"headerlink\" title=\"二、编码方式\"></a>二、编码方式</h3><p>1、vue3的采用了函数式的编码方式，将很多的api都实现为了函数，比如：<code>reactive</code>、<code>ref</code></p>\n<p><code>reactive</code>和<code>ref</code>都可以创建响应式数据，不同的是<code>ref</code>应用于基本数据类型的数据，<code>reactive</code>应用于复杂数据类型的数据</p>\n<p><code>toRefs</code>可以实现<code>reactive</code>到<code>ref</code>的转换</p>\n<p>2、vue3从options api转为compositon api</p>\n<p>使用过vue2的都知道，在vue实例中都有，<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>等属性，在对应的地方写上代码就可以使用，这样方式的有点就是简单，上手快，但是也带来了很多缺点，①、代码可读性差，明明一块逻辑代码，但是要写在不同的地方。②、代码复用能力差，在vue2中代码的复用都是采用<code>mixin</code>的方式，但是<code>mixin</code>也有很多的缺点。</p>\n<p>而在vue3中，所有的逻辑代码都卸载setup函数中，data、computed、watch都可以通过vue提供的函数来创建，一块逻辑就可以写在一起，如果是公共逻辑，也可以提成单独文件来实现代码的复用</p>\n<h3 id=\"三、源码实现\"><a href=\"#三、源码实现\" class=\"headerlink\" title=\"三、源码实现\"></a>三、源码实现</h3><p>1、响应式实现</p>\n<p>在vue2中的响应式采用的是<code>Object.defineProperty</code>api来实现的，缺点就是对于数组监听并不理想，所以在vue2中监听数据采用的是拦截数组中能够修改自身的方法来实现。</p>\n<p>而在vue3中，采用了ES6 新增的 Proxy来实现的，更加方便</p>\n<p>2、diff优化</p>\n<p>在vue3中的虚拟DOM中，对于静态的标签和组件添加了静态标记，在diff的时候，如果发现静态标记，将跳过diff，</p>\n<p>Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Vue-3-新特性\"><a href=\"#Vue-3-新特性\" class=\"headerlink\" title=\"Vue 3 新特性\"></a>Vue 3 新特性</h2><p><code>Vue3.0</code>的设计目标可以概括为体积更小、速度更快、加强<code>TypeScript</code>支持、加强<code>API</code>设计一致性、提高自身可维护性、开放更多底层功能。</p>\n<h3 id=\"一、生命周期\"><a href=\"#一、生命周期\" class=\"headerlink\" title=\"一、生命周期\"></a>一、生命周期</h3><p>在vue3中<code>setup</code>替代了<code>beforeCreate</code>和<code>created</code>，并且其他得生命周期都改变了名字</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eadd1ec0ac94343951ae2453cf41fce~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"img\" style=\"zoom:25%;\" />\n\n<h3 id=\"二、编码方式\"><a href=\"#二、编码方式\" class=\"headerlink\" title=\"二、编码方式\"></a>二、编码方式</h3><p>1、vue3的采用了函数式的编码方式，将很多的api都实现为了函数，比如：<code>reactive</code>、<code>ref</code></p>\n<p><code>reactive</code>和<code>ref</code>都可以创建响应式数据，不同的是<code>ref</code>应用于基本数据类型的数据，<code>reactive</code>应用于复杂数据类型的数据</p>\n<p><code>toRefs</code>可以实现<code>reactive</code>到<code>ref</code>的转换</p>\n<p>2、vue3从options api转为compositon api</p>\n<p>使用过vue2的都知道，在vue实例中都有，<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>等属性，在对应的地方写上代码就可以使用，这样方式的有点就是简单，上手快，但是也带来了很多缺点，①、代码可读性差，明明一块逻辑代码，但是要写在不同的地方。②、代码复用能力差，在vue2中代码的复用都是采用<code>mixin</code>的方式，但是<code>mixin</code>也有很多的缺点。</p>\n<p>而在vue3中，所有的逻辑代码都卸载setup函数中，data、computed、watch都可以通过vue提供的函数来创建，一块逻辑就可以写在一起，如果是公共逻辑，也可以提成单独文件来实现代码的复用</p>\n<h3 id=\"三、源码实现\"><a href=\"#三、源码实现\" class=\"headerlink\" title=\"三、源码实现\"></a>三、源码实现</h3><p>1、响应式实现</p>\n<p>在vue2中的响应式采用的是<code>Object.defineProperty</code>api来实现的，缺点就是对于数组监听并不理想，所以在vue2中监听数据采用的是拦截数组中能够修改自身的方法来实现。</p>\n<p>而在vue3中，采用了ES6 新增的 Proxy来实现的，更加方便</p>\n<p>2、diff优化</p>\n<p>在vue3中的虚拟DOM中，对于静态的标签和组件添加了静态标记，在diff的时候，如果发现静态标记，将跳过diff，</p>\n<p>Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法。</p>\n"},{"title":"学习资源","date":"2021-09-30T01:49:20.000Z","description":"学习资源和工具","cover":"https://i.loli.net/2021/09/30/aCVAZEKkIxMQtzU.jpg","top":true,"_content":"### 学习资源\n\n[技术胖](https://jspang.com/) : 免费视频教程\n\n[前端工程师大厂面试宝典](https://www.kancloud.cn/pillys/qianduan/2049475) : 面试题\n\n[免费编程资源大全](https://gitee.com/liyupi/free-programming-resources#/liyupi/free-programming-resources/blob/main/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/README.md)  : 免费资源\n\n[React技术揭秘](https://react.iamkasong.com/) : 源码解读\n\n[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/) : 源码解读\n\n[前端面试真题，会80%直接进大厂](https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblEnSV2PNAajtWE&view=vewJHSwJVd) : 面试题\n\n[全栈修仙之路](http://www.semlinker.com/)\n\n[浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/) : 详解浏览器工作原理\n\n[用JavaScript实现的算法和数据结构](http://www.conardli.top/docs/) : 算法\n\n[代码随想录](https://programmercarl.com/) : 算法\n\n[余杭子曰](https://www.yuque.com/robinson) : 学习笔记\n\n[函数式编程指北](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html) : 详解函数式编程\n\n[前端基础](https://github.com/WindrunnerMax/EveryDay)\n\n[前端Github](https://www.kwgg2020.com/) : 这里最全的资源库\n\n[书栈网](https://www.bookstack.cn/) : 各种api文档\n\n[剑指offer题解](https://github.com/lzxjack/coding-interviews) : 力扣题解\n\n[js基础](https://leohxj.gitbooks.io/front-end-database/content/javascript-basic/index.html)\n\n[大厂面试题每日一题](https://q.shanyue.tech/fe/)\n\n[前端性能优化](https://alienzhou.com/projects/fe-performance-journey/#%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%88%EF%BC%9F) : 性能优化\n\n[现代 JavaScript 教程](https://zh.javascript.info/)\n\n[免费API](https://www.free-api.com/) : 免费API\n\n\n\n### 工具\n\n[在线转换图像文件](https://www.aconvert.com/cn/image/webp-to-jpg/)\n\n[Image Upload](https://sm.ms/)\n\n[在线工具](http://coolaf.com/)","source":"_posts/resource.md","raw":"---\ntitle: 学习资源\ndate: 2021-09-30 09:49:20\ncategories:  resource\ntags: [webpack]\ndescription: 学习资源和工具\ncover: https://i.loli.net/2021/09/30/aCVAZEKkIxMQtzU.jpg\ntop: true\n---\n### 学习资源\n\n[技术胖](https://jspang.com/) : 免费视频教程\n\n[前端工程师大厂面试宝典](https://www.kancloud.cn/pillys/qianduan/2049475) : 面试题\n\n[免费编程资源大全](https://gitee.com/liyupi/free-programming-resources#/liyupi/free-programming-resources/blob/main/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/README.md)  : 免费资源\n\n[React技术揭秘](https://react.iamkasong.com/) : 源码解读\n\n[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/) : 源码解读\n\n[前端面试真题，会80%直接进大厂](https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblEnSV2PNAajtWE&view=vewJHSwJVd) : 面试题\n\n[全栈修仙之路](http://www.semlinker.com/)\n\n[浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/) : 详解浏览器工作原理\n\n[用JavaScript实现的算法和数据结构](http://www.conardli.top/docs/) : 算法\n\n[代码随想录](https://programmercarl.com/) : 算法\n\n[余杭子曰](https://www.yuque.com/robinson) : 学习笔记\n\n[函数式编程指北](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html) : 详解函数式编程\n\n[前端基础](https://github.com/WindrunnerMax/EveryDay)\n\n[前端Github](https://www.kwgg2020.com/) : 这里最全的资源库\n\n[书栈网](https://www.bookstack.cn/) : 各种api文档\n\n[剑指offer题解](https://github.com/lzxjack/coding-interviews) : 力扣题解\n\n[js基础](https://leohxj.gitbooks.io/front-end-database/content/javascript-basic/index.html)\n\n[大厂面试题每日一题](https://q.shanyue.tech/fe/)\n\n[前端性能优化](https://alienzhou.com/projects/fe-performance-journey/#%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%88%EF%BC%9F) : 性能优化\n\n[现代 JavaScript 教程](https://zh.javascript.info/)\n\n[免费API](https://www.free-api.com/) : 免费API\n\n\n\n### 工具\n\n[在线转换图像文件](https://www.aconvert.com/cn/image/webp-to-jpg/)\n\n[Image Upload](https://sm.ms/)\n\n[在线工具](http://coolaf.com/)","slug":"resource","published":1,"updated":"2022-03-25T06:55:23.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1zxk1mj003jdswk7c2wh1mp","content":"<h3 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h3><p><a href=\"https://jspang.com/\">技术胖</a> : 免费视频教程</p>\n<p><a href=\"https://www.kancloud.cn/pillys/qianduan/2049475\">前端工程师大厂面试宝典</a> : 面试题</p>\n<p><a href=\"https://gitee.com/liyupi/free-programming-resources#/liyupi/free-programming-resources/blob/main/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/README.md\">免费编程资源大全</a>  : 免费资源</p>\n<p><a href=\"https://react.iamkasong.com/\">React技术揭秘</a> : 源码解读</p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/\">Vue.js 技术揭秘</a> : 源码解读</p>\n<p><a href=\"https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblEnSV2PNAajtWE&view=vewJHSwJVd\">前端面试真题，会80%直接进大厂</a> : 面试题</p>\n<p><a href=\"http://www.semlinker.com/\">全栈修仙之路</a></p>\n<p><a href=\"https://blog.poetries.top/browser-working-principle/\">浏览器工作原理与实践</a> : 详解浏览器工作原理</p>\n<p><a href=\"http://www.conardli.top/docs/\">用JavaScript实现的算法和数据结构</a> : 算法</p>\n<p><a href=\"https://programmercarl.com/\">代码随想录</a> : 算法</p>\n<p><a href=\"https://www.yuque.com/robinson\">余杭子曰</a> : 学习笔记</p>\n<p><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html\">函数式编程指北</a> : 详解函数式编程</p>\n<p><a href=\"https://github.com/WindrunnerMax/EveryDay\">前端基础</a></p>\n<p><a href=\"https://www.kwgg2020.com/\">前端Github</a> : 这里最全的资源库</p>\n<p><a href=\"https://www.bookstack.cn/\">书栈网</a> : 各种api文档</p>\n<p><a href=\"https://github.com/lzxjack/coding-interviews\">剑指offer题解</a> : 力扣题解</p>\n<p><a href=\"https://leohxj.gitbooks.io/front-end-database/content/javascript-basic/index.html\">js基础</a></p>\n<p><a href=\"https://q.shanyue.tech/fe/\">大厂面试题每日一题</a></p>\n<p><a href=\"https://alienzhou.com/projects/fe-performance-journey/#%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%88%EF%BC%9F\">前端性能优化</a> : 性能优化</p>\n<p><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></p>\n<p><a href=\"https://www.free-api.com/\">免费API</a> : 免费API</p>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p><a href=\"https://www.aconvert.com/cn/image/webp-to-jpg/\">在线转换图像文件</a></p>\n<p><a href=\"https://sm.ms/\">Image Upload</a></p>\n<p><a href=\"http://coolaf.com/\">在线工具</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h3><p><a href=\"https://jspang.com/\">技术胖</a> : 免费视频教程</p>\n<p><a href=\"https://www.kancloud.cn/pillys/qianduan/2049475\">前端工程师大厂面试宝典</a> : 面试题</p>\n<p><a href=\"https://gitee.com/liyupi/free-programming-resources#/liyupi/free-programming-resources/blob/main/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/README.md\">免费编程资源大全</a>  : 免费资源</p>\n<p><a href=\"https://react.iamkasong.com/\">React技术揭秘</a> : 源码解读</p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/\">Vue.js 技术揭秘</a> : 源码解读</p>\n<p><a href=\"https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblEnSV2PNAajtWE&view=vewJHSwJVd\">前端面试真题，会80%直接进大厂</a> : 面试题</p>\n<p><a href=\"http://www.semlinker.com/\">全栈修仙之路</a></p>\n<p><a href=\"https://blog.poetries.top/browser-working-principle/\">浏览器工作原理与实践</a> : 详解浏览器工作原理</p>\n<p><a href=\"http://www.conardli.top/docs/\">用JavaScript实现的算法和数据结构</a> : 算法</p>\n<p><a href=\"https://programmercarl.com/\">代码随想录</a> : 算法</p>\n<p><a href=\"https://www.yuque.com/robinson\">余杭子曰</a> : 学习笔记</p>\n<p><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html\">函数式编程指北</a> : 详解函数式编程</p>\n<p><a href=\"https://github.com/WindrunnerMax/EveryDay\">前端基础</a></p>\n<p><a href=\"https://www.kwgg2020.com/\">前端Github</a> : 这里最全的资源库</p>\n<p><a href=\"https://www.bookstack.cn/\">书栈网</a> : 各种api文档</p>\n<p><a href=\"https://github.com/lzxjack/coding-interviews\">剑指offer题解</a> : 力扣题解</p>\n<p><a href=\"https://leohxj.gitbooks.io/front-end-database/content/javascript-basic/index.html\">js基础</a></p>\n<p><a href=\"https://q.shanyue.tech/fe/\">大厂面试题每日一题</a></p>\n<p><a href=\"https://alienzhou.com/projects/fe-performance-journey/#%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%88%EF%BC%9F\">前端性能优化</a> : 性能优化</p>\n<p><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></p>\n<p><a href=\"https://www.free-api.com/\">免费API</a> : 免费API</p>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p><a href=\"https://www.aconvert.com/cn/image/webp-to-jpg/\">在线转换图像文件</a></p>\n<p><a href=\"https://sm.ms/\">Image Upload</a></p>\n<p><a href=\"http://coolaf.com/\">在线工具</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl1zxk1kz0000dswkfk2nhy3k","category_id":"cl1zxk1l80002dswkfdzs8i72","_id":"cl1zxk1le000cdswk8t838dit"},{"post_id":"cl1zxk1l70001dswke2jsefa4","category_id":"cl1zxk1lc0007dswk1fdk33tw","_id":"cl1zxk1lg000jdswk5oix0yfu"},{"post_id":"cl1zxk1le000bdswk6b0i8khf","category_id":"cl1zxk1lc0007dswk1fdk33tw","_id":"cl1zxk1li000odswke1ar2e6u"},{"post_id":"cl1zxk1lf000fdswkgd79222q","category_id":"cl1zxk1lc0007dswk1fdk33tw","_id":"cl1zxk1lj000rdswkgpq24r2q"},{"post_id":"cl1zxk1l90004dswk32isdvn5","category_id":"cl1zxk1le000ddswkc8m1cdi1","_id":"cl1zxk1ll000vdswk2y2p6k21"},{"post_id":"cl1zxk1la0005dswk3mkqfghe","category_id":"cl1zxk1lg000kdswk21re7sal","_id":"cl1zxk1ln000zdswkf5f416fv"},{"post_id":"cl1zxk1lb0006dswkc03s3xdj","category_id":"cl1zxk1lc0007dswk1fdk33tw","_id":"cl1zxk1lp0016dswka1ni4px0"},{"post_id":"cl1zxk1lm000xdswkh8ur4evz","category_id":"cl1zxk1le000ddswkc8m1cdi1","_id":"cl1zxk1lq001adswkfd9o4xo3"},{"post_id":"cl1zxk1ln0011dswk5yzo9lm1","category_id":"cl1zxk1le000ddswkc8m1cdi1","_id":"cl1zxk1lq001ddswk1n3h1tlk"},{"post_id":"cl1zxk1ld000adswkdrrq9zol","category_id":"cl1zxk1lg000kdswk21re7sal","_id":"cl1zxk1ls001idswkceen6ouu"},{"post_id":"cl1zxk1lo0013dswkbqc17pzt","category_id":"cl1zxk1le000ddswkc8m1cdi1","_id":"cl1zxk1lw001ldswk5k6agbrl"},{"post_id":"cl1zxk1lp0018dswkckxd01t4","category_id":"cl1zxk1le000ddswkc8m1cdi1","_id":"cl1zxk1ly001qdswkhk5b9wxn"},{"post_id":"cl1zxk1lq001bdswkfmzah7x2","category_id":"cl1zxk1le000ddswkc8m1cdi1","_id":"cl1zxk1ly001sdswkb72ke7xe"},{"post_id":"cl1zxk1lf000hdswkh7fmcoi6","category_id":"cl1zxk1lp0015dswk68wc4wv7","_id":"cl1zxk1lz001wdswka9f9dfya"},{"post_id":"cl1zxk1lh000mdswk5zwb9j8l","category_id":"cl1zxk1lp0015dswk68wc4wv7","_id":"cl1zxk1lz001ydswkhy2labg7"},{"post_id":"cl1zxk1lj000pdswk8cx36cd5","category_id":"cl1zxk1lp0015dswk68wc4wv7","_id":"cl1zxk1m00021dswkbkhb4o6f"},{"post_id":"cl1zxk1lk000udswkgzgxau1c","category_id":"cl1zxk1lp0015dswk68wc4wv7","_id":"cl1zxk1m00023dswk43ji41au"},{"post_id":"cl1zxk1lr001edswk33u37moy","category_id":"cl1zxk1lz001zdswk4ek09288","_id":"cl1zxk1m00027dswkb44igvrl"},{"post_id":"cl1zxk1ls001jdswk8vcl72e4","category_id":"cl1zxk1m00024dswkabm0bq5v","_id":"cl1zxk1m10029dswk72ksgzw0"},{"post_id":"cl1zxk1m5002fdswketh205p9","category_id":"cl1zxk1m4002cdswk8d23hys7","_id":"cl1zxk1m8002ndswkg4xb0txd"},{"post_id":"cl1zxk1m3002adswk59pkc0mc","category_id":"cl1zxk1m4002cdswk8d23hys7","_id":"cl1zxk1m9002sdswk1z7755pj"},{"post_id":"cl1zxk1m6002gdswkeasof962","category_id":"cl1zxk1m4002cdswk8d23hys7","_id":"cl1zxk1ma002vdswk35s85uqw"},{"post_id":"cl1zxk1m4002bdswkes2p7m5s","category_id":"cl1zxk1m4002cdswk8d23hys7","_id":"cl1zxk1md0030dswk12lq5qf1"},{"post_id":"cl1zxk1m5002edswkgwrzecku","category_id":"cl1zxk1m4002cdswk8d23hys7","_id":"cl1zxk1me0032dswk2ftd8t13"},{"post_id":"cl1zxk1m7002kdswk4l4z1ark","category_id":"cl1zxk1ma002wdswk149f5ypk","_id":"cl1zxk1mg0038dswkd8944380"},{"post_id":"cl1zxk1me0035dswkhwmxaxp8","category_id":"cl1zxk1lg000kdswk21re7sal","_id":"cl1zxk1mi003fdswkhkdjh1d3"},{"post_id":"cl1zxk1m8002mdswkeefj19iw","category_id":"cl1zxk1me0033dswk76dp5lsi","_id":"cl1zxk1mj003kdswkhy0g54zq"},{"post_id":"cl1zxk1mf0037dswk26qpav4w","category_id":"cl1zxk1lg000kdswk21re7sal","_id":"cl1zxk1mk003mdswk2e6taghq"},{"post_id":"cl1zxk1m9002rdswkdueq7o10","category_id":"cl1zxk1mg0039dswk73mk70xd","_id":"cl1zxk1mk003odswkbukr24vj"},{"post_id":"cl1zxk1mh003edswkhypc0fbg","category_id":"cl1zxk1lc0007dswk1fdk33tw","_id":"cl1zxk1ml003sdswk675r2wcn"},{"post_id":"cl1zxk1ma002udswkfaif0ovl","category_id":"cl1zxk1mi003hdswkfkhwbpwx","_id":"cl1zxk1ml003udswkfkibd78m"},{"post_id":"cl1zxk1mc002zdswk9bby5keh","category_id":"cl1zxk1mk003pdswkhiho1yd1","_id":"cl1zxk1mm003ydswk61z4751e"},{"post_id":"cl1zxk1md0031dswkf40u1ti0","category_id":"cl1zxk1ml003vdswk0l7b654p","_id":"cl1zxk1mm0042dswk46mwhs1l"},{"post_id":"cl1zxk1mg003cdswkfapie6u5","category_id":"cl1zxk1mm003zdswk6zrt3d9x","_id":"cl1zxk1mn0045dswk8hleawkf"},{"post_id":"cl1zxk1mj003jdswk7c2wh1mp","category_id":"cl1zxk1mm0043dswk4dm33iks","_id":"cl1zxk1mn0046dswkfmqv8fdl"}],"PostTag":[{"post_id":"cl1zxk1kz0000dswkfk2nhy3k","tag_id":"cl1zxk1l90003dswk3ur9arcb","_id":"cl1zxk1lc0009dswkgufea4oi"},{"post_id":"cl1zxk1l70001dswke2jsefa4","tag_id":"cl1zxk1lc0008dswkfpgsh8r0","_id":"cl1zxk1lf000gdswkhpid62b0"},{"post_id":"cl1zxk1le000bdswk6b0i8khf","tag_id":"cl1zxk1lc0008dswkfpgsh8r0","_id":"cl1zxk1lg000idswk8ytsfh9l"},{"post_id":"cl1zxk1lf000fdswkgd79222q","tag_id":"cl1zxk1lc0008dswkfpgsh8r0","_id":"cl1zxk1li000ndswkap3v05o5"},{"post_id":"cl1zxk1l90004dswk32isdvn5","tag_id":"cl1zxk1le000edswkahcughmo","_id":"cl1zxk1lj000qdswkgu87dcvx"},{"post_id":"cl1zxk1la0005dswk3mkqfghe","tag_id":"cl1zxk1lg000ldswk784s6zt4","_id":"cl1zxk1lm000wdswkgsi01z86"},{"post_id":"cl1zxk1lb0006dswkc03s3xdj","tag_id":"cl1zxk1lc0008dswkfpgsh8r0","_id":"cl1zxk1lo0012dswk4mo0fhwv"},{"post_id":"cl1zxk1lm000xdswkh8ur4evz","tag_id":"cl1zxk1le000edswkahcughmo","_id":"cl1zxk1lo0014dswk8p0tg0bc"},{"post_id":"cl1zxk1ln0011dswk5yzo9lm1","tag_id":"cl1zxk1le000edswkahcughmo","_id":"cl1zxk1lq0019dswkc7m3emot"},{"post_id":"cl1zxk1ld000adswkdrrq9zol","tag_id":"cl1zxk1lg000ldswk784s6zt4","_id":"cl1zxk1lq001cdswk1eq7gujp"},{"post_id":"cl1zxk1lo0013dswkbqc17pzt","tag_id":"cl1zxk1le000edswkahcughmo","_id":"cl1zxk1ls001hdswk7m5m4m7a"},{"post_id":"cl1zxk1lp0018dswkckxd01t4","tag_id":"cl1zxk1le000edswkahcughmo","_id":"cl1zxk1lw001kdswkgg437a9y"},{"post_id":"cl1zxk1lq001bdswkfmzah7x2","tag_id":"cl1zxk1le000edswkahcughmo","_id":"cl1zxk1ly001pdswkc9pt5l38"},{"post_id":"cl1zxk1lf000hdswkh7fmcoi6","tag_id":"cl1zxk1lp0017dswk0ac0c0hl","_id":"cl1zxk1ly001rdswk2pva3uae"},{"post_id":"cl1zxk1lh000mdswk5zwb9j8l","tag_id":"cl1zxk1lp0017dswk0ac0c0hl","_id":"cl1zxk1lz001vdswk41d1bjdl"},{"post_id":"cl1zxk1lj000pdswk8cx36cd5","tag_id":"cl1zxk1lp0017dswk0ac0c0hl","_id":"cl1zxk1lz001xdswk9s1kd3wi"},{"post_id":"cl1zxk1lk000udswkgzgxau1c","tag_id":"cl1zxk1lp0017dswk0ac0c0hl","_id":"cl1zxk1m00022dswkh4pmfd4y"},{"post_id":"cl1zxk1lr001edswk33u37moy","tag_id":"cl1zxk1lz0020dswkgh6qedkv","_id":"cl1zxk1m00026dswkdhdy74x1"},{"post_id":"cl1zxk1ls001jdswk8vcl72e4","tag_id":"cl1zxk1m00025dswk6v4edcqf","_id":"cl1zxk1m10028dswkcicagpzb"},{"post_id":"cl1zxk1m5002fdswketh205p9","tag_id":"cl1zxk1m4002ddswkcq3ecohu","_id":"cl1zxk1m7002jdswk11k38xs8"},{"post_id":"cl1zxk1m3002adswk59pkc0mc","tag_id":"cl1zxk1m4002ddswkcq3ecohu","_id":"cl1zxk1m8002ldswk7g038unf"},{"post_id":"cl1zxk1m6002gdswkeasof962","tag_id":"cl1zxk1m4002ddswkcq3ecohu","_id":"cl1zxk1m9002qdswkfejtgf48"},{"post_id":"cl1zxk1m4002bdswkes2p7m5s","tag_id":"cl1zxk1m4002ddswkcq3ecohu","_id":"cl1zxk1ma002tdswke72xa6jx"},{"post_id":"cl1zxk1m5002edswkgwrzecku","tag_id":"cl1zxk1m4002ddswkcq3ecohu","_id":"cl1zxk1mc002ydswkcyuebabi"},{"post_id":"cl1zxk1m7002kdswk4l4z1ark","tag_id":"cl1zxk1ma002xdswk117u06pk","_id":"cl1zxk1me0036dswk9l7z5uxt"},{"post_id":"cl1zxk1me0035dswkhwmxaxp8","tag_id":"cl1zxk1lg000ldswk784s6zt4","_id":"cl1zxk1mg003bdswk7vcs2sag"},{"post_id":"cl1zxk1m8002mdswkeefj19iw","tag_id":"cl1zxk1me0034dswk3w4c75sa","_id":"cl1zxk1mh003ddswk5rgz9ya3"},{"post_id":"cl1zxk1mf0037dswk26qpav4w","tag_id":"cl1zxk1lg000ldswk784s6zt4","_id":"cl1zxk1mi003gdswkceq76rzx"},{"post_id":"cl1zxk1m9002rdswkdueq7o10","tag_id":"cl1zxk1mg003adswkcvzl1mw5","_id":"cl1zxk1mj003ldswk9e88bgt2"},{"post_id":"cl1zxk1mh003edswkhypc0fbg","tag_id":"cl1zxk1lc0008dswkfpgsh8r0","_id":"cl1zxk1mk003ndswk1fww1jgv"},{"post_id":"cl1zxk1mj003jdswk7c2wh1mp","tag_id":"cl1zxk1lg000ldswk784s6zt4","_id":"cl1zxk1ml003rdswk0gjgfnzq"},{"post_id":"cl1zxk1ma002udswkfaif0ovl","tag_id":"cl1zxk1mi003idswk95ov8m94","_id":"cl1zxk1ml003tdswk0sg8clli"},{"post_id":"cl1zxk1mc002zdswk9bby5keh","tag_id":"cl1zxk1mk003qdswk0z9zeu8t","_id":"cl1zxk1ml003xdswk3zm47sly"},{"post_id":"cl1zxk1md0031dswkf40u1ti0","tag_id":"cl1zxk1ml003wdswkdm4f881n","_id":"cl1zxk1mm0041dswk15o22glm"},{"post_id":"cl1zxk1mg003cdswkfapie6u5","tag_id":"cl1zxk1mm0040dswkdp7lcctn","_id":"cl1zxk1mm0044dswkhag9ef5j"}],"Tag":[{"name":"http","_id":"cl1zxk1l90003dswk3ur9arcb"},{"name":"vue","_id":"cl1zxk1lc0008dswkfpgsh8r0"},{"name":"浏览器","_id":"cl1zxk1le000edswkahcughmo"},{"name":"webpack","_id":"cl1zxk1lg000ldswk784s6zt4"},{"name":"算法","_id":"cl1zxk1lp0017dswk0ac0c0hl"},{"name":"CSS","_id":"cl1zxk1lz0020dswkgh6qedkv"},{"name":"HTML","_id":"cl1zxk1m00025dswk6v4edcqf"},{"name":"网络","_id":"cl1zxk1m4002ddswkcq3ecohu"},{"name":"服务器","_id":"cl1zxk1ma002xdswk117u06pk"},{"name":"项目","_id":"cl1zxk1me0034dswk3w4c75sa"},{"name":"React","_id":"cl1zxk1mg003adswkcvzl1mw5"},{"name":"react","_id":"cl1zxk1mi003idswk95ov8m94"},{"name":"微前端","_id":"cl1zxk1mk003qdswk0z9zeu8t"},{"name":"component","_id":"cl1zxk1ml003wdswkdm4f881n"},{"name":"WORK","_id":"cl1zxk1mm0040dswkdp7lcctn"}]}}